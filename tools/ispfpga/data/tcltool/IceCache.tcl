


proc  Ice:cache:write_init {doth dotc idfile} {
    global Ice_state arch ARCH cell CELL CLASS idfile_name doth_name dotc_name sp

    puts $idfile "/*******  WARNING: This file has been generated by Ice ****************/"
    puts $doth "/*******  WARNING: This file has been generated by Ice ****************/"
    puts $dotc "/*******  WARNING: This file has been generated by Ice ****************/"

    puts $idfile  "#ifndef ${ARCH}_CM_${CELL}_BASE_CACHE_IDS_H"
    puts $idfile  "#define ${ARCH}_CM_${CELL}_BASE_CACHE_IDS_H\n"
    puts $idfile  "#ifndef ${ARCH}_CM_TYPES_H"
    puts $idfile  "#include \"${arch}cmtypes.h\""
    puts $idfile  "#endif\n"

    puts $doth  "#ifndef ${ARCH}_CM_${CELL}_BASECACHE_H"
    puts $doth  "#define ${ARCH}_CM_${CELL}_BASECACHE_H\n"
    puts $doth  "#ifndef ${ARCH}_CM_DBG_H"
    puts $doth  "#include \"${arch}cmdbg.h\""
    puts $doth  "#endif\n"
    puts $doth  "#ifndef ${ARCH}_CM_TYPES_H"
    puts $doth  "#include \"${arch}cmtypes.h\""
    puts $doth  "#endif\n"
    puts $doth  "#ifndef ${ARCH}_CM_${CELL}_BASE_CACHE_IDS_H"
    puts $doth  "#include \"${idfile_name}\""
    puts $doth  "#endif\n"
    puts $doth  "#ifndef ${ARCH}_CM_DLL"
    puts $doth  "#define ${ARCH}_CM_DLL DLLIMPORT"
    puts $doth  "#endif\n\n"

    puts $dotc "////////////////////////////////////////////////////////////////////////"
    puts $dotc "// Copyright 1996-1997 Lucent Technologies.  All rights reserved."
    puts $dotc "// File                                                          "
    puts $dotc "//    $dotc_name                                                 "
    puts $dotc "// Purpose:                                                      "
    puts $dotc "//    ${ARCH}00 ${CELL} cache  member functions.                 "
    puts $dotc "////////////////////////////////////////////////////////////////////////\n"
    puts $dotc "#define ${ARCH}_CM_DLL DLLEXPORT"
    puts $dotc "#ifndef BAS_UT_MSGMAN_H"
    puts $dotc "#include \"base/pkg/basutil/i/basutmsgman.h\""
    puts $dotc "#endif\n"
    puts $dotc "#ifndef BAS_UT_STROBJ_H"
    puts $dotc "#include \"base/pkg/basutil/i/basutstrobj.h\""
    puts $dotc "#endif\n"
    puts $dotc "#ifndef BAS_PM_DLM_H"
    puts $dotc "#include \"base/pkg/baspm/i/baspmdlm.h\""
    puts $dotc "#endif\n"
    puts $dotc "#ifndef ${ARCH}_CM_UTIL_H"
    puts $dotc "#include \"${arch}cmutil.h\""
    puts $dotc "#endif\n"
    puts $dotc "#ifndef ${ARCH}_CM_${CELL}_CACHE_H"
    puts $dotc "#include \"$doth_name\""
    puts $dotc "#endif\n"
    puts $dotc "\n\n\n"
}

proc  Ice:cache:write_class {doth dotc} {
    global Ice_state arch ARCH cell CELL CLASS sp

    puts $doth  "// ${ARCH}CM_${CELL}CACHE is a singleton class:  only one instance will exist."
    puts $doth  "//  To gain access to this instance, call ${ARCH}CM_${CELL}CACHE::instance()."
    puts $doth  "//  Also created and returned by ${CLASS}::buildme(cm)."
    puts $doth  "class ${CLASS}"
    puts $doth  "\{"
    puts $doth  "#ifdef ${ARCH}CM_TEST_FRIENDS\n${ARCH}CM_TEST_FRIENDS\n#endif"
    puts $doth  ""
    puts $doth  "protected:"
    puts $doth  "${sp}// This is a singleton class.  This represents the single instance of this class.."
    puts $doth  "${sp}${ARCH}_CM_DLL static ${CLASS} *_instance;"
    puts $doth  "${sp}${ARCH}_CM_DLL ${CLASS}(CM_CELLMODEL *cm);"
    puts $doth "\n\n"


    puts $dotc  "${CLASS} *${CLASS}::_instance = NULL;\n\n"
    puts $dotc "${CLASS} *\n${CLASS}::buildme(CM_CELLMODEL *cm) \n\{"
    puts $dotc "${sp}if (_instance != NULL)\n${sp}${sp}return _instance;"
    puts $dotc "${sp}typedef ${CLASS}* (* BUILDER)(CM_CELLMODEL *cm);"
    puts $dotc "${sp}PM_DLM *dlm = cm->getdlm();"
    puts $dotc "${sp}BUILDER builder = (BUILDER) dlm->get_ventrypoint(\"CM_${CELL}CACHE\");"
    puts $dotc "${sp}if (builder != NULL)\n${sp}${sp}_instance = builder(cm);"
    puts $dotc "${sp}else\n${sp}${sp}_instance = new ${CLASS}(cm);"
    puts $dotc "${sp}return _instance;"
    puts $dotc "\}\n"
}



proc  Ice:cache:write_end {doth dotc idfile} {
    puts $doth "\n\n\};\n\n"
    puts $doth "#endif"

    puts $idfile "#endif"
}


proc Ice:cache:collect { list type} {
    global $list prims modes ${list}_elts CLASS
    set $list [list]
    array set ${list}_elts ""
    foreach mode $modes {
	foreach prim [GRAPH:get_elements $mode $type] {
	    if [GRAPH:get_attr $prim cmOk 0] {
		set name [GRAPH:get_attr $prim name]

		if {![info exists prims($list,$name)]} {
		    set prims($list,$name) $prim
		    lappend $list $name
		    set ${list}_elts($name)  $prim
		}
	    }
	}
    }
    set $list [lsort  -ascii [set $list]]
}

proc Ice:get_buttons {prim} {
    set buttons [list]
    ## Buttons are Boolean properties.  The attrNameValue is of the form: " A: ; B: ; C:"
    #puts "Looking for buttons on [GRAPH:get_attr $prim name]: [GRAPH:get_attr $prim attrNameValue]" 
    foreach pair [split  [GRAPH:get_attr $prim attrNameValue ""] ";" ] {
	set tmp   [split $pair :]
	set name  [string toupper [string trim [lindex $tmp 0] ]]
	set value [string trim [lindex $tmp 1]]

	if {![UTIL:strck $value] && [UTIL:strck $name]} {
	    ## a boolean
	    lappend buttons $name
	}
    }

    ##Now do the same thing for any connected prims
    foreach succ [GRAPH:succs $prim Ice_AttributeOf] {
	#puts "succ: Looking for buttons on [GRAPH:get_attr $succ name]: [GRAPH:get_attr $succ attrNameValue]" 
	set pairs   [split  [GRAPH:get_attr $succ attrNameValue ""] ";" ]
	foreach pair $pairs {
	    set tmp   [split $pair :]
	    set name  [string toupper [string trim [lindex $tmp 0] ]]
	    set value [string trim [lindex $tmp 1]]
	    #puts "Sucking in a button: $name"
	    if {![UTIL:strck $value] && [UTIL:strck $name]} {
		lappend buttons $name
	    } else {
		#puts "Lost $name:$value"
	    }
	}
    }
    return $buttons
}

proc Ice:get_named_props {prim} {
    set namedProps [list]
    ## Named properties are of the form: "PROP:A B C" where A B and C are
    ## the possible values of the property named PROP

    foreach attr [GRAPH:succs $prim Ice_AttributeOf] {
	foreach pair [split  [GRAPH:get_attr $attr attrNameValue ""] ";" ] {
	    set tmp   [split $pair :]
	    set name  [string toupper [string trim [lindex $tmp 0] ]]
	    set value [string trim [lindex $tmp 1]]
	    
	    if {[UTIL:strck $name] && [UTIL:strck $value]} {
		## a named prop
		lappend namedProps $name
	    }
	}
    }
    return $namedProps
}



proc Ice:cache:write_list {idfile name list_name } {
    global Ice_state arch ARCH cell CELL handleArrayDecl handleArrayAccess handleArrayImpl CLASS $list_name ${list_name}_elts sp pinCnt buttonCnt namedPropCnt pinIdStr buttonIdStr namedPropIdStr pinType buttonType namedPropType pinHandleArray buttonHandleArray namedPropHandleArray modeHandleArray
    set type  ${ARCH}CM_CONTEXT_${name}
    set primHandleArray [string tolower $name]_handle

    set cnt 0
    set low  "${ARCH}CM_${CELL}_${name}_LOW"

    ## Only do modes when we're looking at modeboxes
    set domodes [expr [string compare $name "MODEBOX"] == 0]

    foreach tag [set $list_name] {
	if {$cnt == 0} {
	    puts $idfile "\n// ${name} constants for ${cell}"
	    puts $idfile "const $type $low = 0;"
	}

	set elt [set ${list_name}_elts($tag)]
	set const ${ARCH}CM_${CELL}_${name}_$tag
	#lappend handleArrayImpl "\n${sp}//Get the handles for $name ${tag}"
	lappend handleArrayImpl "cp = NULL;"
	lappend handleArrayImpl "$primHandleArray\[$const\] =\n${sp}${sp}cm->gethandle\(\"$tag\", cp, rpt_err);"
	puts $idfile "const $type $const = $cnt;"
	incr cnt

	foreach pin [GRAPH:succs $elt Ice_PinOf] {
	    set pinname [GRAPH:get_attr $pin name]
	    set const ${ARCH}CM_${CELL}_PRIMPIN_${tag}_${pinname}
	    lappend pinIdStr  "const $pinType $const = $pinCnt;"
	    lappend handleArrayImpl "${pinHandleArray}\[$const\] =\n${sp}${sp}\(cp==NULL\) ? CM_BAD_HANDLE : cm->getpinhandle\(cp, \"$pinname\", rpt_err\);"
	    incr pinCnt
	}

	foreach namedProp [Ice:get_named_props $elt] {
	    set const      ${ARCH}CM_${CELL}_${tag}_NAMEDPROP_${namedProp}
	    
	    lappend namedPropIdStr  "const $namedPropType $const = $namedPropCnt;"
	    lappend handleArrayImpl "${namedPropHandleArray}\[$const\] = (cp == NULL) ?\n${sp}${sp}CM_BAD_HANDLE : cm->getpropertyhandle\(cp, \"$namedProp\", rpt_err);"
	    
	    incr namedPropCnt
	}

	if {[string length [GRAPH:preds $elt Ice_AttributeOf]]} {
	    #puts "Have a prim with an incoming attribute of edge - skipping"
	} else {
	    foreach button [Ice:get_buttons $elt] {
 		regsub {\.} $button P tmp
		set const      ${ARCH}CM_${CELL}_${name}_${tag}_BUTTON_${tmp}
		set modeConst  ${ARCH}CM_${CELL}_MODE_${button}
		lappend buttonIdStr  "const $buttonType $const = $buttonCnt;"
		lappend handleArrayImpl "${buttonHandleArray}\[$const\] = (cp == NULL) ?\n${sp}${sp}CM_BAD_HANDLE : cm->getpropertyhandle\(cp, \"$button\", rpt_err);"
		
		if {$domodes} {
		    lappend handleArrayImpl "${modeHandleArray}\[$modeConst\] = ${buttonHandleArray}\[$const\];"
		}
		incr buttonCnt
	    }
	}
    }



    if {$cnt != 0} {
	incr cnt -1
	set high  "${ARCH}CM_${CELL}_${name}_HIGH"
	puts $idfile "const $type $high = $cnt;\n\n";
	lappend  handleArrayImpl "\n"
	lappend  handleArrayDecl "${sp}//$name handles\n${sp}CM_HANDLE $primHandleArray\[$high + 1];\n"
	lappend  handleArrayAccess "${sp}virtual CM_HANDLE get_[string tolower $name]_handle\($type idx)\n${sp}\{\n${sp}${sp}return\n${sp}${sp}${sp}(idx < $low || idx > $high) ?\n${sp}${sp}${sp}CM_BAD_HANDLE : $primHandleArray\[idx\];\n${sp}\}\n"
    }
}


proc    Ice:cache:write_decl {doth list {pre ""} {post ""} {comment  ""} {type CM_HANDLE}}  {
    puts $doth "\n$comment"
    foreach tag $list {
	puts $doth "${sp}$type ${pre}${tag}${post};"
    }
}




proc Ice:cache:write {} {
    global Ice_state arch ARCH cell CELL CLASS  idfile_name doth_name dotc_name modes sp
    global prims handleArrayDecl handleArrayAccess handleArrayImpl
    global buttonIdStr namedPropIdStr pinIdStr modeHandleArray

    set arch [string tolower $Ice_state(arg,arch)]
    set ARCH [string toupper $Ice_state(arg,arch)]
    set sp "   "

    set cell [string tolower $Ice_state(cellname)]
    set CELL [string toupper $Ice_state(cellname)]


    set CLASS ${ARCH}CM_${CELL}_BASECACHE


    set fileRoot ${arch}cm[string tolower ${cell}]basecache

    set idfile_name ${fileRoot}_ids.h
    set doth_name  ${fileRoot}.h
    set dotc_name  ${fileRoot}.c

    set idfile [open  $idfile_name w]
    set doth   [open  $doth_name w]
    set dotc   [open  $dotc_name w]


    Ice:cache:write_init $doth $dotc $idfile


    set modes [list]

    foreach mode  [GRAPH:get_graphs] {
	if [GRAPH:get_attr $mode cmOk 0] {
	    lappend modes $mode
	}
    }


    set modenames [list]
    set MODENAMES [list]

    foreach mode $modes {
	set modename  [GRAPH:get_attr $mode name]
	lappend modenames [string tolower $modename]
	lappend MODENAMES [string toupper $modename]
    }

    set modenames [lsort -ascii $modenames]
    set MODENAMES [lsort -ascii $MODENAMES]

    array set prims ""
    set handleArrayDecl [list]
    set handleArrayAccess [list]
    set handleArrayImpl [list]

    set pinIdStr [list]
    set buttonIdStr [list]
    set namedPropIdStr [list]


    global bboxes luts muxes tribufs flipflops modeboxes ports

    Ice:cache:collect bboxes Ice_BlackBox
    Ice:cache:collect modeboxes Ice_ModeBox
    Ice:cache:collect luts Ice_Lut
    Ice:cache:collect muxes Ice_Mux
    Ice:cache:collect tribufs Ice_TriBuf
    Ice:cache:collect flipflops Ice_FlipFlop
    Ice:cache:collect alus Ice_Alu

    ## global inputports outputports
    ##Ice:cache:collect inputports Ice_InputPort
    ##Ice:cache:collect outputports Ice_OutputPort

    #Ice:cache:collect attributes Ice_AttributePrim
    #Ice:cache:collect_attrs attributes
    Ice:cache:collect ports      Ice_CellPort

    global pinCnt pinType pinHandleArray
    set pinCnt 0
    set pinType  ${ARCH}CM_CONTEXT_PRIMPIN
    set pinHandleArray "pin_handle"
    set pinLow ${ARCH}CM_${CELL}_PRIMPIN_LOW
    set pinHigh ${ARCH}CM_${CELL}_PRIMPIN_HIGH
    set pinNone ${ARCH}CM_${CELL}_NO_PRIMPIN
    
    
    global buttonCnt buttonType buttonHandleArray
    set buttonCnt 0
    set buttonType  ${ARCH}CM_CONTEXT_BUTTON
    set buttonHandleArray "button_handle"
    set buttonLow ${ARCH}CM_${CELL}_BUTTON_LOW
    set buttonHigh ${ARCH}CM_${CELL}_BUTTON_HIGH
    set buttonNone ${ARCH}CM_${CELL}_NO_BUTTON
    
    global namedPropCnt namedPropType namedPropHandleArray
    set namedPropCnt 0
    set namedPropType  ${ARCH}CM_CONTEXT_NAMEDPROP
    set namedPropHandleArray "namedProp_handle"
    set namedPropLow ${ARCH}CM_${CELL}_NAMEDPROP_LOW
    set namedPropHigh ${ARCH}CM_${CELL}_NAMEDPROP_HIGH
    set namedPropNone ${ARCH}CM_${CELL}_NO_NAMEDPROP
    
    ## print out mode constants
    set type "${ARCH}CM_CONTEXT_MODE"
    set prefix "${ARCH}CM_${CELL}"
    set modeLow "${prefix}_MODE_LOW"
    set modeHigh "${prefix}_MODE_HIGH"
    set cnt 0
    puts $idfile "\n// MODE constants for ${cell}"
    puts $idfile "const $type ${modeLow} = 0;"
    
    foreach mode $MODENAMES {
	puts $idfile "const $type ${prefix}_MODE_${mode} = $cnt;"
	incr cnt
    }
    puts $idfile "const $type $modeHigh = [expr $cnt - 1];"
    
    
    set modeHandleArray "mode_handle"
    lappend handleArrayDecl "${sp}// Mode handles"
    lappend handleArrayDecl "${sp}CM_HANDLE ${modeHandleArray}\[$modeHigh + 1];\n"
    lappend handleArrayAccess "${sp}virtual CM_HANDLE get_mode_handle\($type idx)\n${sp}\{\n${sp}${sp}return\n${sp}${sp}${sp}(idx < $modeLow || idx > $modeHigh) ?\n${sp}${sp}${sp}CM_BAD_HANDLE : $modeHandleArray\[idx\];\n${sp}\}\n"
    
    Ice:cache:write_list $idfile MODEBOX modeboxes
    #Ice:cache:write_list $idfile ATTRIBUTE attributes
    Ice:cache:write_list $idfile BBOX bboxes
    Ice:cache:write_list $idfile LUT luts
    Ice:cache:write_list $idfile MUX muxes
    Ice:cache:write_list $idfile TRIBUF tribufs
    Ice:cache:write_list $idfile FLIPFLOP flipflops
    Ice:cache:write_list $idfile ALU alus
    Ice:cache:write_list $idfile PORT ports
    ##Ice:cache:write_list $idfile INPUTPORT $inputports
    ##Ice:cache:write_list $idfile OUTPUTPORT $outputports

    Ice:cache:write_class $doth $dotc
    lappend handleArrayDecl "${sp}// Primitive pin handles"
    lappend handleArrayDecl "${sp}CM_HANDLE ${pinHandleArray}\[$pinHigh + 1];\n"
    lappend handleArrayDecl "${sp}// Button handles"
    lappend handleArrayDecl "${sp}CM_HANDLE ${buttonHandleArray}\[$buttonHigh + 1];\n"
    lappend handleArrayDecl "${sp}// NamedProp handles"
    lappend handleArrayDecl "${sp}CM_HANDLE ${namedPropHandleArray}\[$namedPropHigh + 1];\n"

    ##Write out the CM_HANDLE arrays
    foreach line $handleArrayDecl {
	puts $doth $line
    }

    puts $doth  "protected:"
    puts $doth  "${sp}virtual void initmodes\(){}"

    puts $doth "\n\npublic:"
    puts $doth "${sp}// Use one of the following two methods to gain access to the"
    puts $doth "${sp}//  single instance of this class..  The latter will not create"
    puts $doth "${sp}//  the instance if it does not exist.\n"
    puts $doth "${sp}static ${CLASS} *buildme(CM_CELLMODEL *cm);"
    puts $doth "${sp}${ARCH}_CM_DLL static ${CLASS} *instance()\{return _instance; \}\n"
    puts $doth  "${sp}${ARCH}_CM_DLL virtual ~${CLASS}(){_instance = NULL;}\n\n"


    puts $dotc "${ARCH}_CM_DLL\n${CLASS}::${CLASS}(CM_CELLMODEL *cm)\n\{"
    puts $dotc "${sp}BOOLEAN   rpt_err = TRUE;"
    puts $dotc "${sp}CM_BASE_CELLPRIM * cp = NULL;"
    puts $dotc "${sp}if ( cm == NULL ) return;"

    puts $dotc "\n"
    foreach line $handleArrayImpl {
	puts $dotc "${sp}$line"
    }


    puts $dotc  "${sp}initmodes\();"
    puts $dotc "${sp}${CLASS}::_instance = this;"
    puts $dotc "\} // ${CLASS}::${CLASS}(CM_CELLMODEL *cm)\n\n"


    ## Write out the constants
    lappend handleArrayAccess "${sp}virtual CM_HANDLE get_${pinHandleArray}\(short idx) \n${sp}\{\n${sp}${sp}return\n${sp}${sp}${sp}(idx < $pinLow || idx > $pinHigh) ?\n${sp}${sp}${sp}CM_BAD_HANDLE : $pinHandleArray\[idx\];\n${sp}\}\n"
    lappend handleArrayAccess "${sp}virtual CM_HANDLE get_${buttonHandleArray}\(short idx) \n${sp}\{\n${sp}${sp}return\n${sp}${sp}${sp}(idx < $buttonLow || idx > $buttonHigh) ?\n${sp}${sp}${sp}CM_BAD_HANDLE : $buttonHandleArray\[idx\];\n${sp}\}\n"
    lappend handleArrayAccess "${sp}virtual CM_HANDLE get_${namedPropHandleArray}\(short idx) \n${sp}\{\n${sp}${sp}return\n${sp}${sp}${sp}(idx < $namedPropLow || idx > $namedPropHigh) ?\n${sp}${sp}${sp}CM_BAD_HANDLE : $namedPropHandleArray\[idx\];\n${sp}\}\n"
    

    ## Print pin constants
    puts $idfile "\n// PRIMPIN constants for ${cell}"
    puts $idfile "const $pinType $pinLow = 0;"
    foreach line $pinIdStr {
	puts $idfile $line
    }
    puts $idfile "const $pinType $pinHigh = [expr $pinCnt-1];\n"
    

    ## Print button constants
    puts $idfile "\n// BUTTON constants for ${cell}"
    puts $idfile "const $buttonType $buttonLow = 0;"
    foreach line $buttonIdStr {
	puts $idfile $line
    }
    if {$buttonCnt == 0 } {
    	puts $idfile "const $buttonType $buttonHigh = 0;\n"
    } else {
    	puts $idfile "const $buttonType $buttonHigh = [expr $buttonCnt-1];\n"
    }

    ## Print namedProp constants
    puts $idfile "\n// NAMEDPROP constants for ${cell}"
    puts $idfile "const $namedPropType $namedPropLow = 0;"
    foreach line $namedPropIdStr {
	puts $idfile $line
    }
    if {$namedPropCnt == 0} {
	incr namedPropCnt
    }
    puts $idfile "const $namedPropType $namedPropHigh = [expr $namedPropCnt-1];\n"

    foreach line $handleArrayAccess {
	puts $doth $line
    }

    Ice:cache:write_end $doth $dotc $idfile

    close $idfile
    close $doth
    close $dotc
}
