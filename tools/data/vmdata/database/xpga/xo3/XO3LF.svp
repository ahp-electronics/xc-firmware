<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		SVF_Plus	SYSTEM	"SVF_Plus.dtd" >
<!-- 
	05/04/10 Nguyen Created
	03/02/11 Nguyen replace the DISABLE with DISABLE_REFRESH for the FLASH read operations (CR_52486)
	03/10/12 Nguyen updated the FLASH_ENABLE function to do the SRAM erase first for all OFFLINE operations (CR_56189)
	10/05/12 Nguyen removed "DISABLE" on the "XFLASH Program and TransFR" operation based on requested CR 58387
	06/23/14 Nguyen added "BYPASS" on the "SPIDISABLE" function based on requested CR 121185
    10/22/14, egz, fixed sof-123025
	10/27/14, egz, fixed sof-123055 and sof-123056.
	10/30/14, egz, fixed error of dropping the bypass when multiple device in xcf file for patch sof-123027.
	02/11/15  Nguyen added "I2C Recovery Erase Only" operation due to Steve Hossner requested
	03/16/15, egz, added "Flash Refresh" operation to "SingleSVFOperationRevC" and "ChainSVFOperationRevC" operation lists for fixing sof-124160.
	04/29/15 Nguyen added "XSRAM SEI Fast Program" operation
	08/19/2015 Nguyen added "XFLASH Erase,Program,Verify,Feature and TransFR" operation sof-125438
	09/12/17 Nguyen added "XFLASH Erase,Program,Verify,Secure and TransFR" operation sof-128042
	04/16/2019 Nguyen removed feature row check for background operations (SOF-129580)
-->
<SVF_Plus version="1.0">
<Header>
	<Device name="DEVICE_NAME"/>
</Header>
<Setup> <!-- use default Header, Trailer and Frequency value -->
	<Interface protocol="JTAG_1149.1"/>
</Setup>
<Parameter>
	<!-- Length fields are in number if bits -->
	<Instruction_Length value="INSTRUCTION_REGISTER_LENGTH"/> 
	<Row_Width			value="DEVICE_ROW_WIDTH"/> 
	<Address_Length		value="ADDRESS_REGISTER_LENGTH"/> 
	<Address length="ADDRESS_LENGTH">
		INI_ADDRESS			
	</Address>
	<ID_Length 			value="DEVICE_ID_LENGTH"/>
	<Usercode_Length 	value="DEVICE_USERCODE_LENGTH"/>
	<BSCAN_Length value="BSCAN_REGISTER_LENGTH"/> 
	<Bscan length="BSCAN_LENGTH">
		BSCAN_DATA
	</Bscan>
	<BscanMask length="BSCAN_LENGTH">
		BSCAN_MASK
	</BscanMask>
	<TotalFuse value="TOTAL_FUSE_MAP"/>
	<PWP	value="PROGRAMING_PULSE_WIDTH"/>
	<PWV	value="VERIFY_PULSE_WIDTH"/>
	<PWE	value="ERASE_PULSE_WIDTH"/>
	<MDRDelay value="MDR_DELAY"/>
	<Instruction>
		EXTEST	 			= 0x15;
		EXTEST_PULSE        = 0x2D;
		EXTEST_TRAIN        = 0x2E;
		INTEST              = 0x2C;
		CLAMP               = 0x78;
		HIGHZ               = 0x18;
		LSC_PRELOAD         = 0x1C;
		LSC_SAMPLE          = 0x1C;
		BYPASS              = 0xFF;
		IDCODE_PUB          = 0xE0;
		LSC_UIDCODE_PUB     = 0x19;
		USERCODE            = 0xC0;
		LSC_READ_TEMP       = 0xE8;
		LSC_DEVICE_CTRL     = 0x7D;
		LSC_READ_STATUS     = 0x3C;
		LSC_CHECK_BUSY      = 0xF0;
		LSC_REFRESH         = 0x79;
		LSC_I2CI_CRBR_WT    = 0x9C;
		LSC_I2CI_TXDR_WT    = 0x9D;
		LSC_I2CI_RXDR_RD    = 0x9E;
		LSC_I2CI_SR_RD      = 0x9F;
		LSC_IP_A            = 0x32;
		LSC_IP_B            = 0x38;
		LSC_IPTEST_A        = 0x33;
		LSC_IPTEST_B        = 0x39;
		LSC_PROG_SPI        = 0x3A;
		LSC_PROG_SPI1       = 0x3E;
		LSC_IDCODE_PRV      = 0x16;
		LSC_READ_PES        = 0x11;
		LSC_MANUFACTURE_SHIFT = 0x90;
		ISC_ENABLE          = 0xC6;
		LSC_ENABLE_X        = 0x74;
		ISC_DISABLE         = 0x26;
		ISC_PROGRAM         = 0x67;
		ISC_NOOP            = 0x30;
		ISC_PROGRAM_USERCODE = 0xC2;
		ISC_READ            = 0x80;
		ISC_ERASE           = 0x0E;
		ISC_DISCHARGE       = 0x14;
		ISC_PROGRAM_DONE    = 0x5E;
		ISC_ERASE_DONE      = 0x24;
		ISC_PROGRAM_SECURITY = 0xCE;
		LSC_PROGRAM_SECPLUS = 0xCF;
		ISC_DATA_SHIFT      = 0x05;
		ISC_ADDRESS_SHIFT   = 0x42;
		LSC_INIT_ADDRESS    = 0x46;
		LSC_WRITE_ADDRESS   = 0xB4;
		LSC_PROG_INCR_RTI   = 0x82;
		LSC_PROG_INCR_ENC   = 0xB6;
		LSC_PROG_INCR_CMP   = 0xB8;
		LSC_PROG_INCR_CNE   = 0xBA;
		LSC_VERIFY_INCR_RTI = 0x6A;
		LSC_PROG_CTRL0      = 0x22;
		LSC_READ_CTRL0      = 0x20;
		LSC_RESET_CRC       = 0x3B;
		LSC_READ_CRC        = 0x60;
		LSC_PROG_SED_CRC    = 0xA2;
		LSC_READ_SED_CRC    = 0xA4;
		LSC_SHIFT_PASSWORD  = 0xBC;
		LSC_PROG_PASSWORD   = 0xF1;
		LSC_READ_PASSWORD   = 0xF2;
		LSC_PROG_CIPHER_KEY = 0xF3;
		LSC_READ_CIPHER_KEY = 0xF4;
		LSC_PROG_FEATURE    = 0xE4;          
		LSC_READ_FEATURE    = 0xE7;      
		LSC_PROG_FEABITS    = 0xF8;
		LSC_READ_FEABITS    = 0xFB;
		LSC_PROG_OTP        = 0xF9;
		LSC_READ_OTP        = 0xFA;
		LSC_WRITE_COMP_DIC  = 0x02;
		LSC_WRITE_BUS_ADDR  = 0xF6;
		LSC_PCS_WRITE       = 0x72;
		LSC_PCS_READ        = 0xF7;
		LSC_EBR_WRITE       = 0xB2;
		LSC_EBR_READ        = 0xB0;
		LSC_PROG_INCR_NV    = 0x70;
		LSC_READ_INCR_NV    = 0x73;
		LSC_INIT_ADDR_UFM   = 0x47;
		LSC_READ_TAG        = 0xCA;
		LSC_ERASE_UFM       = 0xCB;
		LSC_PROG_UFM        = 0xC9;
		LSC_READ_UFM        = 0xCA;
		LSC_STORE           = 0xD0;
		LSC_BITSTREAM_BURST = 0x7A;
		LSC_PROG_PES        = 0xD0;
		LSC_PROG_MES        = 0xD1;
		LSC_PROG_MAIN_RED   = 0xD3;
		LSC_PROG_MAIN_RCR   = 0xD4;
		LSC_PROG_MAIN_RMR   = 0xD5;
		LSC_PROG_NV_RED     = 0xD6;
		LSC_PROG_NV_RMR     = 0xD7;
		LSC_READ_MES        = 0xD8; 
		LSC_READ_TRIM       = 0xD1;
		LSC_READ_MAIN_RED   = 0xDA;
		LSC_READ_MAIN_RCR   = 0xDC;
		LSC_READ_MAIN_RMR   = 0xDC;
		LSC_READ_NV_RED     = 0xDD;
		LSC_READ_NV_RMR     = 0xDE;
		LSC_MFG_MTEST       = 0x96;
		LSC_MFG_MTRIM       = 0x69;
		LSC_MFG_MDATA       = 0x8F;
		LSC_ISCAN           = 0xDF;	
	</Instruction>
</Parameter>
<Data>
	<DataField	name="IDTDI">
		<FieldBlock	row_width="DEVICE_ID_LENGTH">
			ID_DATA
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAM">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			MDR_BSCANPROGRAM
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAMMASK">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			MDR_BSCANPROGRAMMASK
		</FieldBlock>
	</DataField>
	<DataField    name="Address_CFG">
        <FieldBlock    row_width="14">
            0x1000,
            0x1008,
            0x1010,
            0x1018,
            0x1020,
            0x1028,
            0x1030,
            0x1038,
            0x1040,
            0x1048,
            0x1050,
            0x1058,
            0x1060,
            0x1068
        </FieldBlock>
    </DataField>
    <DataField    name="I2C_Address_CFG">
        <FieldBlock    row_width="14">
            0x00,
            0x10,
            0x08,
            0x18,
            0x04,
            0x14,
            0x0C,
            0x1C,
            0x02,
            0x12,
            0x0A,
            0x1A,
            0x06,
            0x16
        </FieldBlock>
    </DataField>
    <DataField    name="I2C_Address_FaultLog">
        <FieldBlock    row_width="16">
            0x00,
            0xE0,
            0x70,
            0xA8,
            0x38,
            0xC4,
            0x54,
            0x8C,
            0x1C,
            0xFC,
            0x62,
            0xB2,
            0x2A,
            0xDA,
            0x46,
            0x96
        </FieldBlock>
    </DataField>
</Data>
<Operation_List>	
	"SRAM Boot From External PROM" = " INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_FR_OTP ! Check the OTP fuses,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 FLASH_ENABLE	! Enable the programming mode,
					 FEATURE_ERASE	! Erase the Feature,
					 CHECK_STATUS ! Read the status bit,
					 BOOT_EXTERNAL_FEATURE_PROGRAM, 
					 DISABLE_REFRESH ! Exit the programming mode" ;
					 
	"Verify SPI" = " INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_MSPI ! Check the MSPI Setting,  
					 REFRESH_SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI" = " INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 PSUEDO_FLASH_ENABLE	! Enable the Flash Pseudo programming mode,
					 PSUEDO_FLASH_ERASE	! Erase the Shadow Feature Rows register,
					 CHECK_STATUS ! Read the status bit, 
					 SPI_FEATURE_PROGRAM ! Enable MSPI, 
					 DISABLE_REFRESH ! Exit the programming mode,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = " INIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_OTP ! Check the OTP fuses,
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  											 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;
					 			 	 			 				 
	"SRAM Boot From Internal PROM" = " INIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_FR_OTP ! Check the OTP fuses,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
									 FLASH_ENABLE	! Enable the programming mode,
									 FEATURE_ERASE	! Erase the Feature,
									 CHECK_STATUS ! Read the status bit,
									 BOOT_INTERNAL_FEATURE_PROGRAM ! Enable MSPI,
									 DISABLE_REFRESH ! Exit the programming mode" ;
									   
	"Manufacturing Read PES Fuses" = " INIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SAVE_ID,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   READ_PES_FUSES ! Read the PES Fuses,
									   DISABLE ! Exit the programming mode" ;
									   
	"Manufacturing Read Status Register" = " INIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SAVE_ID,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   READ_STATUS_FUSES ! Read the Status Register Fuses,
									   DISABLE ! Exit the programming mode" ;
									   									   
    "Read Manufacturing Register" = "INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									READ_MANUFACTURING_REGISTER ! Read the Manufacturing Register,
									DISABLE ! Exit the programming mode" ;
						
	"Program Manufacturing Register" = "INIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  PSUEDO_FLASH_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_MANUFACTURING_REGISTER ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;

	"Manufacturing Toggle BG_OFF" = "INIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  PSUEDO_FLASH_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_BG_OFF ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;
								  
	"Manufacturing Read MES Fuses" = "INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									READ_MES_REGISTER ! Read the Manufacturing Register,
									DISABLE ! Exit the programming mode" ;
									
	"Manufacturing Read DTR Fuses" = "INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									READ_DTR_REGISTER ! Read the Manufacturing Register,
									DISABLE ! Exit the programming mode" ;
																			
	
	"Security Read Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										FEATURE_ROW_READ	! Read the Feature row, 
										DISABLE ! Exit the programming mode"	;
					 			 		
										
	"Security Erase Feature Rows"	=	"INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses, 									
										FLASH_ENABLE	! Enable the programming mode, 	
										FEATURE_ERASE	! Erase the Feature row, 
										FLASH_ERASE	! Erase the CFG, 
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
									
	
	"Security Check Feature Row"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses"	;			
	
	
	"Security Read Feature Bits"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
										READ_CONFIG_REGISTER ! Read the Feature Bits,
										DISABLE ! Exit the programming mode"	;
																			
	"Security Program Feature Bits"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										PROGRAM_CONFIG_REGISTER ! Program the Feature Bits,
										DISABLE ! Exit the programming mode"	;
										
	"Security Program Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;																						
	
	"Security Read Status Register" = "INIT ! Initialize,
						 			 READ_ID	! Check the IDCODE,
						 			 SAVE_ID,
						 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
						 			 SAVE_STATUS,
						 			 DISABLE";
	
	"Security Check Protect Fuses" =  "INIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	"Verify ID with Password" = 		"INIT 	! Initialize, 
						 				READ_ID ! Check the IDCODE,
						 				CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key";
						 				
	"Security Read Feature Row with Password Key"	=	"INIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														SAVE_ID,
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,																												
														CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
														FEATURE_ROW_READ	! Read the Feature row, 
														DISABLE ! Exit the programming mode"	;
										
	"Security Erase Feature Row with Password Key"	=	"INIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														CHECK_FR_OTP ! Check the OTP fuses,
														CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 									
														FLASH_ENABLE	! Enable the programming mode, 	
														FEATURE_ERASE	! Erase the Feature row, 
														FLASH_ERASE	! Erase the CFG, 
														CHECK_STATUS ! Read the status bit,
														DISABLE ! Exit the programming mode"	;
																																																														
	"Security Program Password Key" = "INIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  CHECK_FR_OTP ! Check the OTP fuses,
									  CHECK_KEYLOCK ! Check the Key Protection fuses,  
									  FLASH_ENABLE	! Enable the programming mode,
									  PROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  DISABLE ! Exit the programming mode" ;
							  
	"Security Program Password Key with Lock" = "INIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  CHECK_FR_OTP ! Check the OTP fuses,
												  CHECK_KEYLOCK ! Check the Key Protection fuses,  
												  FLASH_ENABLE	! Enable the programming mode,
												  PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
												  DISABLE ! Exit the programming mode" ;
							  
	"Security Check Password Key" =  "INIT 	! Initialize, 
										   READ_ID	! Check the IDCODE,
										   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										   
										   CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
										   READ_PROTECT_KEY_FUSES ! Read the Protection Fuses,
										   DISABLE ! Exit the programming mode" ;
								   				 			 
	"Security Flash EPV with Password" = "	INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,											  
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 															   
	
	"Security Flash EPVS with Password" = "	INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											FLASH_ENABLE	! Enable the programming mode,	
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,										  
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,									 			 		
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security Flash Program with Password" = "	INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											FLASH_ENABLE	! Enable the programming mode,	
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,										  
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode"	;
						 			 				 			 		
	"Security Flash Erase with Password"	=	"	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
													FLASH_ENABLE	! Enable the programming mode, 
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,																										
													FLASH_ERASE_NO_FEA	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
							
	"Security Flash Verify with Password"	=	"	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													CHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
													FLASH_ENABLE	! Enable the programming mode, 													
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode,
													VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							
							
	"Security XFlash EPV with Password" = "	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,																										  
													FLASH_ERASE_NO_FEA	! Erase the CFG, 
													CHECK_STATUS ! Read the status bit,
								 			 		FLASH_PROGRAM_STATUS	! Program CFG,
													UFM_PROGRAM_STATUS  ! Program the UFM,
													PROGRAM_USERCODE	! Program USERCODE,
													CHECK_STATUS ! Read the status bit,
													FLASH_VERIFY	! Verify CFG,
													UFM_VERIFY          ! Verify the UFM,								 
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit,	
													FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								 			 		DISABLE ! Exit the programming mode"	;
			 			 										 			 					 			 		
	
	"Security XFlash EPVS with Password" = "	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												CHECK_CFG_UFM_OTP ! Check the OTP fuses, 												 
												FLASH_ERASE_NO_FEA	! Erase the CFG, 
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,				 			 		
							 			 		DISABLE ! Exit the programming mode"	;
			 			 			 			 															  
	
	"Security XFlash Program with Password" = "	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,													
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,													  
													FLASH_ERASE_NO_FEA	! Erase the CFG, 
													CHECK_STATUS ! Read the status bit,
								 			 		FLASH_PROGRAM_STATUS	! Program CFG,
													UFM_PROGRAM_STATUS  ! Program the UFM,
													PROGRAM_USERCODE	! Program USERCODE,
													CHECK_STATUS ! Read the status bit,
													FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								 			 		DISABLE ! Exit the programming mode"	;
								 			 		
	"Security XFlash Erase with Password"	=	"	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 													 
													CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,
													FLASH_ERASE_NO_FEA	! Erase the CFG, 
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
		 			 					 			 		
	
	"Security XFlash Verify with Password"	=	"	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 													
													CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode"	;
							
	
	"Security Fast Program with Password" = "INIT 	! Initialize,   
											READ_ID	! Check the IDCODE,
											IO_STATE ! Program Bscan register,
											CHECK_SRAM_OTP ! Check the OTP fuses,
											SRAM_ENABLE	! Enable SRAM programming mode,									 		  
											CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
									 		SRAM_ERASE	! Erase the SRAM, 
											BURST_PROGRAM	! Program Fuse Map,
											VERIFY_USERCODE		! Verify USERCODE,
											DISABLE ! Exit the programming mode"	;
	
	
	"Security SRAM EPV with Password" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								SRAM_ENABLE	! Enable SRAM programming mode, 						 		  
								CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
						 		SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;						
			 			 		
	"Security SRAM Erase with Password"	=	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								SRAM_ENABLE	! Enable SRAM programming mode, 								
								CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;
	
	"Security SRAM Verify with Password"	=	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 								
								CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	
	"Security XSRAM SEI Fast Program with Password" = "INIT 	! Initialize,   
													READ_ID	! Check the IDCODE,
													CHECK_SRAM_OTP ! Check the OTP fuses,
													SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
													CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,													
													BURST_PROGRAM	! Program Fuse Map,
													DISABLE ! Exit the programming mode,
													VERIFY_STATUS ! Verify Status Register"	;
	
	"Security XSRAM Verify with Password"	=	"INIT 	! Initialize, 
												READ_ID	! Check the IDCODE,  
												SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
												CHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SRAM_VERIFY	! Verify Fuse Map, 
												SRAM_VERIFY_USERCODE		! Verify USERCODE, 
							 			 		DISABLE ! Exit the programming mode"	;	 			 		
	
	"Security EPV with Password Key Option" = 	"INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,   
												FLASH_ENABLE	! Enable the programming mode,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,								
												CHECK_STATUS ! Read the status bit,
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,		
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							 			 		
	"Security EPVS with Password Key Option" = "INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,  
												FLASH_ENABLE	! Enable the programming mode,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,	
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_SECURITY ! Secure device,									 			 									 			 		
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPV with my_ASSP, Password Key Option" = 	"	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,   
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							 			 								 			 									
	"Security EPV with OTP Option" = 	"	INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
						 			 		OTP_PROGRAM_STATUS ! Program OTP, 	
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
										
 	
 	"Security EPVS with OTP Option" = 	"	INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,							 			 		
						 			 		OTP_PROGRAM_STATUS ! Program OTP, 
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
						 			 		
	"Security EPV with Full OTP Option" =  	"	INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													CHECK_KEYLOCK ! Check the Key Protection fuses,  
													FLASH_ENABLE	! Enable the Flash,
													CHECK_FLASH_OTP ! Check the OTP fuses,
													DIRECT_FLASH_ERASE	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													FLASH_PROGRAM_STATUS	! Program CFG,
													UFM_PROGRAM_STATUS  ! Program the UFM,
													PROGRAM_USERCODE	! Program USERCODE,
													CHECK_STATUS ! Read the status bit,
													FLASH_VERIFY	! Verify CFG,
													UFM_VERIFY          ! Verify the UFM,								 
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit,	
													FEATURE_PROGRAM_STATUS ! Program Feature Rows,
													CHECK_STATUS ! Read the status bit,			 			 		
								 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
								 			 		OTP_FEATURE_ROW_STATUS ! Program OTP, 	
								 			 		DISABLE ! Exit the programming mode,
								 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPVS with Full OTP Option" = "	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		UFM_SECURITY ! Secure the UFM,
							 			 		PROGRAM_SECURITY ! Secure device,	
							 			 		OTP_FEATURE_ROW_STATUS ! Program OTP, 
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
								 			 		
	"Security EPV with my_ASSP Option" = 	"	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;	
										
	"Security EPVS with my_ASSP Option" = 	"	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses, 
												FLASH_ENABLE	! Enable the Flash, 
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash, 
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_PROGRAM_STATUS	! Program CFG,
												UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,									 			 		
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;	
							 			 		
	"Security Display TraceID" = "INIT, SAVE_TRACEID";
	"Security Read TraceID" = "INIT, SAVE_TRACEID";						 			 										 			 		
								
	"FLASH Verify Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;
										
	"FLASH Program Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;	
																				
	
	"Bypass"	=	"INIT 	! Initialize";																	 			 					 			 												 		 													 			 															  				 			 										  								
	"FLASH Bypass"	=	"INIT 	! Initialize";
	"FLASH Verify ID" = 	"INIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"Verify ID" = 		"INIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"FLASH Display ID" = "INIT, SAVE_ID";
	"FLASH Verify USERCODE"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE_REFRESH ! Exit the programming mode"	;
					             								 								
	"FLASH Display USERCODE"	=	"INIT, 
									 READ_ID	! Check the IDCODE,
									 SAVE_ID,
									FLASH_ENABLE	! Enable the CFG, 
									SAVE_USERCODE,
									DISABLE_REFRESH ! Exit the programming mode";
	"FLASH Disable Only" = "INIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"FLASH Enable Only" = "INIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   IO_STATE ! Program Bscan register,
						   FLASH_ENABLE	! Enable the CFG"	;
	"FLASH Erase DONE bit"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,								
								FLASH_ENABLE	! Enable the CFG, 
								CHECK_CFG_OTP ! Check the OTP fuses,								
								ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
	"FLASH Program DONE bit"	=	"INIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 IO_STATE ! Program Bscan register,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,
									 FLASH_ENABLE	! Enable the CFG, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"FLASH Read DONE bit" = 	"INIT, 
								 READ_ID, 
								 FLASH_ENABLE	! Enable the CFG, 
								 READ_DONE_BIT,
								 DISABLE_REFRESH ! Exit the programming mode";
	
	"FLASH Re-Initialize" = "INIT 	! Initialize,  
						  	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
							 FLASH_ENABLE	! Enable the CFG, 
						  	 DIRECT_FLASH_ERASE	! Erase the device, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"FLASH Program,Verify,skip Erase" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 		
	"Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 					 			 		
	
	"FLASH CFG Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_CFG_OTP ! Check the OTP fuses,
								CFG_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"FLASH CFG and UFM Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FLASH_ERASE_NO_FEA	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 				 			 		
	"FLASH Erase,Program" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 			
	"FLASH Erase,Program,Verify,Secure" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,									 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Erase,Program,Verify,Secure" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,									 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		
			 			 		
	"FLASH Erase,Program,Verify,Secure Plus" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,								
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		UFM_SECURITY ! Secure the UFM,																	 			 					 			 		
			 			 		PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		
	
	"FLASH Secure Device" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	"FLASH Secure Plus" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								UFM_SECURITY ! Secure the UFM,			 			 		
								PROGRAM_SECURITY ! Secure device,
								CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;			 			 		
			 			 		
	"FLASH Program"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash, 
							CHECK_STATUS ! Read the status bit,
							FLASH_PROGRAM_STATUS	! Program CFG, 
							UFM_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FEATURE_PROGRAM_STATUS ! Program Feature Rows,
							CHECK_STATUS ! Read the status bit,			 			 		
			 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 	DISABLE ! Exit the programming mode"	;	
			 			 	
	"FLASH Program,skip Erase"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									CHECK_KEYLOCK ! Check the Key Protection fuses, 
									FLASH_ENABLE	! Enable the Flash,
									CHECK_FLASH_OTP ! Check the OTP fuses,
									CHECK_STATUS ! Read the status bit,
									FLASH_PROGRAM_STATUS	! Program CFG, 
									UFM_PROGRAM_STATUS  ! Program the UFM,							
									PROGRAM_USERCODE	! Program USERCODE,
									CHECK_STATUS ! Read the status bit,	
									FEATURE_PROGRAM_STATUS ! Program Feature Rows,
									CHECK_STATUS ! Read the status bit,			 			 		
					 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 	DISABLE ! Exit the programming mode"	;	
			 			 			 			 		
	"FLASH Verify Only" =	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  							
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify CFG, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE_REFRESH ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							
	"Verify Only" =	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  							
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify CFG, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE_REFRESH ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							
													
	"FLASH Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_OTP ! Check the OTP fuses,
							CFG_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG and UFM Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			 			 			
	
	"Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Calculate Checksum"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
									 SAVE_ID,
									 IO_STATE ! Program Bscan register,
						 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_ENABLE	! Enable the Flash, 
						             FLASH_SAVE_ARRAY,
						             UFM_SAVE_ARRAY,
						             FEATURE_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE_REFRESH";			 						 
	"FLASH Read and Save"	=	"INIT, 
								 READ_ID, 
								 SAVE_ID, 
								 IO_STATE ! Program Bscan register,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_ENABLE, 
								 FLASH_SAVE_ARRAY, 								 
								 UFM_SAVE_ARRAY,
								 FEATURE_SAVE_ARRAY,
								 SAVE_USERCODE, 
								 DISABLE_REFRESH";
	
	"FLASH Read Status Register" = "INIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 FLASH_ENABLE,
					 			 SAVE_STATUS,
					 			 DISABLE_REFRESH";
	"FLASH Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 							 
	"FLASH Upload to Static RAM" = " 	INIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";
						
	
	"FLASH Refresh" = " 	INIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
								 			 		
	"FLASH UFM Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_ENABLE	! Enable the Flash, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"FLASH Verify UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE_REFRESH ! Exit the programming mode"	;
	"FLASH UFM Erase" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_UFM_OTP ! Check the OTP fuses, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,
							FLASH_ENABLE	! Enable the Flash, 
							UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"FLASH Display UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SAVE_ID, 
							FLASH_ENABLE	! Enable the Flash, 
							UFM_SAVE_ARRAY, 
							DISABLE_REFRESH ! Exit the programming mode"	;
	
	"FLASH UFM Secure" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,
							FLASH_ENABLE	! Enable the Flash, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Verify Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;	
																												 			 		
	"XFLASH Upload to Static RAM" = " 	INIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";
	"XFLASH Bypass"	=	"INIT 	! Initialize";
	"XFLASH Verify ID" = 	"INIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"XFLASH Display ID" = "INIT, READ_ID, SAVE_ID";
	"XFLASH Verify USERCODE"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;  								
	"XFLASH Display USERCODE"	=	"INIT, 
									 READ_ID	! Check the IDCODE,
									 SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 	SAVE_USERCODE,
								 	DISABLE ! Exit the programming mode";
	"XFLASH Disable Only" = "INIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"XFLASH Enable Only" = "INIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode"	;
						   
	"XFLASH Erase DONE bit"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
		 			 			
	"XFLASH Program DONE bit"	=	"INIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"XFLASH Read DONE bit" = 	"INIT, 
								 READ_ID, 
								 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 READ_DONE_BIT,
								 DISABLE ! Exit the programming mode";
	
	"XFLASH Read Status Register" = "INIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
					 			 SAVE_STATUS,
					 			 DISABLE ! Exit the programming mode";	
	"XFLASH Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 
					 			 
	"XFLASH Re-Initialize" = "INIT 	! Initialize,  
							 CHECK_KEYLOCK ! Check the Key Protection fuses,
						  	 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
						  	 FLASH_ERASE	! Erase the device, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"XFLASH Refresh" = "INIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
	
	
	"XFLASH Clamping IO" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							FLASH_MDR ! Transparent Field Reconfiguration"	;
	
	"XFLASH Program and Clamping IO" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,			 
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		IO_STATE ! Program Bscan register,
			 			 		FLASH_MDR ! Transparent Field Reconfiguration"	;
			 			 		
	"XFLASH TransFR" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							REFRESH_FUNCTION ! Refresh"	;
	
	"XFLASH Program and TransFR" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,			 
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh"	;
	
	"XFLASH Program Feature Rows" =    "INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,   
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										FEATURE_ERASE	! Erase the Feature Rows,
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										DISABLE ! Exit the programming mode"	;
											 			 		
	
	"XFLASH Erase,Program,Verify,Feature" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								FLASH_ERASE	! Erase the CFG, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
			 			 		CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Erase,Program,Verify,Feature and TransFR" = "	INIT 	! Initialize, 
															READ_ID	! Check the IDCODE,
															CHECK_KEYLOCK ! Check the Key Protection fuses,  
															FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
															CHECK_FLASH_OTP ! Check the OTP fuses,
															FLASH_ERASE	! Erase the CFG, 
															CHECK_STATUS ! Read the status bit,
										 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
										 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
										 			 		PROGRAM_USERCODE	! Program USERCODE,
															CHECK_STATUS ! Read the status bit,
															FLASH_VERIFY	! Verify CFG, 
															UFM_VERIFY          ! Verify the UFM,								
															VERIFY_USERCODE		! Verify USERCODE,
															CHECK_STATUS ! Read the status bit,	
															FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
										 			 		CHECK_STATUS ! Read the status bit,			 			 		
										 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
										 			 		DISABLE ! Exit the programming mode,
										 			 		REFRESH_FUNCTION ! Refresh"	;
	
	"XFLASH Erase,Program,Verify,Feature,Secure and TransFR" = "INIT 	! Initialize, 
															READ_ID	! Check the IDCODE,
															CHECK_KEYLOCK ! Check the Key Protection fuses,  
															FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
															CHECK_FLASH_OTP ! Check the OTP fuses,
															FLASH_ERASE	! Erase the CFG, 
															CHECK_STATUS ! Read the status bit,
										 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
										 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
										 			 		PROGRAM_USERCODE	! Program USERCODE,
															CHECK_STATUS ! Read the status bit,
															FLASH_VERIFY	! Verify CFG, 
															UFM_VERIFY          ! Verify the UFM,								
															VERIFY_USERCODE		! Verify USERCODE,
															CHECK_STATUS ! Read the status bit,	
															FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
										 			 		CHECK_STATUS ! Read the status bit,			 			 		
										 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
										 			 		PROGRAM_SECURITY ! Secure device,
										 			 		DISABLE ! Exit the programming mode,
										 			 		REFRESH_FUNCTION ! Refresh"	;
										 			 											 			 					 		
	"XFLASH Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								CFG_FLASH_ERASE	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Erase,Program,Verify,Refresh" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Upload to SRAM"	;			 			 		
		
	"XFLASH Erase,Program,Verify,Secure Plus" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG, 
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								UFM_SECURITY ! Secure the UFM,		 			 					 			 				 			 					 			 		
			 			 		PROGRAM_SECURITY ! Secure device,	
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Erase,Program,Verify,Secure" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_PROGRAM_STATUS	! Program CFG,
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode"	;			 			 		
	
	"XFLASH Erase,Program,Verify,Secure and TransFR" = "INIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												CHECK_CFG_UFM_OTP ! Check the OTP fuses,
												FEATURE_VERIFY_STATUS ! Verify the Feature,								
												FLASH_ERASE_NO_FEA	! Erase the CFG,  
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_PROGRAM_STATUS	! Program CFG,
							 			 		UFM_PROGRAM_STATUS  ! Program the UFM,								
							 			 		PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG, 
												UFM_VERIFY          ! Verify the UFM,								
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,			 			 		
							 			 		DISABLE ! Exit the programming mode,
							 			 		REFRESH_FUNCTION ! Refresh"	;
			 			 		
	"XFLASH Secure Device" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
								CHECK_CFG_OTP ! Check the OTP fuses,
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Secure Plus" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								UFM_SECURITY ! Secure the UFM,			 			 		
								PROGRAM_SECURITY ! Secure device,
								CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 				 			 		
	"XFLASH Program"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FEATURE_VERIFY_STATUS ! Verify the Feature,								
							FLASH_ERASE_NO_FEA	! Erase the CFG, 
							CHECK_STATUS ! Read the status bit,
							FLASH_PROGRAM_STATUS	! Program CFG, 
							UFM_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							DISABLE ! Exit the programming mode"	;		
	"XFLASH Verify Only" =	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							FEATURE_VERIFY_STATUS ! Verify the Feature,							
							FLASH_VERIFY	! Verify CFG,
							UFM_VERIFY          ! Verify the UFM,							 
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							DISABLE ! Exit the programming mode" ;
							
	"XFLASH Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FLASH_ERASE_NO_FEA	! Erase the CFG,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			
	
	"XFLASH Erase CFG Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_OTP ! Check the OTP fuses,
							CFG_FLASH_ERASE	! Erase the CFG,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XFLASH Calculate Checksum"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
									 SAVE_ID,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
						             FLASH_SAVE_ARRAY,
						             UFM_SAVE_ARRAY,
						             FEATURE_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE";					 						 
	"XFLASH Read and Save"	=	"INIT, 
								 READ_ID, 
								 SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_TRANSPARENT_ENABLE, 
								 FLASH_SAVE_ARRAY,
						         UFM_SAVE_ARRAY,
						         FEATURE_SAVE_ARRAY,
								 SAVE_USERCODE, 
								 DISABLE";
	
	"XFLASH UFM Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
	
	"XFLASH Verify UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XFLASH UFM Erase" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Display UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SAVE_ID, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
	
	"XFLASH UFM Secure" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_UFM_OTP ! Check the OTP fuses, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
		 			 									 
	"SRAM Bypass"	=	"INIT 	! Initialize";
	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 
	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";
	
	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								SRAM_VERIFY_USERCODE		! Verify USERCODE"	; 
	"SRAM Display USERCODE"	=	"INIT, READ_ID, SAVE_ID,SRAM_ENABLE,SAVE_USERCODE,DISABLE";
	
	
	"SRAM Disable Only" = "	INIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	 			 		
	"SRAM Enable Only" = "INIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						IO_STATE ! Program Bscan register,
						SRAM_ENABLE	! Enable SRAM programming mode"	;
						
	"SRAM Display Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
					 			 SRAM_ENABLE	! Enable SRAM programming mode, 
					             SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					        
					                  
	"SRAM Program Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 CHECK_SRAM_OTP ! Check the OTP fuses,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode, 
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
					             						
	"SRAM Fast Program" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"SRAM Erase,Program,Verify" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;			

	"SRAM Program Only" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;				
	
	"SRAM Secure Device" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"SRAM Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							SRAM_ERASE	! Erase the SRAM, 
		 			 		DISABLE ! Exit the programming mode"	;
	
	"SRAM Verify Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							SRAM_VERIFY	! Verify Fuse Map, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Re-Initialize" = " INIT 	! Initialize,
						CHECK_SRAM_OTP ! Check the OTP fuses,
						CHECK_KEYLOCK ! Check the Key Protection fuses,  
						SRAM_ENABLE	! Enable SRAM programming mode, 
						SRAM_ERASE	! Erase the SRAM, 
	 			 		DISABLE ! Exit the programming mode"	;
	
	"SRAM Re-Initialize" = " INIT 	! Initialize,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode,  
							SRAM_ERASE	! Erase the SRAM, 
		 			 		DISABLE ! Exit the programming mode"	;
	"SRAM Erase DONE bit"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
	"SRAM Program DONE bit"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase DONE bit,
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"SRAM Read Status Register" = "INIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 SAVE_STATUS";	
	"SRAM Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 
	"SRAM Read DONE bit"	=	"INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 READ_DONE_BIT	! Erase the done bit"	;
	
	"SRAM Calculate Data CRC"	=	"INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 IO_STATE ! Program Bscan register,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode, 
					             SRAM_SAVE_ARRAY,
					             SAVE_USERCODE,
		 						 DISABLE";
	"SRAM Calculate Checksum"	=	"INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 IO_STATE ! Program Bscan register,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode, 
					             SRAM_SAVE_ARRAY,
					             SAVE_USERCODE,
		 						 DISABLE";		 				
		 						 		 
	"SRAM Read and Save"	=	"INIT, 
						 READ_ID, 
						 SAVE_ID, 
						 IO_STATE ! Program Bscan register,
						 CHECK_KEYLOCK ! Check the Key Protection fuses,  
						 SRAM_ENABLE, 
						 SAVE_CONTROL0,
						 SRAM_SAVE_ARRAY, 
						 SAVE_USERCODE, 
						 DISABLE";
						 
	"SRAM EBR Read and Save"	=	"INIT, 
						 			READ_ID, 
						 			SAVE_ID, 
						 			IO_STATE ! Program Bscan register,
						 			CHECK_KEYLOCK ! Check the Key Protection fuses,  
									SRAM_ENABLE, 
						 			EBR_SAVE_ARRAY, 
						 			DISABLE";
						 						 
	"SRAM Refresh" = " 	INIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
	
	
	"XSRAM SEI Fast Program" 	= "	INIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									CHECK_SRAM_OTP ! Check the OTP fuses,
									CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 	SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;
									
	"XSRAM Fast Program" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode, 
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"XSRAM Fast Program,Refresh" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
								
	"XSRAM Erase,Program,Verify" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;					
	
	"XSRAM Erase,Program,Verify,Refresh" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
	
	"XSRAM Refresh" = "	INIT 	! Initialize,   
						READ_ID	! Check the IDCODE,
						REFRESH_FUNCTION ! Refresh" ;
								
	"XSRAM Erase Only"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							XSRAM_ERASE	! Erase the SRAM, 
		 			 		DISABLE ! Exit the programming mode"	;
	
	"XSRAM Verify Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							SRAM_VERIFY	! Verify Fuse Map, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 						             
	"XSRAM Bypass"	=	"	INIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Display ID" = "INIT, READ_ID, SAVE_ID";								
	"XSRAM Disable Only" = "	INIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"INIT, 
								 READ_ID, 
								 SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_TRANSPARENT_READ_ENABLE, 
								 SAVE_CONTROL0,
								 SRAM_SAVE_ARRAY, 
								 SAVE_USERCODE, 
								 DISABLE";					 
	"XSRAM Calculate Data CRC"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SRAM_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE";
	
	"XSRAM Calculate Checksum"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SRAM_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE";
			 						 	 			 		
	"XSRAM Verify Only"	=	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
								VERIFY	! Verify Fuse Map, 
		 			 			SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Verify USERCODE"	=	"	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
			 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,  
					 			READ_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;				             
	"XSRAM Read Status Register" = "INIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
					 			 SAVE_STATUS,
					 			 DISABLE ! Exit the programming mode";	
	"XSRAM Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 
	"Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"XSRAM Display USERCODE"	=	"INIT, READ_ID, SAVE_ID,SRAM_TRANSPARENT_READ_ENABLE,SAVE_USERCODE,DISABLE";											 			 
	
	"XSRAM EBR Read and Save"	=	"INIT, 
						 			READ_ID, 
						 			SAVE_ID, 
						 			CHECK_KEYLOCK ! Check the Key Protection fuses,  
									SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
						 			EBR_SAVE_ARRAY, 
						 			DISABLE";
	
	"Slave SPI Verify ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID";
	
	"Slave SPI Refresh" = "SPIINIT !Initialize,
						   SPIREAD_ID	! Check the IDCODE, 
						   SPIREFRESH ! Refresh";
						   
	"Slave SPI Read Status Register" = "SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
										 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
							             SPI_SAVE_STATUS !Read Status Register,
							             SPIDISABLE";							
	
	"Slave SPI Display USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
						             SPISAVE_USERCODE,
						             SPIDISABLE";
	
	"Slave SPI Verify USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPIFLASH_ENABLE	! Enable the Flash, 
									 SPIVERIFY_USERCODE		! Verify USERCODE,										
						             SPIDISABLE";
						             
	"Slave SPI Calculate Checksum"	=	"SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
							 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							 			 SPIFLASH_ENABLE	! Enable the Flash, 
							             SPIFLASH_SAVE_ARRAY,
							             SPIUFM_SAVE_ARRAY,
							             SPIFEATURE_SAVE_ARRAY,
							             SPISAVE_USERCODE,
				 						 SPIDISABLE";			 						 
	"Slave SPI Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
						 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							 		 SPIFLASH_ENABLE	! Enable the Flash, 
						             SPIFLASH_SAVE_ARRAY,
						             SPIUFM_SAVE_ARRAY,
						             SPIFEATURE_SAVE_ARRAY,
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";	
	
	"Slave SPI RAM Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							 		 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 	
									 SPISRAM_SAVE_CONTROL0,	
									 SPISRAM_SAVE_ARRAY,					 			 							
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";
			 						 							 						             
	"Slave SPI Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses, 
										SPIDIRECT_FLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_OTP ! Check the OTP fuses,
										SPICFG_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_FLASH_OTP ! Check the OTP fuses,
											SPIDIRECT_FLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,	
											SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											SPICHECK_STATUS ! Read the status bit,		 			 		
						 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIDISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
												SPIFLASH_ENABLE	! Enable the Flash, 
												SPICHECK_FLASH_OTP ! Check the OTP fuses,
												SPIDIRECT_FLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												SPICHECK_STATUS ! Read the status bit,		 			 		
							 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 																			 			 					 			 					 			 			
	"Slave SPI Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,
								SPICHECK_STATUS ! Read the status bit,
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPICHECK_FLASH_OTP ! Check the OTP fuses,
								SPIDIRECT_FLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 		
			 			 		
	"Slave SPI Background Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
								SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
								SPIFLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,								
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Program Feature Rows" =    "SPIINIT 	! Initialize, 
													  SPIREAD_ID	! Check the IDCODE, 
													  SPICHECK_FR_OTP ! Check the OTP fuses,
													  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
													  SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
													  SPIFEATURE_ERASE	! Erase the Feature Rows,
													  SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
													  SPICHECK_STATUS ! Read the status bit,	
													  SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
									
	"Slave SPI Background Erase,Program,Verify,Feature" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses, 
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 									
	"Slave SPI Background CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										SPICHECK_CFG_OTP ! Check the OTP fuses, 
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPICFG_ERASE	! Erase the CFG,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	
	"Slave SPI Background Erase,Program" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 		
	"Slave SPI Background Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 		
					 			 		
	"Slave SPI Background Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
											SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
											SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
											SPIFLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Background Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses,
												SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;	 	
	
	"Slave SPI Display UFM" = "SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIUFM_SAVE_ARRAY, 
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI UFM Program,Verify" = "SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPICHECK_UFM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPIFLASH_ENABLE	! Enable the Flash,									 
									SPIUFM_ERASE	! Erase the UFM, 
									SPICHECK_STATUS ! Read the status bit,
				 			 		SPIUFM_PROGRAM_STATUS  ! Program the UFM,	
				 			 		SPICHECK_STATUS ! Read the status bit,
									SPIUFM_VERIFY          ! Verify the UFM,
									SPICHECK_STATUS ! Read the status bit,
									SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Verify UFM" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_VERIFY          ! Verify the UFM,
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
	"Slave SPI UFM Erase" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_UFM_OTP ! Check the OTP fuses,
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_ERASE	! Erase the UFM, 
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
		 			 																	 			 				 							 			 		
	"Slave SPI Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
															
	"Slave SPI Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI Background SEI Fast Program" 	= "	SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,	
									SPICHECK_SRAM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPI_SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPIBURST_PROGRAM	! Program Fuse Map,	
									SPICHECK_STATUS ! Read the status bit,	
									SPIDISABLE ! Exit the programming mode"	;
		
	"Slave SPI SEI Fast Program" 	= "	SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,	
									SPICHECK_SRAM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPI_SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPIBURST_PROGRAM	! Program Fuse Map,	
									SPICHECK_STATUS ! Read the status bit,	
									SPIDISABLE ! Exit the programming mode"	;
										
	"Slave SPI RAM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,  
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							 		SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									SPISRAM_VERIFY	! Verify Fuse Map, 
									SPIVERIFY_USERCODE		! Verify USERCODE, 
				 			 		SPIDISABLE ! Exit the programming mode"	;
				 			 		
				 			 		
	"Slave SPI Check Protect Fuses" =  "SPIINIT 	! Initialize, 
									   SPIREAD_ID	! Check the IDCODE,
									   SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	"Slave SPI Fast Configuration with Password" = "SPIINIT 	! Initialize,   
													SPIREAD_ID	! Check the IDCODE,
													SPICHECK_SRAM_OTP ! Check the OTP fuses,
													SPISRAM_ENABLE	! Enable SRAM programming mode, 
													SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													SPISRAM_ERASE	! Erase the SRAM, 
													SPIBURST_PROGRAM	! Program Fuse Map,
													SPIVERIFY_USERCODE		! Verify USERCODE,
													SPIDISABLE ! Exit the programming mode"	;
																		   				 			 
	"Slave SPI Erase,Program,Verify with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,	
										SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 									
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;					 			 						 			 		
													   
	
	"Slave SPI EPVS with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIPROGRAM_SECURITY ! Secure device,									 			 		
			 			 				SPIDISABLE ! Exit the programming mode"	;
			 			 		
	"Slave SPI Erase Only with Password"	=	"SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE,
												SPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
												SPIFLASH_ENABLE	! Enable the programming mode, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
												SPIDISABLE ! Exit the programming mode"	;
														
	"Slave SPI Background EPV with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Background EPVS with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 						 			 					 				 			 					 			 															  
	
	"Slave SPI Background Erase with Password"	=	"SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE,
													SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
													SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
													SPIFLASH_ERASE	! Erase the device, 
													SPICHECK_STATUS ! Read the status bit,
								 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Verify Only with Password" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											SPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  													
											SPIFLASH_VERIFY	! Verify the Flash, 
											SPIUFM_VERIFY          ! Verify the UFM,							
											SPIVERIFY_USERCODE	! Verify USERCODE, 
											SPICHECK_STATUS ! Read the status bit, 
											SPIVERIFY_DONE_BIT ! Verify Done Bit,
											SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
																					
		
	"Slave SPI Program Password Key" = "SPIINIT 	! Initialize, 
									  SPIREAD_ID	! Check the IDCODE,
									  SPICHECK_FR_OTP ! Check the OTP fuses,
									  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									  SPIFLASH_ENABLE	! Enable the programming mode,
									  SPIPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  SPIDISABLE ! Exit the programming mode" ;	
	
	"Slave SPI Program Password Key with Lock" = "SPIINIT 	! Initialize, 
									  SPIREAD_ID	! Check the IDCODE,
									  SPICHECK_FR_OTP ! Check the OTP fuses,
									  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									  SPIFLASH_ENABLE	! Enable the programming mode,
									  SPIPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
									  SPIDISABLE ! Exit the programming mode" ;	
									  											  
	"Slave SPI Read Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									    SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
					 			 		
	
	"Slave SPI Erase Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_FR_OTP ! Check the OTP fuses,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 									
										SPIFLASH_ENABLE	! Enable the programming mode, 	
										SPIFEATURE_ERASE	! Erase the Feature row,
										SPIFLASH_ERASE	! Erase the CFG,  
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	
	"Slave SPI Check Feature Row"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses"	;		
										
										
	"I2C Verify ID" = "	I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE";
	"I2C Display ID" = "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE,
						I2CSAVE_ID";						
	
	"I2C Program Feature Rows" =    "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_FR_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFEATURE_ENABLE	! Enable the Flash, 
									I2CFEATURE_ERASE	! Erase the Feature Rows,
									I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
									I2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	
	"I2C Fast Program" = "I2CINIT 	! Initialize,   
						I2CREAD_ID	! Check the IDCODE,
						I2CCHECK_SRAM_OTP ! Check the OTP fuses,
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 
						I2CSRAM_ERASE	! Erase the SRAM, 
						I2CBURST_PROGRAM	! Program Fuse Map,
						I2CVERIFY_USERCODE		! Verify USERCODE,
						I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Fast Configuration" = "I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_ENABLE	! Enable SRAM programming mode, 
								I2CSRAM_ERASE	! Erase the SRAM, 
								I2CBURST_PROGRAM	! Program Fuse Map,
								I2CVERIFY_USERCODE		! Verify USERCODE,
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Program" = "I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CCHECK_SRAM_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									I2CSRAM_ERASE	! Erase the SRAM, 
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Configuration" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CCHECK_SRAM_OTP ! Check the OTP fuses,
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,	
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,		
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
																						
	"I2C Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure Plus" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CUFM_SECURITY ! Secure the UFM,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
						 			 							 			 					 			 					 			 		
	"I2C Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																																				
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,								 
									I2CCHECK_STATUS ! Read the status bit,	
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Program" =   "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE, 
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CFLASH_ENABLE	! Enable the Flash, 
						I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
						I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
						I2CFLASH_ERASE	! Erase the Flash,
						I2CCHECK_STATUS ! Read the status bit,
	 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
	 			 		I2CPROGRAM_USERCODE	! Program USERCODE,
	 			 		I2CUFM_PROGRAM_STATUS  ! Program the UFM,							
						I2CCHECK_STATUS ! Read the status bit,
						I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
	 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"I2C Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CCHECK_FLASH_OTP ! Check the OTP fuses,
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Full Erase"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CCHECK_FLASH_OTP ! Check the OTP fuses,
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CDISABLE ! Exit the programming mode"	;
			 			 						 			 								
	"I2C Background Program Feature Rows" =    "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CCHECK_FR_OTP ! Check the OTP fuses,
												I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
												I2CFEATURE_ERASE	! Erase the Feature Rows,
												I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												I2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"I2C Background Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CCHECK_STATUS ! Read the status bit,	
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
						 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"I2C Background Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"I2C Background Program" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,								
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"I2C Background Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,  
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"I2C Background Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,	
									I2CCHECK_STATUS ! Read the status bit,							 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"I2C Background Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
							I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,							
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"I2C Background Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
							I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses, 
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	
	"I2C Check Feature Row"	=	"I2CINIT 	! Initialize, 
								 I2CREAD_ID	! Check the IDCODE, 
								 I2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;	
	
	"I2C Check Protect Fuses" =  "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;	
	
		
	"I2C Erase Feature Row with Password Key"	=	"I2CINIT 	! Initialize, 
													 I2CREAD_ID	! Check the IDCODE, 
													 I2CCHECK_FR_OTP ! Check the OTP fuses,
													 I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													 I2CFLASH_ENABLE	! Enable the Flash, 	
													 I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													 I2CFEATURE_ERASE	! Erase the Feature row, 
													 I2CFLASH_ERASE	! Erase the Flash,
													 I2CCHECK_STATUS ! Read the status bit,
													 I2CDISABLE ! Exit the programming mode"	;
																																																														
	"I2C Program Password Key" = "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CCHECK_FR_OTP ! Check the OTP fuses,
								  I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  I2CDISABLE ! Exit the programming mode" ;
							  
	"I2C Program Password Key with Lock" = "I2CINIT 	! Initialize, 
								  			I2CREAD_ID	! Check the IDCODE, 
								  			I2CCHECK_FR_OTP ! Check the OTP fuses,
								  			I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			I2CFLASH_ENABLE	! Enable the Flash, 
											I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode" ;							  	
	
	"I2C EPV with Password Key Option" = 	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	I2CDISABLE ! Exit the programming mode"	;
							 			 		
	"I2C EPVS with Password Key Option" = "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CPROGRAM_SECURITY ! Secure device,							 			 	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode"	;
	
	"I2C EPV with my_ASSP, Password Key Option" = 	"I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													I2CFLASH_ENABLE	! Enable the Flash, 
													I2CCHECK_FLASH_OTP ! Check the OTP fuses,
													I2CFLASH_ERASE	! Erase the Flash,
													I2CCHECK_STATUS ! Read the status bit,
								 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
													I2CPROGRAM_USERCODE	! Program USERCODE,
													I2CCHECK_STATUS ! Read the status bit,
													I2CVERIFY_USERCODE		! Verify USERCODE,																																				
													I2CFLASH_VERIFY	! Verify CFG,
													I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													I2CUFM_VERIFY          ! Verify the UFM,
													I2CCHECK_STATUS ! Read the status bit,									 
													I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													I2CFEATURE_ERASE	! Erase the Feature Rows,
													I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													I2CDISABLE ! Exit the programming mode"	;
							 			 											   							  								
	"I2C Erase,Program,Verify with Password" =   "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_ENABLE	! Enable the Flash, 
												I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
												I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												I2CFLASH_ERASE	! Erase the Flash,
												I2CCHECK_STATUS ! Read the status bit,
							 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
												I2CPROGRAM_USERCODE	! Program USERCODE,
												I2CCHECK_STATUS ! Read the status bit,
												I2CVERIFY_USERCODE		! Verify USERCODE,																																				
												I2CFLASH_VERIFY	! Verify CFG,
												I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												I2CUFM_VERIFY          ! Verify the UFM,								 
												I2CCHECK_STATUS ! Read the status bit,	
												I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Fast Configuration with Password" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CCHECK_SRAM_OTP ! Check the OTP fuses,
											I2CSRAM_ENABLE	! Enable SRAM programming mode, 
											I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C Verify Only with Password" = "	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_VERIFY	! Verify the Flash, 
										I2CUFM_VERIFY          ! Verify the UFM,							
										I2CVERIFY_USERCODE	! Verify USERCODE, 
										I2CCHECK_STATUS ! Read the status bit, 
										I2CVERIFY_DONE_BIT ! Verify Done Bit,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C Erase Only with Password" =	"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										I2CCHECK_FLASH_OTP ! Check the OTP fuses,
										I2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_ERASE	! Erase the Flash,
										I2CCHECK_STATUS ! Read the status bit,
					 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Refresh"	=	"I2CINIT 	! Initialize, 
						 I2CREAD_ID	! Check the IDCODE,	
						 I2CREFRESH ! Refresh";		
						 
	"PTM Bypass"	=	"INIT 	! Initialize";	
	"PTM Background Bypass"	=	"INIT 	! Initialize";
							 		
	"PTM Verify ID" = 	"INIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 
	
	"PTM Background Verify ID" = 	"INIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 
						 
	"PTM Display ID" = "INIT, SAVE_ID";	
	
	"PTM Background Display ID" = "INIT, SAVE_ID";	
	
	"PTM Verify USERCODE"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Verify USERCODE"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
												             								 								
	"PTM Display USERCODE"	=	"INIT, 
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
								 FLASH_ENABLE	! Enable the CFG, 
								 SAVE_USERCODE,
								 DISABLE_REFRESH ! Exit the programming mode";
								 
	"PTM Background Display USERCODE"	=	"INIT, 
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											 SAVE_USERCODE,
											 DISABLE ! Exit the programming mode";
								 
								 
	"PTM Disable Only" = "INIT 	! Initialize, 
	 			 		  DISABLE ! Exit the programming mode"	;	
	
	
	"PTM Background Program Feature Rows"  =    "INIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												CHECK_FR_OTP ! Check the OTP fuses,
												CHECK_KEYLOCK ! Check the Key Protection fuses,   
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												FEATURE_ERASE	! Erase the Feature Rows,
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												DISABLE ! Exit the programming mode"	;
	 			 		  				 
	"PTM Erase,Program,Verify" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode";
	
	"PTM Background Erase,Program,Verify,Refresh" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh";
	
	"PTM Background Program,Verify and TransFR" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_STATUS ! Read the status bit,
								FLASH_PROGRAM_STATUS	! Program CFG,
								UFM_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		FLASH_MDR ! Transparent Field Reconfiguration";
			 			 				 			 				 			 					 			 				 			 																									 			 				 			 		
	"PTM Erase,Program,Verify,Secure" = "INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash, 
										CHECK_STATUS ! Read the status bit,
					 			 		FLASH_PROGRAM_STATUS	! Program CFG,
										UFM_PROGRAM_STATUS  ! Program the UFM,
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,			 			 		
					 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,									 			 		
					 			 		DISABLE ! Exit the programming mode,
					 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
			 			 		
	
	"PTM Background Erase,Program,Verify,Secure" = "INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										CHECK_STATUS ! Read the status bit,
					 			 		FLASH_PROGRAM_STATUS	! Program CFG,
										UFM_PROGRAM_STATUS  ! Program the UFM,
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,									 			 		
					 			 		DISABLE ! Exit the programming mode";
					 			 				 			 					 			 		
	
	"PTM Erase,Program,Verify,Secure Plus" = "INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											FLASH_ENABLE	! Enable the Flash, 
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,								
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		UFM_SECURITY ! Secure the UFM,																	 			 					 			 		
						 			 		PROGRAM_SECURITY ! Secure device,
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify,Secure Plus" = "INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_PROGRAM_STATUS	! Program CFG,
											UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,								
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		UFM_SECURITY ! Secure the UFM,																	 			 					 			 		
						 			 		PROGRAM_SECURITY ! Secure device,
						 			 		DISABLE ! Exit the programming mode";
						 			 				 			 					 			 		 
	"PTM Program"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							FLASH_ENABLE	! Enable the Flash,
							CHECK_STATUS ! Read the status bit,
							FLASH_PROGRAM_STATUS	! Program CFG, 
							UFM_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FEATURE_PROGRAM_STATUS ! Program Feature Rows,
							CHECK_STATUS ! Read the status bit,			 			 		
			 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 	DISABLE ! Exit the programming mode";
							
	"PTM Background Program"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									CHECK_STATUS ! Read the status bit,
									FLASH_PROGRAM_STATUS	! Program CFG, 
									UFM_PROGRAM_STATUS  ! Program the UFM,							
									PROGRAM_USERCODE	! Program USERCODE,
									CHECK_STATUS ! Read the status bit,	
									FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 	DISABLE ! Exit the programming mode";
															
	"PTM Verify Only" =	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify CFG, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY_STATUS ! Verify Feature Rows,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE_REFRESH ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Verify Only" =	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							FEATURE_VERIFY_STATUS ! Verify the Feature,
							FLASH_VERIFY	! Verify CFG, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode";
								 			 			
	"PTM Erase Only"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";
							
	
	"PTM Background Erase Only"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,							
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FEATURE_VERIFY_STATUS ! Verify the Feature,
							FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";
		 			 										 			 		
	
	"PTM Calculate Checksum"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
									 SAVE_ID,
									 IO_STATE ! Program Bscan register,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,
									 FLASH_ENABLE	! Enable the Flash, 
						             FLASH_SAVE_ARRAY,
						             UFM_SAVE_ARRAY,
						             FEATURE_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE_REFRESH";
			 						 
	"PTM Background Calculate Checksum"	=	"INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 CHECK_KEYLOCK ! Check the Key Protection fuses,
									 		 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								             FLASH_SAVE_ARRAY,
								             UFM_SAVE_ARRAY,
								             FEATURE_SAVE_ARRAY,
								             SAVE_USERCODE,
					 						 DISABLE";
			 						 			 						 			 						 
	"PTM Read and Save"	=	"INIT, 
							 READ_ID, 
							 SAVE_ID, 
							 IO_STATE ! Program Bscan register,
							 CHECK_KEYLOCK ! Check the Key Protection fuses,
							 FLASH_ENABLE, 
							 FLASH_SAVE_ARRAY, 								 
							 UFM_SAVE_ARRAY,
							 FEATURE_SAVE_ARRAY,
							 SAVE_USERCODE, 
							 DISABLE_REFRESH";		 			 								 
	
	"PTM Background Read and Save"	=	"INIT, 
										 READ_ID, 
										 SAVE_ID, 
										 CHECK_KEYLOCK ! Check the Key Protection fuses,
									 	 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										 FLASH_SAVE_ARRAY, 								 
										 UFM_SAVE_ARRAY,
										 FEATURE_SAVE_ARRAY,
										 SAVE_USERCODE, 
										 DISABLE";
							 
	"PTM UFM Program,Verify" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,   
								FLASH_ENABLE	! Enable the Flash, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background UFM Program,Verify" = "INIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											CHECK_UFM_OTP ! Check the OTP fuses,
											CHECK_KEYLOCK ! Check the Key Protection fuses,   
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											UFM_ERASE	! Erase the UFM, 
											CHECK_STATUS ! Read the status bit,
						 			 		UFM_PROGRAM_STATUS  ! Program the UFM,
						 			 		CHECK_STATUS ! Read the status bit,
											UFM_VERIFY          ! Verify the UFM,
											CHECK_STATUS ! Read the status bit,
											DISABLE ! Exit the programming mode"	;
								
	"PTM Verify UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE_REFRESH ! Exit the programming mode"	;
		 			 		
	"PTM Background Verify UFM" = "	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									CHECK_KEYLOCK ! Check the Key Protection fuses,   
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
									UFM_VERIFY          ! Verify the UFM,
									CHECK_STATUS ! Read the status bit,
				 			 		DISABLE ! Exit the programming mode"	;
		 			 				 			 		
	"PTM UFM Erase" = "	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						CHECK_UFM_OTP ! Check the OTP fuses,
						CHECK_KEYLOCK ! Check the Key Protection fuses,   
						FLASH_ENABLE	! Enable the Flash, 
						UFM_ERASE	! Erase the UFM, 
						CHECK_STATUS ! Read the status bit,
	 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background UFM Erase" = "	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						CHECK_UFM_OTP ! Check the OTP fuses,
						CHECK_KEYLOCK ! Check the Key Protection fuses,   
						FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
						UFM_ERASE	! Erase the UFM, 
						CHECK_STATUS ! Read the status bit,
	 			 		DISABLE ! Exit the programming mode"	;
	 			 				 			 		
	"PTM Display UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SAVE_ID, 
							FLASH_ENABLE	! Enable the Flash, 
							UFM_SAVE_ARRAY, 
							DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Display UFM" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SAVE_ID, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
							
													
	"PTM Secure Device" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_CFG_OTP ! Check the OTP fuses,
							PROGRAM_SECURITY ! Secure device,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background Secure Device" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_OTP ! Check the OTP fuses,
							PROGRAM_SECURITY ! Secure device,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			 			 		
	"PTM Secure Plus" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background Secure Plus" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 				 			 		
	"PTM Read Status Register" = "INIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 FLASH_ENABLE,
					 			 SAVE_STATUS,
					 			 DISABLE_REFRESH";
	
	"PTM Background Read Status Register" = "INIT ! Initialize,
								 			 READ_ID	! Check the IDCODE,
								 			 SAVE_ID,
								 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								 			 SAVE_STATUS,
								 			 DISABLE";
					 			 							 						 						 				 			 					 			 
	"PTM Capture Only" = "INIT 	! Initialize,
						  READ_ID	! Check the IDCODE,
						  IO_STATE ! Capture Bscan register"	;		
						  			 			 							 
	"PTM Upload to Static RAM" = "INIT !Initialize,
								  READ_ID !Check the IDCODE,
								  UPLOAD_FUNCTION ! Uploaded";
						
	"PTM Refresh" = " 	INIT !Initialize,
						READ_ID !Check the IDCODE,
						SRAM_ENABLE	! Enable SRAM programming mode, 
						SRAM_ERASE	! Erase the SRAM,
						DISABLE ! Exit the programming mode";
	
	"PTM Background Refresh" = "INIT !Initialize,
								READ_ID !Check the IDCODE,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM,
								DISABLE ! Exit the programming mode";
						
						
	"ASC Erase,Program,Verify" =	"ASC_INIT 	! Initialize, 
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"ASC Background Erase,Program,Verify" =	"ASC_BACKGROUND_INIT 	! Initialize,  
									 ASC_CHECK_MUTEX ! Check the Mutex,	
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
									 
	"ASC Erase,Program,Verify,I2CSA" =	"ASC_INIT 	! Initialize, 
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_ERASE_I2CSA ! Erase the I2CSA,
									 ASC_PROGRAM_I2CSA ! Program I2CSA,
									 ASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"ASC Background Erase,Program,Verify,I2CSA" =	"ASC_BACKGROUND_INIT 	! Initialize, 
									 ASC_CHECK_MUTEX ! Check the Mutex,	
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_ERASE_I2CSA ! Erase the I2CSA,
									 ASC_PROGRAM_I2CSA ! Program I2CSA,
									 ASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 
	"ASC I2CSA Program" =	"ASC_INIT 	! Initialize, 
							 ASCREAD_ID	! Check the IDCODE,	
							 ASC_ENABLE	! Enable the ASC, 
							 ASC_ERASE_I2CSA ! Erase the I2CSA,
							 ASC_PROGRAM_I2CSA ! Program I2CSA,
							 ASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"ASC Background I2CSA Program" =	"ASC_BACKGROUND_INIT 	! Initialize, 
										 ASC_CHECK_MUTEX ! Check the Mutex,
										 ASCREAD_ID	! Check the IDCODE,	
										 ASC_ENABLE	! Enable the ASC, 
										 ASC_ERASE_I2CSA ! Erase the I2CSA,
										 ASC_PROGRAM_I2CSA ! Program I2CSA,
										 ASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
							 
	"ASC I2CSA Erase Only" =	"ASC_INIT 	! Initialize, 
								 ASCREAD_ID	! Check the IDCODE,	
								 ASC_ENABLE	! Enable the ASC, 
								 ASC_ERASE_I2CSA ! Erase the I2CSA,
								 ASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	"ASC Background I2CSA Erase Only" =	"ASC_BACKGROUND_INIT 	! Initialize,
										 ASC_CHECK_MUTEX ! Check the Mutex,
										 ASCREAD_ID	! Check the IDCODE,	
										 ASC_ENABLE	! Enable the ASC, 
										 ASC_ERASE_I2CSA ! Erase the I2CSA,
										 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
							 								 			 			 		 	
	"ASC Program" =	 	"ASC_INIT 	! Initialize, 
						 ASCREAD_ID	! Check the IDCODE,	
						 ASC_ENABLE	! Enable the ASC, 
						 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
						 ASCCHECK_STATUS ! Read the status,
	 			 		 ASC_PROGRAM_STATUS	! Program CFG,
						 ASCPROGRAM_USERCODE	! Program USERCODE,
						 ASCCHECK_STATUS ! Read the status bit,
						 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
						 ASC_DIRECT_DISABLE ! Exit the programming mode"	;
	 
	 "ASC Background Program" =	 	"ASC_BACKGROUND_INIT 	! Initialize, 
									 ASC_CHECK_MUTEX ! Check the Mutex,
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
						 			 		 
	"ASC Erase Only" = "ASC_INIT 	! Initialize, 
							 ASCREAD_ID	! Check the IDCODE,	
							 ASC_ENABLE	! Enable the ASC, 
							 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 ASCCHECK_STATUS ! Read the status,
		 			 		 ASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"ASC Background Erase Only" = "ASC_BACKGROUND_INIT 	! Initialize,
									 ASC_CHECK_MUTEX ! Check the Mutex,
									 ASCREAD_ID	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"ASC Verify Only" = "ASC_INIT 	! Initialize, 
							 ASCREAD_ID	! Check the IDCODE,	
							 ASC_ENABLE	! Enable the ASC, 
							 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 ASC_VERIFY	! Verify ASC CFG,
							 ASCCHECK_STATUS ! Read the status bit,	
							 ASC_DIRECT_DISABLE ! Exit the programming mode"	;
							 
	"ASC Background Verify Only" = "ASC_BACKGROUND_INIT 	! Initialize,
									 ASC_CHECK_MUTEX ! Check the Mutex,	
									 ASCREAD_ID	! Check the IDCODE,
									 ASC_ENABLE	! Enable the ASC, 
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
							 							 
	"ASC Read Status Register" = "ASC_INIT 	! Initialize, 
								     ASCREAD_ID	! Check the IDCODE,	
								     ASCSAVE_ID	,	
									 ASC_SAVE_STATUS,
									 ASC_EXIT_USERMODE ! Exit the programming mode";
									 
	"ASC Background Read Status Register" = "ASC_BACKGROUND_INIT 	! Initialize, 
								     ASC_CHECK_MUTEX ! Check the Mutex,
									 ASCREAD_ID	! Check the IDCODE,	
								     ASCSAVE_ID	,	
								     ASC_SAVE_STATUS,
									 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";
									 
	"ASC Verify ID" = "ASC_INIT 	! Initialize, 
					     ASCREAD_ID	! Check the IDCODE";
					     
	"ASC Background Verify ID" = "ASC_BACKGROUND_INIT 	! Initialize,
					     		  ASC_CHECK_MUTEX ! Check the Mutex,
								  ASCREAD_ID	! Check the IDCODE,
								  ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";
					     
	"ASC Display ID" = "ASC_INIT 	! Initialize, 
					    ASCSAVE_ID";					     									 							 								 							 			 																													  
	
	"ASC Background Display ID" = "ASC_BACKGROUND_INIT 	! Initialize,
							       ASC_CHECK_MUTEX ! Check the Mutex,
					    		   ASCSAVE_ID,
					    		   ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";	
	
	"ASC Refresh" = 		"ASC_INIT 	! Initialize, 
							 ASCREAD_ID	! Check the IDCODE,	
							 ASC_REFRESH	! Refresh"	;
								 				    
	"ASC Background Refresh" = 		"ASC_BACKGROUND_INIT 	! Initialize,
								     ASC_CHECK_MUTEX ! Check the Mutex,
								     ASCREAD_ID	! Check the IDCODE,	
								     ASC_REFRESH	! Refresh,
								     ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
							 
	"ASC Read Shadow Registers" = "ASC_INIT 	! Initialize, 
								   ASCREAD_ID	! Check the IDCODE,	
								   ASCSAVE_ID,
								   ASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;

	"ASC Background Read Shadow Registers" = "ASC_BACKGROUND_INIT 	! Initialize,
											   ASC_CHECK_MUTEX ! Check the Mutex,
											   ASCREAD_ID	! Check the IDCODE,	
											   ASCSAVE_ID,
											   ASC_READ_SHADOW_REGISTERS	! Read ASC Shadow,
											   ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode"	;
								   
								   
	"ASC Read FaultLog Registers" = "ASC_INIT 	! Initialize, 
									     ASCREAD_ID	! Check the IDCODE,	
									     ASCSAVE_ID,
										 ASC_ENABLE	! Enable the ASC, 
										 ASC_SAVE_FAULTLOG_REGISTERS,
										 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Registers" = "ASC_BACKGROUND_INIT 	! Initialize, 
									     ASC_CHECK_MUTEX ! Check the Mutex,
										 ASCREAD_ID	! Check the IDCODE,	
									     ASCSAVE_ID,
									     ASC_ENABLE	! Enable the ASC, 
										 ASC_SAVE_FAULTLOG_REGISTERS,
										 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";
										 
	"ASC Read FaultLog Memory" = "ASC_INIT 	! Initialize, 
								     ASCREAD_ID	! Check the IDCODE,
								     ASCSAVE_ID,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_SAVE_FAULTLOG_MEMORY,
									 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Memory" = "ASC_BACKGROUND_INIT 	! Initialize, 
										     ASC_CHECK_MUTEX ! Check the Mutex,
											 ASCREAD_ID	! Check the IDCODE,
										     ASCSAVE_ID,	
										     ASC_ENABLE	! Enable the ASC, 
											 ASC_SAVE_FAULTLOG_MEMORY,
											 ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";
	
	"ASC FaultLog Erase Only" = "ASC_INIT 	! Initialize, 
							     ASCREAD_ID	! Check the IDCODE,
							     ASCSAVE_ID,	
								 ASC_ENABLE	! Enable the ASC, 
								 ASC_ERASE_FAULTLOG_MEMORY,
								 ASC_EXIT_USERMODE ! Exit the programming mode";
									 								 
	"ASC Read and Save" = "ASC_INIT 	! Initialize, 
						   ASCREAD_ID	! Check the IDCODE,
						   ASCSAVE_ID,
						   ASC_ENABLE	! Enable the ASC, 									 	
						   ASC_SAVE,
						   ASCSAVE_USERCODE,
						   ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read and Save" = " ASC_BACKGROUND_INIT 	! Initialize, 
									   ASC_CHECK_MUTEX ! Check the Mutex,
									   ASCREAD_ID	! Check the IDCODE,
									   ASCSAVE_ID,
									   ASC_ENABLE	! Enable the ASC, 									 	
									   ASC_SAVE,
									   ASCSAVE_USERCODE,
									   ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";
						   
	"ASC Calculate Data CRC"	=	"ASC_INIT 	! Initialize, 
									 ASCREAD_ID	! Check the IDCODE,
								   ASCSAVE_ID,
								   ASC_ENABLE	! Enable the ASC, 									 	
								   ASC_SAVE,
								   ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Calculate Data CRC"	=	"ASC_BACKGROUND_INIT 	! Initialize, 
									 		 ASC_CHECK_MUTEX ! Check the Mutex,
								   			 ASCREAD_ID	! Check the IDCODE,
								   			 ASCSAVE_ID,
								   			 ASC_ENABLE	! Enable the ASC, 									 	
										     ASC_SAVE,
										     ASC_EXIT_USERMODE_BACKGROUND ! Exit the programming mode";

	
	
	"JTAGI2C Re-Initialize" = "JTAGI2CINIT 	! Initialize,  
						  	 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							 JTAGI2CFLASH_ERASE	! Erase the Flash,
							 JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		 JTAGI2CDISABLE ! Exit the programming mode"	;
	 			 		  	 
	"JTAGI2C Verify ID" = "JTAGI2CINIT 	! Initialize, 
						   JTAGI2CREAD_ID	! Check the IDCODE";
	"JTAGI2C Display ID" = "JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSAVE_ID";						
	
	"JTAGI2C Program Feature Rows" =    "JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CCHECK_FR_OTP ! Check the OTP fuses, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 			JTAGI2CFEATURE_ENABLE	! Enable the Flash, 
										JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
										JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	"JTAGI2C Read Feature Rows"	=	"JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 		 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CFEATURE_SAVE_ARRAY	! Read the Feature row, 
									 JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C Display USERCODE"	=	"JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Read Status Register" = "JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
					 			 	 JTAGI2C_SAVE_STATUS,
					 			 	 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Fast Program" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Fast Configuration" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C Background Fast Program" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Fast Configuration" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C SEI Fast Program" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background SEI Fast Program" = "JTAGI2CINIT 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
										 			 								
	"JTAGI2C Erase,Program,Verify,Feature" =   "JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Feature,Secure" =   "JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C Erase,Program,Verify,Feature,Secure Plus" =   "JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												JTAGI2CUFM_SECURITY ! Secure the UFM,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;	
							 			 							 			 					 			 					 			 		
	"JTAGI2C Erase,Program,Verify" =   "JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							         	JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
										JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
										JTAGI2CFLASH_VERIFY	! Verify CFG,
										JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
										JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
										JTAGI2CCHECK_STATUS ! Read the status bit,	
										JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program" =   "JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
							JTAGI2CFLASH_ERASE	! Erase the Flash,
							JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
		 			 		JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
		 			 		JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,							
							JTAGI2CCHECK_STATUS ! Read the status bit,
							JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Secure" =   "JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							         			JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,								 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,
							 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							         				JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							         				JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,								 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
													JTAGI2CUFM_SECURITY ! Secure the UFM,	
													JTAGI2CPROGRAM_SECURITY ! Secure device,
								 			 		JTAGI2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"JTAGI2C Verify Only" = "JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							JTAGI2CFLASH_ENABLE	! Enable the Flash,
							JTAGI2CFLASH_VERIFY	! Verify the Flash,
							JTAGI2CUFM_VERIFY          ! Verify the UFM,
							JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
							JTAGI2CCHECK_STATUS ! Read the status bit, 
							JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
							JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase Only"	=	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
								JTAGI2CFLASH_ERASE	! Erase the Flash,
								JTAGI2CCHECK_STATUS ! Read the status bit,
			 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Full Erase"	=	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
								JTAGI2CFLASH_ERASE	! Erase the Flash,
								JTAGI2CCHECK_STATUS ! Read the status bit,
			 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
			 			 		
	"JTAGI2C Recovery Erase Only"	=	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
					 			 		
				 			 				 			 						 			 								
	"JTAGI2C Background Program Feature Rows" =    "JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    					JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
													JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
													JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
													JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"JTAGI2C Background Erase,Program,Verify,Feature" =   "JTAGI2CINIT 	! Initialize, 
															JTAGI2CREAD_ID	! Check the IDCODE, 
															JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    							JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
															JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
															JTAGI2CFLASH_ERASE	! Erase the Flash,
															JTAGI2CCHECK_STATUS ! Read the status bit,
										 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
															JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
															JTAGI2CCHECK_STATUS ! Read the status bit,
															JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
															JTAGI2CFLASH_VERIFY	! Verify CFG,
															JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
															JTAGI2CUFM_VERIFY          ! Verify the UFM,
															JTAGI2CCHECK_STATUS ! Read the status bit,									 
															JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
															JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
															JTAGI2CCHECK_STATUS ! Read the status bit,	
															JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
										 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"JTAGI2C Background Erase,Program,Verify" =   "JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    					JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							    					JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,								 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Program" =   "JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    	JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							    	JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
									JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,								
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"JTAGI2C Background Erase,Program,Verify,Secure" =   "JTAGI2CINIT 	! Initialize, 
															JTAGI2CREAD_ID	! Check the IDCODE, 
															JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    							JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,  
							    							JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
															JTAGI2CFLASH_ERASE	! Erase the Flash,
															JTAGI2CCHECK_STATUS ! Read the status bit,
										 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
															JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
															JTAGI2CCHECK_STATUS ! Read the status bit,
															JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
															JTAGI2CFLASH_VERIFY	! Verify CFG,
															JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
															JTAGI2CUFM_VERIFY          ! Verify the UFM,
															JTAGI2CCHECK_STATUS ! Read the status bit,								 
															JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
															JTAGI2CPROGRAM_SECURITY ! Secure device,
										 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"JTAGI2C Background Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT 	! Initialize, 
																JTAGI2CREAD_ID	! Check the IDCODE, 
																JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    								JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							    								JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
																JTAGI2CFLASH_ERASE	! Erase the Flash,
																JTAGI2CCHECK_STATUS ! Read the status bit,
											 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
																JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
																JTAGI2CCHECK_STATUS ! Read the status bit,
																JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
																JTAGI2CFLASH_VERIFY	! Verify CFG,
																JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
																JTAGI2CUFM_VERIFY          ! Verify the UFM,	
																JTAGI2CCHECK_STATUS ! Read the status bit,							 
																JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
																JTAGI2CUFM_SECURITY ! Secure the UFM,	
																JTAGI2CPROGRAM_SECURITY ! Secure device,
											 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"JTAGI2C Background Verify Only" = "JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    		JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
										JTAGI2CFLASH_VERIFY	! Verify the Flash, 
										JTAGI2CUFM_VERIFY          ! Verify the UFM,							
										JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 
										JTAGI2CCHECK_STATUS ! Read the status bit, 
										JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
										JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"JTAGI2C Background Erase Only"	=	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,										
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							    		JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							    		JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	"JTAGI2C Refresh"	=	"JTAGI2CINIT 	! Initialize, 
							 JTAGI2CREAD_ID	! Check the IDCODE,	
							 JTAGI2CREFRESH ! Refresh";	
							 
	
	"JTAGI2C Check Feature Row"	=	"JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;
	
	"JTAGI2C Check Protect Fuses" =  "JTAGI2CINIT 	! Initialize, 
								      JTAGI2CREAD_ID	! Check the IDCODE, 
								      JTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;	
	
	
	"JTAGI2C Erase Feature Row with Password Key"	=	"JTAGI2CINIT 	! Initialize, 
													 JTAGI2CREAD_ID	! Check the IDCODE, 
													 JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
													 JTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
													 JTAGI2CFLASH_ENABLE	! Enable the Flash, 	
													 JTAGI2CFEATURE_ERASE	! Erase the Feature row, 
													 JTAGI2CFLASH_ERASE	! Erase the Flash,
													 JTAGI2CCHECK_STATUS ! Read the status bit,
													 JTAGI2CDISABLE ! Exit the programming mode"	;
																																																														
	"JTAGI2C Program Password Key" = "JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
								  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								  JTAGI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  JTAGI2CDISABLE ! Exit the programming mode" ;
							  
	"JTAGI2C Program Password Key with Lock" = "JTAGI2CINIT 	! Initialize, 
								  			JTAGI2CREAD_ID	! Check the IDCODE, 
								  			JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
								  			JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode" ;							  	
	
	"JTAGI2C EPV with Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	JTAGI2CDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C EPVS with Password Key Option" = "JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CPROGRAM_SECURITY ! Secure device,							 			 	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C EPV with my_ASSP, Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash, 
													JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,									 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
													JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													JTAGI2CDISABLE ! Exit the programming mode"	;
																				  									
	"JTAGI2C Erase,Program,Verify with Password" =   "JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											         	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											         	JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
														JTAGI2CFLASH_ERASE	! Erase the Flash,
														JTAGI2CCHECK_STATUS ! Read the status bit,
									 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
														JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
														JTAGI2CCHECK_STATUS ! Read the status bit,
														JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
														JTAGI2CFLASH_VERIFY	! Verify CFG,
														JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
														JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
														JTAGI2CCHECK_STATUS ! Read the status bit,	
														JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
									 			 		
	"JTAGI2C Fast Configuration with Password" = "JTAGI2CINIT 	! Initialize,   
													  JTAGI2CREAD_ID	! Check the IDCODE,
													  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
													  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
													  JTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
													  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
													  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
													  JTAGI2CDISABLE ! Exit the programming mode"	;
													  
	"JTAGI2C Verify Only with Password" = "JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CFLASH_VERIFY	! Verify the Flash,
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
											JTAGI2CCHECK_STATUS ! Read the status bit, 
											JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C Erase Only with Password" =	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
										    JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
							 
	"I2CASC Erase,Program,Verify" =	"I2CASC_INIT 	! Initialize, 
									 I2CASCREAD_ID	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify" =	"I2CASC_INIT 	! Initialize, 
												 I2CASCREAD_ID	! Check the IDCODE,	
												 I2CASC_ENABLE	! Enable the ASC, 
												 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
												 I2CASC_PROGRAM_STATUS	! Program CFG,
												 I2CASCPROGRAM_USERCODE	! Program USERCODE,
												 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
												 I2CASC_VERIFY	! Verify ASC CFG,
												 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
												 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
									 
	"I2CASC Erase,Program,Verify,I2CSA" =	"I2CASC_INIT 	! Initialize, 
											 I2CASCREAD_ID	! Check the IDCODE,	
											 I2CASC_ENABLE	! Enable the ASC, 
											 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
											 I2CASC_PROGRAM_STATUS	! Program CFG,
											 I2CASCPROGRAM_USERCODE	! Program USERCODE,
											 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
											 I2CASC_VERIFY	! Verify ASC CFG,
											 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
											 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
											 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
											 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify,I2CSA" =	"I2CASC_INIT 	! Initialize, 
														 I2CASCREAD_ID	! Check the IDCODE,	
														 I2CASC_ENABLE	! Enable the ASC, 
														 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
														 I2CASC_PROGRAM_STATUS	! Program CFG,
														 I2CASCPROGRAM_USERCODE	! Program USERCODE,
														 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
														 I2CASC_VERIFY	! Verify ASC CFG,
														 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
														 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
														 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
														 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 
	"I2CASC I2CSA Program" =	"I2CASC_INIT 	! Initialize, 
								 I2CASCREAD_ID	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
								 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Program" =	"I2CASC_INIT 	! Initialize, 
										 I2CASCREAD_ID	! Check the IDCODE,	
										 I2CASC_ENABLE	! Enable the ASC, 
										 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
										 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
										 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 
	"I2CASC I2CSA Erase Only" =	"I2CASC_INIT 	! Initialize, 
								 I2CASCREAD_ID	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Erase Only" =	"I2CASC_INIT 	! Initialize, 
											 I2CASCREAD_ID	! Check the IDCODE,	
											 I2CASC_ENABLE	! Enable the ASC, 
											 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
											 I2CASC_EXIT_USERMODE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
											 			 			 		 	
	"I2CASC Program" =	 	"I2CASC_INIT 	! Initialize, 
							 I2CASCREAD_ID	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 I2CASC_PROGRAM_STATUS	! Program CFG,
							 I2CASCPROGRAM_USERCODE	! Program USERCODE,
							 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	 
	"I2CASC Background Program" =	 "I2CASC_INIT 	! Initialize, 
									 I2CASCREAD_ID	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
						 			 		 
	"I2CASC Erase Only" = "I2CASC_INIT 	! Initialize, 
						 I2CASCREAD_ID	! Check the IDCODE,	
						 I2CASC_ENABLE	! Enable the ASC, 
						 I2CASC_ERASE_BECFG	! Erase the ASC CFG,
						 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase Only" = "I2CASC_INIT 	! Initialize, 
									 I2CASCREAD_ID	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"I2CASC Verify Only" = 	"I2CASC_INIT 	! Initialize, 
							 I2CASCREAD_ID	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC,
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																											 							  
				 			 I2CASC_VERIFY	! Verify ASC CFG,
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
							 
	
	"I2CASC Background Verify Only" = 	"I2CASC_INIT 	! Initialize, 
							 I2CASCREAD_ID	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC,
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																											 							  
							 I2CASC_VERIFY	! Verify ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
							 						 
	"I2CASC Read Status Register" = "I2CASC_INIT 	! Initialize, 
								     I2CASCREAD_ID	! Check the IDCODE,	
								     I2CASCSAVE_ID	,	
									 I2CASC_SAVE_STATUS";
								 
	"I2CASC Background Read Status Register" = "I2CASC_INIT 	! Initialize, 
											     I2CASCREAD_ID	! Check the IDCODE,	
											     I2CASCSAVE_ID	,	
												 I2CASC_SAVE_STATUS";
								 								 
	"I2CASC Verify ID" = "I2CASC_INIT 	! Initialize, 
					   I2CASCREAD_ID	! Check the IDCODE";
					     
	"I2CASC Background Verify ID" = "I2CASC_INIT 	! Initialize, 
					     		  I2CASCREAD_ID	! Check the IDCODE";
					     
	"I2CASC Display ID" = "I2CASC_INIT 	! Initialize, 
					    I2CASCSAVE_ID";					     									 							 								 							 			 																													  
	
	"I2CASC Background Display ID" = "I2CASC_INIT 	! Initialize, 
					    			I2CASCSAVE_ID";	
					    
	"I2CASC Refresh" = 		"I2CASC_INIT 	! Initialize, 
							 I2CASCREAD_ID	! Check the IDCODE,	
							 I2CASC_REFRESH	! Refresh"	;
	
	"I2CASC Read Shadow Registers" = "I2CASC_INIT 	! Initialize, 
								   I2CASCREAD_ID	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;

	"I2CASC Background Read Shadow Registers" = "I2CASC_INIT 	! Initialize, 
								   I2CASCREAD_ID	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;
								   
								   					 
	"I2CASC Read FaultLog Registers" = "I2CASC_INIT 	! Initialize, 
								     I2CASCREAD_ID	! Check the IDCODE,	
								     I2CASCSAVE_ID,
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_REGISTERS,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Registers" = "I2CASC_INIT 	! Initialize, 
								     I2CASCREAD_ID	! Check the IDCODE,	
								     I2CASCSAVE_ID,
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_REGISTERS,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
									 
	"I2CASC Read FaultLog Memory" = "I2CASC_INIT 	! Initialize, 
							     I2CASCREAD_ID	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_SAVE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Memory" = "I2CASC_INIT 	! Initialize, 
							     I2CASCREAD_ID	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_SAVE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
								 
	"I2CASC FaultLog Erase Only" = "I2CASC_INIT 	! Initialize, 
							     I2CASCREAD_ID	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background FaultLog Erase Only" = "I2CASC_INIT 	! Initialize, 
							     I2CASCREAD_ID	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
								 							 
	"I2CASC Read and Save" = "I2CASC_INIT 	! Initialize, 
						   I2CASCREAD_ID	! Check the IDCODE,
						   I2CASCSAVE_ID,
						   I2CASC_ENABLE	! Enable the ASC,
						   I2CASC_SAVE,
						   I2CASCSAVE_USERCODE,						    									 							   
						   I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read and Save" = "I2CASC_INIT 	! Initialize, 
						   I2CASCREAD_ID	! Check the IDCODE,
						   I2CASCSAVE_ID,
						   I2CASC_ENABLE	! Enable the ASC,
						   I2CASCSAVE_USERCODE,						    									 	
						   I2CASC_SAVE,
						   I2CASC_EXIT_USERMODE ! Exit the programming mode";
						   
	"I2CASC Calculate Data CRC"	=	"I2CASC_INIT 	! Initialize, 
									 I2CASCREAD_ID	! Check the IDCODE,
								   	I2CASCSAVE_ID,
								   I2CASC_ENABLE	! Enable the ASC, 									 	
								   I2CASC_SAVE,
								   I2CASC_EXIT_USERMODE ! Exit the programming mode";
								   
	"I2CASC Background Calculate Data CRC"	=	"I2CASC_INIT 	! Initialize, 
									 I2CASCREAD_ID	! Check the IDCODE,
								   	I2CASCSAVE_ID,
								   I2CASC_ENABLE	! Enable the ASC, 									 	
								   I2CASC_SAVE,
								   I2CASC_EXIT_USERMODE ! Exit the programming mode";
				 		  	 						  																
</Operation_List>
<Operation_List label="SingleSVFOperation">		 			 		
	
	"Program Manufacturing Register" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  PSUEDO_FLASH_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_MANUFACTURING_REGISTER ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;
									  
	"Manufacturing Toggle BG_OFF" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  PSUEDO_FLASH_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_BG_OFF ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;
									  
	"SRAM Boot From External PROM" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_FR_OTP ! Check the OTP fuses,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 FLASH_ENABLE	! Enable the programming mode,
					 FEATURE_ERASE	! Erase the Feature,
					 CHECK_STATUS ! Read the status bit,
					 BOOT_EXTERNAL_FEATURE_PROGRAM, 
					 DISABLE_REFRESH ! Exit the programming mode" ;
					 
	"Verify SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_MSPI ! Check the MSPI Setting,  
					 CHECK_SRAM_OTP ! Check the OTP fuses,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 PSUEDO_FLASH_ENABLE	! Enable the Flash Pseudo programming mode,
					 PSUEDO_FLASH_ERASE	! Erase the Shadow Feature Rows register,
					 CHECK_STATUS ! Read the status bit, 
					 SPI_FEATURE_PROGRAM ! Enable MSPI, 
					 DISABLE_REFRESH ! Exit the programming mode,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = "SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_OTP ! Check the OTP fuses,
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  											 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;
					 			 				 
	"SRAM Boot From Internal PROM" = " SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_FR_OTP ! Check the OTP fuses,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
									 FLASH_ENABLE	! Enable the programming mode,
									 FEATURE_ERASE	! Erase the Feature,
									 CHECK_STATUS ! Read the status bit,
									 BOOT_INTERNAL_FEATURE_PROGRAM ! Enable MSPI,
									 DISABLE_REFRESH ! Exit the programming mode" ;
									   
	
	"Security Erase Feature Rows"	=	"SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses, 									
										FLASH_ENABLE	! Enable the programming mode, 	
										FEATURE_ERASE	! Erase the Feature row,										
										FLASH_ERASE	! Erase the CFG,  
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
														
	"Security Check Feature Row"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses"	;				
										
	"Security Program Feature Bits"	=	"SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										PROGRAM_CONFIG_REGISTER ! Program the Feature Bits,
										DISABLE ! Exit the programming mode"	;
	
	"Security Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
					 			 SAVE_STATUS,
					 			 DISABLE";
	
	"Security Check Protect Fuses" =  "SVFINIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	"Verify ID with Password" = 		"SVFINIT 	! Initialize, 
						 				READ_ID ! Check the IDCODE,
						 				SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key";
						 												   																											
	"Security Read Feature Row with Password Key"	=	"SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														SAVE_ID,
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
														FEATURE_ROW_READ	! Read the Feature row, 
														DISABLE ! Exit the programming mode"	;
										
	"Security Erase Feature Row with Password Key"	=	"SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														CHECK_FR_OTP ! Check the OTP fuses,
														SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 									
														FLASH_ENABLE	! Enable the programming mode, 	
														FEATURE_ERASE	! Erase the Feature row, 
														FLASH_ERASE	! Erase the CFG, 
														CHECK_STATUS ! Read the status bit,
														DISABLE ! Exit the programming mode"	;
																																																														
	"Security Program Password Key" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  CHECK_FR_OTP ! Check the OTP fuses,
									  CHECK_KEYLOCK ! Check the Key Protection fuses,  
									  FLASH_ENABLE	! Enable the programming mode,
									  PROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  DISABLE ! Exit the programming mode" ;
							  
	"Security Program Password Key with Lock" = "SVFINIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  CHECK_FR_OTP ! Check the OTP fuses,
												  CHECK_KEYLOCK ! Check the Key Protection fuses,  
												  FLASH_ENABLE	! Enable the programming mode,
												  PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
												  DISABLE ! Exit the programming mode" ;
							  
	"Security Check Password Key" =  "SVFINIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 																							
									   READ_PROTECT_KEY_FUSES ! Read the Protection Fuses,
									   DISABLE ! Exit the programming mode" ;
								   				 			 
	"Security Flash EPV with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 															   
	
	"Security Flash EPVS with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,									 			 		
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security Flash Program with Password" = "SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											FLASH_ERASE_NO_FEA	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode"	;
						 			 				 			 		
	"Security Flash Erase with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
													FLASH_ENABLE	! Enable the programming mode, 
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,
													FLASH_ERASE_NO_FEA	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
							
	"Security Flash Verify with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  											
													FLASH_ENABLE	! Enable the programming mode, 
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode,
													VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							
							
	"Security XFlash EPV with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											FLASH_ERASE_NO_FEA	! Erase the CFG, 
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode"	;
			 			 										 			 					 			 		
	
	"Security XFlash EPVS with Password" = "	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
												SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												CHECK_CFG_UFM_OTP ! Check the OTP fuses,
												FLASH_ERASE_NO_FEA	! Erase the CFG, 
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,				 			 		
							 			 		DISABLE ! Exit the programming mode"	;
			 			 			 			 															  
	"Security XFlash Program with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											FLASH_ERASE_NO_FEA	! Erase the CFG, 
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode"	;
						 			 		
	"Security XFlash Erase with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,
													FLASH_ERASE_NO_FEA	! Erase the CFG, 
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
		 			 					 			 		
	
	"Security XFlash Verify with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode"	;
							
	
	"Security Fast Program with Password" = "SVFINIT 	! Initialize,   
											READ_ID	! Check the IDCODE,
											IO_STATE ! Program Bscan register,
											CHECK_SRAM_OTP ! Check the OTP fuses,
									 		SRAM_ENABLE	! Enable SRAM programming mode,
									 		SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											SRAM_ERASE	! Erase the SRAM, 
											BURST_PROGRAM	! Program Fuse Map,
											VERIFY_USERCODE		! Verify USERCODE,
											DISABLE ! Exit the programming mode"	;
	
	
	"Security SRAM EPV with Password" = "SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		SRAM_ENABLE	! Enable SRAM programming mode, 
						 		SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;						
			 			 		
	"Security SRAM Erase with Password"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;
	
	"Security SRAM Verify with Password"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	
	"Security XSRAM SEI Fast Program with Password" = "SVFINIT 	! Initialize,   
													READ_ID	! Check the IDCODE,
													CHECK_SRAM_OTP ! Check the OTP fuses,
													SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													BURST_PROGRAM	! Program Fuse Map,
													DISABLE ! Exit the programming mode,
													VERIFY_STATUS ! Verify Status Register"	;
	
	"Security XSRAM Verify with Password"	=	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,  
												SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
												SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SRAM_VERIFY	! Verify Fuse Map, 
												SRAM_VERIFY_USERCODE		! Verify USERCODE, 
							 			 		DISABLE ! Exit the programming mode"	;	 			 		
	
	"Security EPV with Password Key Option" = 	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,   
												FLASH_ENABLE	! Enable the programming mode,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,								
												CHECK_STATUS ! Read the status bit,
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,		
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							 			 		
	"Security EPVS with Password Key Option" = "SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,  
												FLASH_ENABLE	! Enable the programming mode,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,	
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_SECURITY ! Secure device,									 			 									 			 		
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPV with my_ASSP, Password Key Option" = 	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK_OPTION ! Verify the Protection Key,   
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPV with OTP Option" = 	"	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
						 			 		OTP_PROGRAM_STATUS ! Program OTP, 	
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
										
 	
 	"Security EPVS with OTP Option" = 	"	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,							 			 		
						 			 		OTP_PROGRAM_STATUS ! Program OTP, 
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
						 			 		
	"Security EPV with Full OTP Option" =  	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													CHECK_KEYLOCK ! Check the Key Protection fuses,  
													FLASH_ENABLE	! Enable the Flash,
													CHECK_FLASH_OTP ! Check the OTP fuses,
													DIRECT_FLASH_ERASE	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													FLASH_FULL_PROGRAM_STATUS	! Program CFG,
													UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
													PROGRAM_USERCODE	! Program USERCODE,
													CHECK_STATUS ! Read the status bit,
													FLASH_VERIFY	! Verify CFG,
													UFM_VERIFY          ! Verify the UFM,								 
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit,	
													FEATURE_PROGRAM_STATUS ! Program Feature Rows,
													CHECK_STATUS ! Read the status bit,			 			 		
								 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
								 			 		OTP_FEATURE_ROW_STATUS ! Program OTP, 	
								 			 		DISABLE ! Exit the programming mode,
								 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPVS with Full OTP Option" = "	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													CHECK_KEYLOCK ! Check the Key Protection fuses,  
													FLASH_ENABLE	! Enable the Flash,
													CHECK_FLASH_OTP ! Check the OTP fuses,
													DIRECT_FLASH_ERASE	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													FLASH_FULL_PROGRAM_STATUS	! Program CFG,
													UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
													PROGRAM_USERCODE	! Program USERCODE,
													CHECK_STATUS ! Read the status bit,
													FLASH_VERIFY	! Verify CFG,
													UFM_VERIFY          ! Verify the UFM,								 
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit,	
													FEATURE_PROGRAM_STATUS ! Program Feature Rows,
													CHECK_STATUS ! Read the status bit,			 			 		
								 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								 			 		UFM_SECURITY ! Secure the UFM,
								 			 		PROGRAM_SECURITY ! Secure device,	
								 			 		OTP_FEATURE_ROW_STATUS ! Program OTP, 
								 			 		DISABLE ! Exit the programming mode,
								 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
								 			 		
	"Security EPV with my_ASSP Option" = 	"	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;	
										
	"Security EPVS with my_ASSP Option" = 	"	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses, 
												FLASH_ENABLE	! Enable the Flash, 
												CHECK_FLASH_OTP ! Check the OTP fuses,
												DIRECT_FLASH_ERASE	! Erase the Flash, 
												CHECK_STATUS ! Read the status bit,
							 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
												UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,									 			 		
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;								 			 										 			 								 			 		
	
	"FLASH Verify Feature Rows"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses, 
										FLASH_ENABLE	! Enable the programming mode, 
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;
	
	"FLASH Program Feature Rows"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the Flash, 
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;	
	
	"Bypass"	=	"SVFINIT 	! Initialize";																								 			 					 			 
	"FLASH Bypass"	=	"SVFINIT 	! Initialize";
	"FLASH Verify ID" = 	"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"Verify ID" = 		"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"FLASH Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	
	"FLASH Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 FLASH_ENABLE	! Enable the Flash, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"FLASH Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 			 FLASH_ENABLE	! Enable the Flash, 
					 			 CHECK_CFG_OTP ! Check the OTP fuses,					 			 
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
					             
	"FLASH Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the Flash, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	; 								
	"FLASH Display USERCODE"	=	"SVFINIT, 
									 READ_ID	! Check the IDCODE,
									 FLASH_ENABLE	! Enable the Flash, 
									 SVF_SAVE_USERCODE,
									 DISABLE ! Exit the programming mode";
	"FLASH Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"FLASH Enable Only" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
						   FLASH_ENABLE	! Enable the CFG"	;
	"FLASH Erase DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,								
								CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								FLASH_ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
	"FLASH Program DONE bit"	=	"SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
									 FLASH_ENABLE	! Enable the Flash, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"FLASH Read DONE bit" = 	"SVFINIT, 
								 READ_ID, 
								 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 SVF_SAVE_DONE_BIT,
								 DISABLE ! Exit the programming mode";
	
	"FLASH Re-Initialize" = "SVFINIT 	! Initialize,  
							 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 		 FLASH_ENABLE	! Enable programming mode, 
						  	 DIRECT_FLASH_ERASE	! Erase the CFG, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 		
	"FLASH CFG and UFM Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FLASH_ERASE_NO_FEA	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,	
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 					 			 		
	
	"FLASH Program,Verify,skip Erase" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 				 			 		
	"Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 					 			 		
	
	"FLASH CFG Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_CFG_OTP ! Check the OTP fuses,
								CFG_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	
			 			 				 			 		
	"FLASH Erase,Program" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 					 			 			
	"FLASH Erase,Program,Verify,Secure" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 		
	"Erase,Program,Verify,Secure" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		

	"FLASH Erase,Program,Verify,Secure Plus" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,								
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		UFM_SECURITY ! Secure the UFM,											 			 					 			 		
			 			 		PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		
	
	"FLASH Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  								
								FLASH_ENABLE	! Enable the Flash,
								CHECK_CFG_OTP ! Check the OTP fuses, 
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	"FLASH Secure Plus" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  								
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								UFM_SECURITY ! Secure the UFM,			 			 		
								PROGRAM_SECURITY ! Secure device,
								CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;			 			 		
			 			 		
	"FLASH Program"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash, 
							CHECK_STATUS ! Read the status bit,
							FLASH_FULL_PROGRAM_STATUS	! Program CFG,
							UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FEATURE_PROGRAM_STATUS ! Program Feature Rows,		 			 		
			 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,								
							DISABLE ! Exit the programming mode"	;		
	
	"FLASH Program,skip Erase"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							CHECK_STATUS ! Read the status bit,
							FLASH_FULL_PROGRAM_STATUS	! Program CFG,
							UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FEATURE_PROGRAM_STATUS ! Program Feature Rows,		 			 		
			 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,								
							DISABLE ! Exit the programming mode"	;	
							
	"FLASH Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE	! Verify USERCODE, 
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							CHECK_STATUS ! Read the status bit,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE	! Verify USERCODE, 
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							CHECK_STATUS ! Read the status bit,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							
	
	"FLASH Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			
	"Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_OTP ! Check the OTP fuses,
							CFG_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG and UFM Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"FLASH Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 FLASH_ENABLE	! Enable programming mode, 
						             SVF_FLASH_CHECKSUM_ARRAY,
						             SVF_UFM_CHECKSUM_ARRAY,
								 	 SVF_FEATURE_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";			 						 
	"FLASH Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 IO_STATE ! Program Bscan register,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_ENABLE, 
								 SVF_FLASH_SAVE_ARRAY,
								 SVF_UFM_SAVE_ARRAY,
								 SVF_FEATURE_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	
	"FLASH Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_ENABLE,
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";
	"FLASH Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 
	"FLASH Upload to Static RAM" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";
						
	"FLASH UFM Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
	
	"FLASH Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"FLASH UFM Erase" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"FLASH Display UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SVF_SAVE_ID, 
							FLASH_ENABLE	! Enable the Flash, 
							SVF_UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
	
	"FLASH UFM Secure" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Verify Feature Rows"	=	"	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;	
																			
	"FLASH Refresh" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
							 			 								
	"XFLASH Upload to Static RAM" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";				 			 							 
	"XFLASH Bypass"	=	"SVFINIT 	! Initialize";
	"XFLASH Verify ID" = 	"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"XFLASH Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	"XFLASH Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	; 
	"Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;								
	"XFLASH Display USERCODE"	=	"SVFINIT, 
								     READ_ID	! Check the IDCODE,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 	SVF_SAVE_USERCODE,
								 	DISABLE ! Exit the programming mode";
	"XFLASH Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"XFLASH Enable Only" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode"	;
	"XFLASH Erase DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
	"XFLASH Program DONE bit"	=	"SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"XFLASH Read DONE bit" = 	"SVFINIT, 
								 READ_ID, 
								 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 SVF_SAVE_DONE_BIT,
								 DISABLE ! Exit the programming mode";
	
	"XFLASH Re-Initialize" = "SVF_INIT 	! Initialize,  
							 CHECK_KEYLOCK ! Check the Key Protection fuses,  
							 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
						  	 FLASH_ERASE	! Erase the device, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"XFLASH Clamping IO" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							FLASH_MDR ! Transparent Field Reconfiguration"	;
	
	"XFLASH Program and Clamping IO" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,	
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		IO_STATE ! Program Bscan register,
			 			 		FLASH_MDR ! Transparent Field Reconfiguration"	;
			 			 		
	"XFLASH TransFR" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						REFRESH_FUNCTION ! Refresh"	;
	
	"XFLASH Program and TransFR" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,	
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh"	;	 			 		
	
	
	"XFLASH Program Feature Rows" =    "SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,   
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										FEATURE_ERASE	! Erase the Feature Rows,
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										DISABLE ! Exit the programming mode"	;
											 			 		
	
	"XFLASH Erase,Program,Verify,Feature" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								FLASH_ERASE	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,									
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
			 			 		CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Erase,Program,Verify,Feature and TransFR" = "SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														CHECK_KEYLOCK ! Check the Key Protection fuses,  
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														CHECK_FLASH_OTP ! Check the OTP fuses,
														FLASH_ERASE	! Erase the CFG, 
														CHECK_STATUS ! Read the status bit,
									 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
														UFM_FULL_PROGRAM_STATUS  ! Program the UFM,									
									 			 		PROGRAM_USERCODE	! Program USERCODE,
														CHECK_STATUS ! Read the status bit,
														FLASH_VERIFY	! Verify CFG, 
														UFM_VERIFY          ! Verify the UFM,								
														VERIFY_USERCODE		! Verify USERCODE,
														CHECK_STATUS ! Read the status bit,	
														FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
									 			 		CHECK_STATUS ! Read the status bit,			 			 		
									 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		DISABLE ! Exit the programming mode,
										 			 	REFRESH_FUNCTION ! Refresh"	;	
										 			 	
	"XFLASH Erase,Program,Verify,Feature,Secure and TransFR" = "SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														CHECK_KEYLOCK ! Check the Key Protection fuses,  
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														CHECK_FLASH_OTP ! Check the OTP fuses,
														FLASH_ERASE	! Erase the CFG, 
														CHECK_STATUS ! Read the status bit,
									 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
														UFM_FULL_PROGRAM_STATUS  ! Program the UFM,									
									 			 		PROGRAM_USERCODE	! Program USERCODE,
														CHECK_STATUS ! Read the status bit,
														FLASH_VERIFY	! Verify CFG, 
														UFM_VERIFY          ! Verify the UFM,								
														VERIFY_USERCODE		! Verify USERCODE,
														CHECK_STATUS ! Read the status bit,	
														FEATURE_PROGRAM_STATUS ! Program Feature Rows,	
									 			 		CHECK_STATUS ! Read the status bit,			 			 		
									 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									 			 		PROGRAM_SECURITY ! Secure device,	
									 			 		DISABLE ! Exit the programming mode,
										 			 	REFRESH_FUNCTION ! Refresh"	;
										 			 		 			 		
	"XFLASH Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								CFG_FLASH_ERASE	! Erase the CFG,  
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Erase,Program,Verify,Refresh" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG, 
								UFM_VERIFY          ! Verify the UFM,								
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Upload to SRAM"	;	
			 			 			
	"XFLASH Erase,Program,Verify,Secure" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Erase,Program,Verify,Secure and TransFR" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh"	;
			 			 		
	"XFLASH Erase,Program,Verify,Secure Plus" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,								
								FLASH_ERASE_NO_FEA	! Erase the CFG, 
								CHECK_STATUS ! Read the status bit,
			 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,								
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		UFM_SECURITY ! Secure the UFM,												 			 						 			 		
			 			 		PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode"	;			 			 		
	
	"XFLASH Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Secure Plus" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								UFM_SECURITY ! Secure the UFM,			 			 		
								PROGRAM_SECURITY ! Secure device,
								CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 				 			 		
	"XFLASH Program"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FEATURE_VERIFY_STATUS ! Verify the Feature,								
							FLASH_ERASE_NO_FEA	! Erase the CFG,  
							CHECK_STATUS ! Read the status bit,
							FLASH_FULL_PROGRAM_STATUS	! Program CFG,
							UFM_FULL_PROGRAM_STATUS  ! Program the UFM,						
							PROGRAM_USERCODE	! Program USERCODE, 
							CHECK_STATUS ! Read the status bit,		 
							FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							DISABLE ! Exit the programming mode"	;
									
	"XFLASH Verify Only" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							FEATURE_VERIFY_STATUS ! Verify the Feature,								
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							VERIFY_USERCODE	! Verify USERCODE,							
							CHECK_STATUS ! Read the status bit, 
							DISABLE ! Exit the programming mode"   ;
							
	"XFLASH Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FLASH_ERASE_NO_FEA	! Erase the CFG,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			
	"XFLASH Erase CFG Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_OTP ! Check the OTP fuses,
							CFG_FLASH_ERASE	! Erase the CFG,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XFLASH Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 SVF_SAVE_ID, 
								 	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable programming mode, 
						             SVF_FLASH_CHECKSUM_ARRAY,
						             SVF_UFM_CHECKSUM_ARRAY,
								 	 SVF_FEATURE_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";	
						             				 						 
	"XFLASH Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_TRANSPARENT_ENABLE, 
								 SVF_FLASH_SAVE_ARRAY, 
								 SVF_UFM_SAVE_ARRAY,
								 SVF_FEATURE_SAVE_ARRAY,
								 SVF_SAVE_USERCODE, 
								 DISABLE";
								 
	"XFLASH Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_TRANSPARENT_ENABLE, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";
					 			 	
	"XFLASH Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
						
	"XFLASH UFM Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
	
	"XFLASH Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XFLASH UFM Erase" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Display UFM" = "SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SVF_SAVE_ID, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							SVF_UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
	
	"XFLASH UFM Secure" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 													 			 
	"SRAM Bypass"	=	"SVFINIT 	! Initialize";
	"SRAM Verify ID" = 	"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 
	"SRAM Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	"SRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								SRAM_VERIFY_USERCODE		! Verify USERCODE"	; 
	"SRAM Display USERCODE"	=	"SVFINIT, READ_ID, SRAM_ENABLE, SVF_SAVE_USERCODE, DISABLE";
	"SRAM Disable Only" = "	SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"SRAM Enable Only" = "SVFINIT 	! Initialize, 
						  READ_ID	! Check the IDCODE,
						  IO_STATE ! Program Bscan register,
						  CHECK_KEYLOCK ! Check the Key Protection fuses,  
						  SRAM_ENABLE	! Enable SRAM programming mode"	;
						  
	"SRAM Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SRAM_ENABLE	! Enable SRAM programming mode,
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"SRAM Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_OTP ! Check the OTP fuses,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode,
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
					             						  
	"SRAM Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"SRAM Erase,Program,Verify" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM,
								PROGRAM_CONTROL0	! Program Control Register, 
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;

	"SRAM Program Only" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM,
								PROGRAM_CONTROL0	! Program Control Register, 
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;
								
	"SRAM Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"SRAM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode,  
							SRAM_ERASE	! Erase the SRAM,  
		 			 		DISABLE ! Exit the programming mode"	;
	
	"SRAM Verify Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,  
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							SRAM_VERIFY	! Verify the SRAM, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"Re-Initialize" = "SVFINIT 	! Initialize,
					   CHECK_SRAM_OTP ! Check the OTP fuses,
					   CHECK_KEYLOCK ! Check the Key Protection fuses,  
					   SRAM_ENABLE	! Enable SRAM programming mode, 
					   SRAM_ERASE	! Erase the SRAM, 
					   DISABLE ! Exit the programming mode"	;
					   
	"SRAM Re-Initialize" = "SVFINIT 	! Initialize,
						   CHECK_SRAM_OTP ! Check the OTP fuses,
						   CHECK_KEYLOCK ! Check the Key Protection fuses,  
						   SRAM_ENABLE	! Enable SRAM programming mode, 
						   SRAM_ERASE	! Erase the SRAM, 
						   DISABLE ! Exit the programming mode"	;
						   
	"SRAM Erase DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  							
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"SRAM Program DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  							
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase DONE bit,
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"SRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 SVF_SAVE_DONE_BIT	! Erase the done bit"	;
	
	"SRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 IO_STATE ! Program Bscan register,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode, 
					             SVF_SRAM_SAVE_ARRAY,
					             SVF_SAVE_USERCODE,
		 						 DISABLE";
		 						 
	"SRAM Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 SVF_SAVE_ID, 
								 	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_ENABLE	! Enable programming mode, 
						             SVF_SRAM_CHECKSUM_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";	
		 						 		 						 
	"SRAM Read and Save"	=	"SVFINIT, 
						 		 READ_ID, 
								 SVF_SAVE_ID, 
								 IO_STATE ! Program Bscan register,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SRAM_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
								 
	"SRAM Refresh" = " SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
					             
	"SRAM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SRAM_ENABLE, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";							
	"SRAM Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;	
						
	
	"XSRAM SEI Fast Program" 	= "	SVFINIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									CHECK_SRAM_OTP ! Check the OTP fuses,
									CHECK_KEYLOCK ! Check the Key Protection fuses,  
									SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;
									
	"XSRAM Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode, 
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"XSRAM Fast Program,Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
								
	"XSRAM Erase,Program,Verify" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;					
	
	"XSRAM Erase,Program,Verify,Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
	
	"XSRAM Refresh" = "	SVFINIT 	! Initialize,   
						READ_ID	! Check the IDCODE,
						REFRESH_FUNCTION ! Refresh" ;
								
	"XSRAM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							XSRAM_ERASE	! Erase the SRAM, 
		 			 		DISABLE ! Exit the programming mode"	;
	
	"XSRAM Verify Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							SRAM_VERIFY	! Verify Fuse Map, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 												 			 
	"XSRAM Bypass"	=	"SVFINIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE"	; 
	"XSRAM Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";							
	"XSRAM Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SRAM_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";					 
	"XSRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
									 READ_ID	! Check the IDCODE,
						 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 	 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SVF_SRAM_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
			 						 DISABLE";
	
	"XSRAM Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID,
									 SVF_SAVE_ID,									 
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								     SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SVF_CHECKSUM_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";
			 						 	 			 		
	"XSRAM Verify Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
							VERIFY	! Verify Fuse Map, 
		 			 		SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XSRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE,
			 			 		DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;				             
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE ! Exit the programming mode";	
	"XSRAM Capture Only" = "SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;	
	"XSRAM Display USERCODE"	=	"SVFINIT, READ_ID, SRAM_TRANSPARENT_READ_ENABLE, SVF_SAVE_USERCODE, DISABLE";
											 			 
	"Capture Only" = "SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;			
						
	"Slave SPI Verify ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID";
	
	"Slave SPI Refresh" = "SPIINIT !Initialize,
						   SPIREAD_ID	! Check the IDCODE, 
						   SPIREFRESH ! Refresh";
						   
	"Slave SPI Read Status Register" = "SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
										 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
							             SPI_SAVE_STATUS !Read Status Register,
							             SPIDISABLE";							
	
	"Slave SPI Display USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
						             SPISAVE_USERCODE,
						             SPIDISABLE";
	
	"Slave SPI Verify USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPIFLASH_ENABLE	! Enable the Flash, 
									 SPIVERIFY_USERCODE		! Verify USERCODE,										
						             SPIDISABLE";
						             
	"Slave SPI Calculate Checksum"	=	"SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
							 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										 SPIFLASH_ENABLE	! Enable the Flash, 
							             SPIFLASH_SAVE_ARRAY,
							             SPIUFM_SAVE_ARRAY,
							             SPIFEATURE_SAVE_ARRAY,
							             SPISAVE_USERCODE,
				 						 SPIDISABLE";			 						 
	"Slave SPI Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
						 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									 SPIFLASH_ENABLE	! Enable the Flash, 
						             SPIFLASH_SAVE_ARRAY,
						             SPIUFM_SAVE_ARRAY,
						             SPIFEATURE_SAVE_ARRAY,
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";	
	
	"Slave SPI RAM Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 	
									 SPISRAM_SAVE_CONTROL0,		
									 SPISRAM_SAVE_ARRAY,				 			 							
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";
			 						 							 						             
	"Slave SPI Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses,
										SPIDIRECT_FLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
	
	
	"Slave SPI CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_OTP ! Check the OTP fuses,
										SPICFG_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
					 			 		
	"Slave SPI Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_FLASH_OTP ! Check the OTP fuses,
											SPIDIRECT_FLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,	
											SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											SPICHECK_STATUS ! Read the status bit,		 			 		
						 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIDISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
												SPIFLASH_ENABLE	! Enable the Flash, 
												SPICHECK_FLASH_OTP ! Check the OTP fuses,
												SPIDIRECT_FLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												SPICHECK_STATUS ! Read the status bit,		 			 		
							 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 																			 			 					 			 					 			 			
	"Slave SPI Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,
								SPICHECK_STATUS ! Read the status bit,
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPICHECK_FLASH_OTP ! Check the OTP fuses,
								SPIDIRECT_FLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 		
	"Slave SPI Background Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
								SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
								SPIFLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 										 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,								
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Program Feature Rows" =    "SPIINIT 	! Initialize, 
													  SPIREAD_ID	! Check the IDCODE, 
													  SPICHECK_FR_OTP ! Check the OTP fuses,
													  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
													  SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
													  SPIFEATURE_ERASE	! Erase the Feature Rows,
													  SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
													  SPICHECK_STATUS ! Read the status bit,	
													  SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
									
	"Slave SPI Background Erase,Program,Verify,Feature" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses,
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Erase,Program" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 						 			 									
	"Slave SPI Background Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	
	"Slave SPI Background CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_OTP ! Check the OTP fuses,
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPICFG_ERASE	! Erase the CFG,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 		
	"Slave SPI Background Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
											SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
											SPIFLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Background Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses,
												SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;	 	
	
	"Slave SPI Display UFM" = "SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIUFM_SAVE_ARRAY, 
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI UFM Program,Verify" = "SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPICHECK_UFM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPIUFM_ERASE	! Erase the UFM, 
									SPICHECK_STATUS ! Read the status bit,
				 			 		SPIUFM_PROGRAM_STATUS  ! Program the UFM,	
				 			 		SPICHECK_STATUS ! Read the status bit,
									SPIUFM_VERIFY          ! Verify the UFM,
									SPICHECK_STATUS ! Read the status bit,
									SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Verify UFM" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,									   
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_VERIFY          ! Verify the UFM,
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
		 			 		
	"Slave SPI UFM Erase" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_UFM_OTP ! Check the OTP fuses,
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_ERASE	! Erase the UFM, 
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
		 			 																	 			 				 							 			 		
	"Slave SPI Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
															
	"Slave SPI Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI Background SEI Fast Program" 	= "	SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,	
									SPICHECK_SRAM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPI_SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPIBURST_PROGRAM	! Program Fuse Map,	
									SPICHECK_STATUS ! Read the status bit,	
									SPIDISABLE ! Exit the programming mode"	;
														
	"Slave SPI RAM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,  
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									SPISRAM_VERIFY	! Verify Fuse Map, 
									SPIVERIFY_USERCODE		! Verify USERCODE, 
				 			 		SPIDISABLE ! Exit the programming mode"	;
				 			 		
				 			 		
	"Slave SPI Check Protect Fuses" =  "SPIINIT 	! Initialize, 
									   SPIREAD_ID	! Check the IDCODE,
									   SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	"Slave SPI Fast Configuration with Password" = "SPIINIT 	! Initialize,   
													SPIREAD_ID	! Check the IDCODE,
													SPICHECK_SRAM_OTP ! Check the OTP fuses,
													SPISRAM_ENABLE	! Enable SRAM programming mode, 
													SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													SPISRAM_ERASE	! Erase the SRAM, 
													SPIBURST_PROGRAM	! Program Fuse Map,
													SPIVERIFY_USERCODE		! Verify USERCODE,
													SPIDISABLE ! Exit the programming mode"	;
																		   				 			 
	"Slave SPI Erase,Program,Verify with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;					 			 						 			 		
													   
	
	"Slave SPI EPVS with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIPROGRAM_SECURITY ! Secure device,									 			 		
			 			 				SPIDISABLE ! Exit the programming mode"	;
			 			 		
	"Slave SPI Erase Only with Password"	=	"SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE,
												SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
												SPIFLASH_ENABLE	! Enable the programming mode, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
												SPIDISABLE ! Exit the programming mode"	;
														
	"Slave SPI Background EPV with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Background EPVS with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 						 			 					 				 			 					 			 															  
	
	"Slave SPI Background Erase with Password"	=	"SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE,
													SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
													SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
													SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
													SPIFLASH_ERASE	! Erase the device, 
													SPICHECK_STATUS ! Read the status bit,
								 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Verify Only with Password" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  													
											SPIFLASH_VERIFY	! Verify the Flash, 
											SPIUFM_VERIFY          ! Verify the UFM,							
											SPIVERIFY_USERCODE	! Verify USERCODE, 
											SPICHECK_STATUS ! Read the status bit, 
											SPIVERIFY_DONE_BIT ! Verify Done Bit,
											SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
																					
		
	"Slave SPI Program Password Key" = "SPIINIT 	! Initialize, 
									  SPIREAD_ID	! Check the IDCODE,
									  SPICHECK_FR_OTP ! Check the OTP fuses,
									  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									  SPIFLASH_ENABLE	! Enable the programming mode,
									  SPIPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  SPIDISABLE ! Exit the programming mode" ;	
	
	"Slave SPI Program Password Key with Lock" = "SPIINIT 	! Initialize, 
												  SPIREAD_ID	! Check the IDCODE,
												  SPICHECK_FR_OTP ! Check the OTP fuses,
												  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
												  SPIFLASH_ENABLE	! Enable the programming mode,
												  SPIPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
												  SPIDISABLE ! Exit the programming mode" ;		
												  
	"Slave SPI Read Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses,
										SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
					 			 		
	
	"Slave SPI Erase Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_FR_OTP ! Check the OTP fuses,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 									
										SPIFLASH_ENABLE	! Enable the programming mode, 	
										SPIFEATURE_ERASE	! Erase the Feature row, 
										SPIFLASH_ERASE	! Erase the CFG, 
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	
	"Slave SPI Check Feature Row"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses"	;
											
	"I2C Verify ID" = "	I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE";
	"I2C Display ID" = "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE,
						I2CSAVE_ID";						
	
	
	"I2C Program Feature Rows" =    "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_FR_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFEATURE_ENABLE	! Enable the Flash, 
									I2CFEATURE_ERASE	! Erase the Feature Rows,
									I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
									I2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	
	"I2C Fast Program" = "I2CINIT 	! Initialize,   
						I2CREAD_ID	! Check the IDCODE,
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 
						I2CSRAM_ERASE	! Erase the SRAM, 
						I2CBURST_PROGRAM	! Program Fuse Map,
						I2CVERIFY_USERCODE		! Verify USERCODE,
						I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Fast Configuration" = "I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_ENABLE	! Enable SRAM programming mode, 
								I2CSRAM_ERASE	! Erase the SRAM, 
								I2CBURST_PROGRAM	! Program Fuse Map,
								I2CVERIFY_USERCODE		! Verify USERCODE,
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Program" = "I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									I2CSRAM_ERASE	! Erase the SRAM, 
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Configuration" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,	
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,		
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
																						
	"I2C Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure Plus" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CUFM_SECURITY ! Secure the UFM,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
						 			 					 			 					 			 		
	"I2C Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																																				
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,								 
									I2CCHECK_STATUS ! Read the status bit,	
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Program" =   "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE, 
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CFLASH_ENABLE	! Enable the Flash, 
						I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
						I2CFLASH_ERASE	! Erase the Flash,
						I2CCHECK_STATUS ! Read the status bit,
	 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
	 			 		I2CPROGRAM_USERCODE	! Program USERCODE,
	 			 		I2CUFM_PROGRAM_STATUS  ! Program the UFM,							
						I2CCHECK_STATUS ! Read the status bit,
						I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
	 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"I2C Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Full Erase"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CDISABLE ! Exit the programming mode"	;
			 			 						 			 								
	"I2C Background Program Feature Rows" =    "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
												I2CFEATURE_ERASE	! Erase the Feature Rows,
												I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												I2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"I2C Background Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CCHECK_STATUS ! Read the status bit,	
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
						 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"I2C Background Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"I2C Background Program" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,								
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"I2C Background Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,  
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"I2C Background Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,	
									I2CCHECK_STATUS ! Read the status bit,							 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"I2C Background Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
							I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,							
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"I2C Background Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	
	"I2C Check Feature Row"	=	"I2CINIT 	! Initialize, 
								 I2CREAD_ID	! Check the IDCODE, 
								 I2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;
	
	"I2C Check Protect Fuses" =  "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;	
	
	"I2C Erase Feature Row with Password Key"	=	"I2CINIT 	! Initialize, 
													 I2CREAD_ID	! Check the IDCODE, 
													 SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
													 I2CFLASH_ENABLE	! Enable the Flash, 	
													 SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													 I2CFEATURE_ERASE	! Erase the Feature row, 
													 I2CFLASH_ERASE	! Erase the Flash,
													 I2CCHECK_STATUS ! Read the status bit,
													 I2CDISABLE ! Exit the programming mode"	;
																																																														
	"I2C Program Password Key" = "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  I2CDISABLE ! Exit the programming mode" ;
							  
	"I2C Program Password Key with Lock" = "I2CINIT 	! Initialize, 
								  			I2CREAD_ID	! Check the IDCODE, 
								  			I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			I2CFLASH_ENABLE	! Enable the Flash, 
											I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode" ;							  	
	
	"I2C EPV with Password Key Option" = 	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	I2CDISABLE ! Exit the programming mode"	;
							 			 		
	"I2C EPVS with Password Key Option" = "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CPROGRAM_SECURITY ! Secure device,							 			 	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode"	;
	
	"I2C EPV with my_ASSP, Password Key Option" = 	"I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													I2CFLASH_ENABLE	! Enable the Flash, 
													I2CFLASH_ERASE	! Erase the Flash,
													I2CCHECK_STATUS ! Read the status bit,
								 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
													I2CPROGRAM_USERCODE	! Program USERCODE,
													I2CCHECK_STATUS ! Read the status bit,
													I2CVERIFY_USERCODE		! Verify USERCODE,																																				
													I2CFLASH_VERIFY	! Verify CFG,
													I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													I2CUFM_VERIFY          ! Verify the UFM,
													I2CCHECK_STATUS ! Read the status bit,									 
													I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													I2CFEATURE_ERASE	! Erase the Feature Rows,
													I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													I2CDISABLE ! Exit the programming mode"	;
																				  							 
	"I2C Erase,Program,Verify with Password" =   "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
												I2CFLASH_ENABLE	! Enable the Flash, 
												SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												I2CFLASH_ERASE	! Erase the Flash,
												I2CCHECK_STATUS ! Read the status bit,
							 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
												I2CPROGRAM_USERCODE	! Program USERCODE,
												I2CCHECK_STATUS ! Read the status bit,
												I2CVERIFY_USERCODE		! Verify USERCODE,																																				
												I2CFLASH_VERIFY	! Verify CFG,
												I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												I2CUFM_VERIFY          ! Verify the UFM,								 
												I2CCHECK_STATUS ! Read the status bit,	
												I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Fast Configuration with Password" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CSRAM_ENABLE	! Enable SRAM programming mode, 
											SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C Verify Only with Password" = "	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_VERIFY	! Verify the Flash, 
										I2CUFM_VERIFY          ! Verify the UFM,							
										I2CVERIFY_USERCODE	! Verify USERCODE, 
										I2CCHECK_STATUS ! Read the status bit, 
										I2CVERIFY_DONE_BIT ! Verify Done Bit,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C Erase Only with Password" =	"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_ERASE	! Erase the Flash,
										I2CCHECK_STATUS ! Read the status bit,
					 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Refresh"	=	"I2CINIT 	! Initialize, 
						 I2CREAD_ID	! Check the IDCODE,	
						 I2CREFRESH ! Refresh";	
	
	
	"PTM Bypass"	=	"SVFINIT 	! Initialize,
						FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";
	
	"PTM Background Bypass"	=	"SVFINIT 	! Initialize";
								 		
	"PTM Verify ID" = 	"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE,
						 FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode"; 
	
	"PTM Background Verify ID" = 	"SVFINIT 	! Initialize, 
									 READ_ID ! Check the IDCODE";
						 					 
	"PTM Display ID" = "SVFINIT, SAVE_ID";	
	"PTM Background Display ID" = "SVFINIT, SAVE_ID";	
	
	"PTM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Verify USERCODE"	=	"SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											VERIFY_USERCODE		! Verify USERCODE,
											DISABLE ! Exit the programming mode"	;
												             								 								
	"PTM Display USERCODE"	=	"SVFINIT, 
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
								 FLASH_ENABLE	! Enable the CFG, 
								 SAVE_USERCODE,
								 DISABLE_REFRESH ! Exit the programming mode";
								 
	"PTM Background Display USERCODE"	=	"SVFINIT, 
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											 SAVE_USERCODE,
											 DISABLE ! Exit the programming mode";
								 								 
	"PTM Disable Only" = "DISABLE ! Exit the programming mode"	;	
	
	"PTM Background Program Feature Rows"  =    "SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												CHECK_KEYLOCK ! Check the Key Protection fuses,   
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												FEATURE_ERASE	! Erase the Feature Rows,
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												DISABLE ! Exit the programming mode"	;
												 			 		  				 
	"PTM Erase,Program,Verify" = "SVF_INIT,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_STATUS ! Read the status bit,
								FLASH_FULL_PROGRAM_STATUS	! Program CFG,
								UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								FEATURE_PROGRAM_STATUS ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,	
								FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
											FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
						 			 		DISABLE ! Exit the programming mode";
	
	"PTM Background Erase,Program,Verify,Refresh" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
											FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
						 			 		DISABLE ! Exit the programming mode,
			 			 					REFRESH_FUNCTION ! Refresh";
	
	"PTM Background Program,Verify and TransFR" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
											FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,		 			 		
						 			 		DISABLE ! Exit the programming mode,
			 			 					FLASH_MDR ! Transparent Field Reconfiguration";
			 			 																	 			 				 			 		
	"PTM Erase,Program,Verify,Secure" = "SVF_INIT,
										FLASH_ENABLE	! Enable the Flash, 
										CHECK_STATUS ! Read the status bit,
					 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
										UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,			 			 		
					 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,									 			 		
					 			 		DISABLE ! Exit the programming mode,
					 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify,Secure" = "SVF_INIT,
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
										CHECK_STATUS ! Read the status bit,
					 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
										UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,									 			 		
					 			 		DISABLE ! Exit the programming mode";
					 			 				 			 					 			 					 			 		
	
	"PTM Erase,Program,Verify,Secure Plus" = "SVF_INIT,
											FLASH_ENABLE	! Enable the Flash, 
											CHECK_STATUS ! Read the status bit,
						 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
											UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,								
											CHECK_STATUS ! Read the status bit,	
											FEATURE_PROGRAM_STATUS ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		UFM_SECURITY ! Secure the UFM,																	 			 					 			 		
						 			 		PROGRAM_SECURITY ! Secure device,
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify,Secure Plus" = "SVF_INIT,
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
														CHECK_STATUS ! Read the status bit,
									 			 		FLASH_FULL_PROGRAM_STATUS	! Program CFG,
														UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
														PROGRAM_USERCODE	! Program USERCODE,
														CHECK_STATUS ! Read the status bit,
														FLASH_VERIFY	! Verify CFG,
														UFM_VERIFY          ! Verify the UFM,								 
														VERIFY_USERCODE		! Verify USERCODE,								
														CHECK_STATUS ! Read the status bit,	
														FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		UFM_SECURITY ! Secure the UFM,																	 			 					 			 		
									 			 		PROGRAM_SECURITY ! Secure device,
									 			 		DISABLE ! Exit the programming mode";
						 			 				 			 					 			 		 
	"PTM Program"	=	"	SVF_INIT,
							FLASH_ENABLE	! Enable the Flash,
							CHECK_STATUS ! Read the status bit,
							FLASH_FULL_PROGRAM_STATUS	! Program CFG,
							UFM_FULL_PROGRAM_STATUS  ! Program the UFM,						
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							FEATURE_PROGRAM_STATUS ! Program Feature Rows,
							CHECK_STATUS ! Read the status bit,			 			 		
			 			 	FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 	DISABLE ! Exit the programming mode";
	
	"PTM Background Program"	=	"SVF_INIT,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
									CHECK_STATUS ! Read the status bit,
									FLASH_FULL_PROGRAM_STATUS	! Program CFG,
									UFM_FULL_PROGRAM_STATUS  ! Program the UFM,							
									PROGRAM_USERCODE	! Program USERCODE,
									CHECK_STATUS ! Read the status bit,	
									FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 	DISABLE ! Exit the programming mode";
			 			 							
															
	"PTM Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify CFG, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE		! Verify USERCODE,
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY_STATUS ! Verify Feature Rows,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE_REFRESH ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit,
							FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";
	
	"PTM Background Verify Only" =	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,   
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
										FEATURE_VERIFY_STATUS ! Verify Feature Rows,										
										FLASH_VERIFY	! Verify CFG, 
										UFM_VERIFY          ! Verify the UFM,							
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit, 
										VERIFY_DONE_BIT ! Verify Done Bit,
										DISABLE ! Exit the programming mode";
							
								 			 			
	"PTM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_ENABLE	! Enable the Flash,
							DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";
	
	"PTM Background Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							FEATURE_VERIFY_STATUS ! Verify Feature Rows, 
							FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";
		 			 																 			 		
	
	"PTM Calculate Checksum"	=	"SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,   
									 FLASH_ENABLE	! Enable the Flash, 
						             FLASH_SAVE_ARRAY,
						             UFM_SAVE_ARRAY,
						             FEATURE_SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE_REFRESH";	
			 						 
	"PTM Background Calculate Checksum"	=	"SVFINIT 	! Initialize, 
											 READ_ID	! Check the IDCODE,
											 CHECK_KEYLOCK ! Check the Key Protection fuses,   
											 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								             FLASH_SAVE_ARRAY,
								             UFM_SAVE_ARRAY,
								             FEATURE_SAVE_ARRAY,
								             SAVE_USERCODE,
					 						 DISABLE";	
			 						 			 						 		 						 
	"PTM Read and Save"	=	"SVFINIT 	! Initialize, 
							 READ_ID	! Check the IDCODE,
							 CHECK_KEYLOCK ! Check the Key Protection fuses,   
							 FLASH_ENABLE, 
							 FLASH_SAVE_ARRAY, 								 
							 UFM_SAVE_ARRAY,
							 FEATURE_SAVE_ARRAY,
							 SAVE_USERCODE, 
							 DISABLE_REFRESH";		 			 								 
	
	"PTM Background Read and Save"	=	"SVFINIT 	! Initialize, 
										 READ_ID	! Check the IDCODE,
										 CHECK_KEYLOCK ! Check the Key Protection fuses,   
										 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										 FLASH_SAVE_ARRAY, 								 
										 UFM_SAVE_ARRAY,
										 FEATURE_SAVE_ARRAY,
										 SAVE_USERCODE, 
										 DISABLE";	
							 
	"PTM UFM Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,   												
								FLASH_ENABLE	! Enable the Flash, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background UFM Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,   												
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		UFM_FULL_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
								
	"PTM Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE_REFRESH ! Exit the programming mode"	;
		 			 		
	"PTM Background Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 				 			 		
	"PTM UFM Erase" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						CHECK_KEYLOCK ! Check the Key Protection fuses,   												
						FLASH_ENABLE	! Enable the Flash, 
						UFM_ERASE	! Erase the UFM, 
						CHECK_STATUS ! Read the status bit,
	 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background UFM Erase" = "	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									CHECK_KEYLOCK ! Check the Key Protection fuses,   												
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,   
									UFM_ERASE	! Erase the UFM, 
									CHECK_STATUS ! Read the status bit,
				 			 		DISABLE ! Exit the programming mode"	;
	 			 				 			 		
	"PTM Display UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SAVE_ID, 
							FLASH_ENABLE	! Enable the Flash, 
							UFM_SAVE_ARRAY, 
							DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Display UFM" = "	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										SAVE_ID, 
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,  
										UFM_SAVE_ARRAY, 
										DISABLE ! Exit the programming mode"	;
													
	"PTM Secure Device" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_ENABLE	! Enable the Flash, 
							PROGRAM_SECURITY ! Secure device,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background Secure Device" = "	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										CHECK_KEYLOCK ! Check the Key Protection fuses,   												
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										PROGRAM_SECURITY ! Secure device,
					 			 		CHECK_STATUS ! Read the status bit,
					 			 		DISABLE ! Exit the programming mode"	;
		 			 			 			 		
	"PTM Secure Plus" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   												
							FLASH_ENABLE	! Enable the Flash, 
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background Secure Plus" = "	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										CHECK_KEYLOCK ! Check the Key Protection fuses,   												
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										UFM_SECURITY ! Secure the UFM,			 			 		
										PROGRAM_SECURITY ! Secure device,
										CHECK_STATUS ! Read the status bit,
					 			 		DISABLE ! Exit the programming mode"	;
		 			 				 			 		
	"PTM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 FLASH_ENABLE,
					 			 SAVE_STATUS,
					 			 DISABLE_REFRESH";
	"PTM Background Read Status Register" = "SVFINIT ! Initialize,
								 			 READ_ID	! Check the IDCODE,
								 			 SAVE_ID,
								 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								 			 SAVE_STATUS,
								 			 DISABLE";
					 			 					 			 									 												 						 						 				 			 					 			 
	"PTM Capture Only" = "SVFINIT 	! Initialize,
						  READ_ID	! Check the IDCODE,
						  IO_STATE ! Capture Bscan register"	;		
						  			 			 							 
	"PTM Upload to Static RAM" = "SVFINIT !Initialize,
								  READ_ID !Check the IDCODE,
								  UPLOAD_FUNCTION ! Uploaded";
						
	"PTM Refresh" = " 	SVF_INIT 	! Initialize, 
						REFRESH_FUNCTION ! Refresh";
	
	"PTM Background Refresh" = " 	SVF_INIT 	! Initialize, 
									REFRESH_FUNCTION ! Refresh";
						
						
	"ASC Erase,Program,Verify" =	"ASC_SVF_INIT 	! Initialize, 
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	
	"ASC Background Erase,Program,Verify" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize,  
											 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
											 ASCREAD_ID_SVF	! Check the IDCODE,	
											 ASC_ENABLE	! Enable the ASC, 
											 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
											 ASCCHECK_STATUS ! Read the status,
						 			 		 ASC_PROGRAM_STATUS	! Program CFG,
											 ASCPROGRAM_USERCODE	! Program USERCODE,
											 ASCCHECK_STATUS ! Read the status bit,
											 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
											 ASC_VERIFY	! Verify ASC CFG,
											 ASCCHECK_STATUS ! Read the status bit,	
											 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
											 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
									 
	
	"ASC Erase,Program,Verify,I2CSA" =	"ASC_SVF_INIT 	! Initialize, 
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 ASC_VERIFY	! Verify ASC CFG,
									 ASCCHECK_STATUS ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_ERASE_I2CSA ! Erase the I2CSA,
									 ASC_PROGRAM_I2CSA ! Program I2CSA,
									 ASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
									 
	
	"ASC Background Erase,Program,Verify,I2CSA" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
													 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
													 ASCREAD_ID_SVF	! Check the IDCODE,	
													 ASC_ENABLE	! Enable the ASC, 
													 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
													 ASCCHECK_STATUS ! Read the status,
								 			 		 ASC_PROGRAM_STATUS	! Program CFG,
													 ASCPROGRAM_USERCODE	! Program USERCODE,
													 ASCCHECK_STATUS ! Read the status bit,
													 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
													 ASC_VERIFY	! Verify ASC CFG,
													 ASCCHECK_STATUS ! Read the status bit,	
													 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
													 ASC_ERASE_I2CSA ! Erase the I2CSA,
													 ASC_PROGRAM_I2CSA ! Program I2CSA,
													 ASC_EXIT_USERMODE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
										 								 
	"ASC I2CSA Program" =	"ASC_SVF_INIT 	! Initialize, 
							 ASCREAD_ID_SVF	! Check the IDCODE,	
							 ASC_ENABLE_SVF	! Enable the ASC, 
							 ASC_ERASE_I2CSA ! Erase the I2CSA,
							 ASC_PROGRAM_I2CSA ! Program I2CSA,
							 ASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
	
	"ASC Background I2CSA Program" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
										 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
										 ASCREAD_ID_SVF	! Check the IDCODE,	
										 ASC_ENABLE	! Enable the ASC, 
										 ASC_ERASE_I2CSA ! Erase the I2CSA,
										 ASC_PROGRAM_I2CSA ! Program I2CSA,
										 ASC_EXIT_USERMODE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
									 
	"ASC I2CSA Erase Only" =	"ASC_SVF_INIT 	! Initialize, 
								 ASCREAD_ID_SVF	! Check the IDCODE,	
								 ASC_ENABLE_SVF	! Enable the ASC, 
								 ASC_ERASE_I2CSA ! Erase the I2CSA,
								 ASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
	
	"ASC Background I2CSA Erase Only" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
										 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
										 ASCREAD_ID_SVF	! Check the IDCODE,	
										 ASC_ENABLE	! Enable the ASC, 
										 ASC_ERASE_I2CSA ! Erase the I2CSA,
										 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
							 								 			 			 		 	
	"ASC Program" =	 	"ASC_SVF_INIT 	! Initialize, 
						 ASCREAD_ID_SVF	! Check the IDCODE,	
						 ASC_ENABLE_SVF	! Enable the ASC, 
						 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
						 ASCCHECK_STATUS ! Read the status,
	 			 		 ASC_PROGRAM_STATUS	! Program CFG,
						 ASCPROGRAM_USERCODE	! Program USERCODE,
						 ASCCHECK_STATUS ! Read the status bit,
						 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
						 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	 
	 "ASC Background Program" =	 	"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS ! Read the status,
				 			 		 ASC_PROGRAM_STATUS	! Program CFG,
									 ASCPROGRAM_USERCODE	! Program USERCODE,
									 ASCCHECK_STATUS ! Read the status bit,
									 ASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
						 			 		 
	"ASC Erase Only" = "ASC_SVF_INIT 	! Initialize, 
						 ASCREAD_ID_SVF	! Check the IDCODE,	
						 ASC_ENABLE_SVF	! Enable the ASC, 
						 ASC_ERASE_BECFG	! Erase the ASC CFG,									 
						 ASCCHECK_STATUS ! Read the status,
	 			 		 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	
	"ASC Background Erase Only" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
								   ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								   ASCREAD_ID_SVF	! Check the IDCODE,	
								   ASC_ENABLE	! Enable the ASC, 
								   ASC_ERASE_BECFG	! Erase the ASC CFG,									 
								   ASCCHECK_STATUS ! Read the status,
			 			 		   ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"ASC Verify Only" = "ASC_SVF_INIT 	! Initialize, 
							 ASCREAD_ID_SVF	! Check the IDCODE,	
							 ASC_ENABLE_SVF	! Enable the ASC, 
							 ASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 ASC_VERIFY	! Verify ASC CFG,
							 ASCCHECK_STATUS ! Read the status bit,	
							 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
							 
	"ASC Background Verify Only" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
								    ASC_CHECK_MUTEX_SVF ! Check the Mutex,
									ASCREAD_ID_SVF	! Check the IDCODE,	
								    ASC_ENABLE	! Enable the ASC, 
									ASCVERIFY_USERCODE		! Verify USERCODE,																																				
									ASC_VERIFY	! Verify ASC CFG,
									ASCCHECK_STATUS ! Read the status bit,	
									ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
							 							 
	"ASC Read Status Register" = "ASC_SVF_INIT 	! Initialize, 
							     ASCREAD_ID_SVF	! Check the IDCODE,	
							     ASC_SAVE_STATUS,
								 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read Status Register" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
								    		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
										     ASCREAD_ID_SVF	! Check the IDCODE,	
								    		 ASC_SAVE_STATUS,
											 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
									 									 
	"ASC Verify ID" = "ASC_SVF_INIT 	! Initialize, 
					     ASCREAD_ID_SVF	! Check the IDCODE";
					     
	"ASC Background Verify ID" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
								  ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
								  ASCREAD_ID_SVF	! Check the IDCODE,	
								  ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
					     
					     
	"ASC Display ID" = "ASC_SVF_INIT 	! Initialize, 
					    ASCSAVE_ID";					     									 							 								 							 			 																													  
	
	"ASC Background Display ID" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
					               ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
								   ASCSAVE_ID,
					               ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
					     
	"ASC Refresh" = 		"ASC_SVF_INIT 	! Initialize, 
							 ASCREAD_ID_SVF	! Check the IDCODE,	
							 ASC_REFRESH	! Refresh"	;
	
	"ASC Background Refresh" = 		"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
							 		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
							 		 ASCREAD_ID_SVF	! Check the IDCODE,	
							 		 ASC_REFRESH	! Refresh,
							 		 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
							 						 
	"ASC Read Shadow Registers" = "ASC_SVF_INIT 	! Initialize, 
								   ASCREAD_ID_SVF	! Check the IDCODE,	
								   ASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;
	
	"ASC Background Read Shadow Registers" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 		  ASC_CHECK_MUTEX_SVF ! Check the Mutex,		
											  ASCREAD_ID_SVF	! Check the IDCODE,	
									 		  ASC_READ_SHADOW_REGISTERS	! Read ASC Shadow,
											  ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
								   
	"ASC Read FaultLog Registers" = "ASC_SVF_INIT 	! Initialize, 
									     ASCREAD_ID_SVF	! Check the IDCODE,	
									     ASC_ENABLE_SVF	! Enable the ASC, 
										 ASC_SAVE_FAULTLOG_REGISTERS,
										 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Registers" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 		    ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
											    ASCREAD_ID_SVF	! Check the IDCODE,	
									 		    ASC_ENABLE	! Enable the ASC, 
												ASC_SAVE_FAULTLOG_REGISTERS,
												ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
										 
	"ASC Read FaultLog Memory" = "ASC_SVF_INIT 	! Initialize, 
								     ASCREAD_ID_SVF	! Check the IDCODE,
								     ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_SAVE_FAULTLOG_MEMORY,
									 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Memory" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
										     ASCREAD_ID_SVF	! Check the IDCODE,	
									 		 ASC_ENABLE	! Enable the ASC, 
											 ASC_SAVE_FAULTLOG_MEMORY,
											 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
	
	"ASC FaultLog Erase Only" = "ASC_SVF_INIT 	! Initialize, 
							     ASCREAD_ID_SVF	! Check the IDCODE,
							     ASC_ENABLE_SVF	! Enable the ASC, 
								 ASC_ERASE_FAULTLOG_MEMORY,
								 ASC_EXIT_USERMODE ! Exit the programming mode";
								 								 
	"ASC Read and Save" = "ASC_SVF_INIT 	! Initialize, 
						     ASCREAD_ID_SVF	! Check the IDCODE,
						     ASC_ENABLE_SVF	! Enable the ASC, 
							 ASC_SAVE	! Read ASC CFG,
							 ASCSAVE_USERCODE		! Read USERCODE,																																											 
							 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read and Save" = "ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
								     ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE	! Enable the ASC, 
									 ASC_SAVE	! Read ASC CFG,
									 ASCSAVE_USERCODE		! Read USERCODE,																																											 
									 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";
							 		 			 								 						 			 								 			 		
	
	"ASC Calculate Data CRC"	=	"ASC_SVF_INIT 	! Initialize, 
						     		 ASCREAD_ID_SVF	! Check the IDCODE,	
						     		 ASC_ENABLE_SVF	! Enable the ASC, 
								     ASC_SAVE,
								     ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Calculate Data CRC"	=	"ASC_BACKGROUND_SVF_INIT 	! Initialize, 
									 		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								     		 ASCREAD_ID_SVF	! Check the IDCODE,	
									 		 ASC_ENABLE	! Enable the ASC, 
										     ASC_SAVE,
										     ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode";

	
	
	"JTAGI2C Re-Initialize" = "JTAGI2CINIT_SVF 	! Initialize,  
						  	 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							 JTAGI2CFLASH_ERASE	! Erase the Flash,
							 JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		 JTAGI2CDISABLE ! Exit the programming mode"	;
		 			 		 
	"JTAGI2C Verify ID" = "JTAGI2CINIT_SVF 	! Initialize, 
						   JTAGI2CREAD_ID	! Check the IDCODE";
	"JTAGI2C Display ID" = "JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSAVE_ID";						
	
	"JTAGI2C Program Feature Rows" =    "JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 			JTAGI2CFEATURE_ENABLE	! Enable the Flash, 
										JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
										JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	"JTAGI2C Read Feature Rows"	=	"JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 		 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CFEATURE_SAVE_ARRAY	! Read the Feature row, 
									 JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C Display USERCODE"	=	"JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Read Status Register" = "JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
					 			 	 JTAGI2C_SAVE_STATUS,
					 			 	 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Fast Configuration" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C Background Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Fast Configuration" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C SEI Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background SEI Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  				 			 								
	"JTAGI2C Erase,Program,Verify,Feature" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 					JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Feature,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 					JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C Erase,Program,Verify,Feature,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 					JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,	
												JTAGI2CUFM_SECURITY ! Secure the UFM,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
							 			 					 			 					 			 		
	"JTAGI2C Erase,Program,Verify" =   "JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
										JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
										JTAGI2CFLASH_VERIFY	! Verify CFG,
										JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
										JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
										JTAGI2CCHECK_STATUS ! Read the status bit,	
										JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program" =   "JTAGI2CINIT_SVF 	! Initialize, 
						JTAGI2CREAD_ID	! Check the IDCODE, 
						JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
						JTAGI2CFLASH_ENABLE	! Enable the Flash, 
						JTAGI2CFLASH_ERASE	! Erase the Flash,
						JTAGI2CCHECK_STATUS ! Read the status bit,
	 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
	 			 		JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
	 			 		JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,							
						JTAGI2CCHECK_STATUS ! Read the status bit,
						JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
	 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 					JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CFLASH_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,								 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,
							 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 						JTAGI2CFLASH_ENABLE	! Enable the Flash, 
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,								 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
													JTAGI2CUFM_SECURITY ! Secure the UFM,	
													JTAGI2CPROGRAM_SECURITY ! Secure device,
								 			 		JTAGI2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"JTAGI2C Verify Only" = "JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							JTAGI2CFLASH_ENABLE	! Enable the Flash,
							JTAGI2CFLASH_VERIFY	! Verify the Flash,
							JTAGI2CUFM_VERIFY          ! Verify the UFM,
							JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
							JTAGI2CCHECK_STATUS ! Read the status bit, 
							JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
							JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								JTAGI2CFLASH_ERASE	! Erase the Flash,
								JTAGI2CCHECK_STATUS ! Read the status bit,
			 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Full Erase"	=	"JTAGI2CINIT_SVF 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								JTAGI2CFLASH_ERASE	! Erase the Flash,
								JTAGI2CCHECK_STATUS ! Read the status bit,
			 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
			 			 		
	"JTAGI2C Recovery Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
					 			 				 			 						 			 								
	"JTAGI2C Background Program Feature Rows" =    "JTAGI2CINIT_SVF 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 						JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
													JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
													JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
													JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"JTAGI2C Background Erase,Program,Verify,Feature" =   "JTAGI2CINIT_SVF 	! Initialize, 
															JTAGI2CREAD_ID	! Check the IDCODE, 
															JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 								JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
															JTAGI2CFLASH_ERASE	! Erase the Flash,
															JTAGI2CCHECK_STATUS ! Read the status bit,
										 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
															JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
															JTAGI2CCHECK_STATUS ! Read the status bit,
															JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
															JTAGI2CFLASH_VERIFY	! Verify CFG,
															JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
															JTAGI2CUFM_VERIFY          ! Verify the UFM,
															JTAGI2CCHECK_STATUS ! Read the status bit,									 
															JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
															JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
															JTAGI2CCHECK_STATUS ! Read the status bit,	
															JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
										 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"JTAGI2C Background Erase,Program,Verify" =   "JTAGI2CINIT_SVF 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 						JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,								 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
								 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Program" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 		JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									JTAGI2CFLASH_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
									JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,								
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"JTAGI2C Background Erase,Program,Verify,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 							JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,  
														JTAGI2CFLASH_ERASE	! Erase the Flash,
														JTAGI2CCHECK_STATUS ! Read the status bit,
									 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
														JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
														JTAGI2CCHECK_STATUS ! Read the status bit,
														JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
														JTAGI2CFLASH_VERIFY	! Verify CFG,
														JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
														JTAGI2CUFM_VERIFY          ! Verify the UFM,
														JTAGI2CCHECK_STATUS ! Read the status bit,								 
														JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
														JTAGI2CPROGRAM_SECURITY ! Secure device,
									 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"JTAGI2C Background Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
																JTAGI2CREAD_ID	! Check the IDCODE, 
																JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
																JTAGI2CFLASH_ERASE	! Erase the Flash,
																JTAGI2CCHECK_STATUS ! Read the status bit,
											 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
																JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
																JTAGI2CCHECK_STATUS ! Read the status bit,
																JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
																JTAGI2CFLASH_VERIFY	! Verify CFG,
																JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
																JTAGI2CUFM_VERIFY          ! Verify the UFM,	
																JTAGI2CCHECK_STATUS ! Read the status bit,							 
																JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
																JTAGI2CUFM_SECURITY ! Secure the UFM,	
																JTAGI2CPROGRAM_SECURITY ! Secure device,
											 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"JTAGI2C Background Verify Only" = "JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 			JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
										JTAGI2CFLASH_VERIFY	! Verify the Flash, 
										JTAGI2CUFM_VERIFY          ! Verify the UFM,							
										JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 
										JTAGI2CCHECK_STATUS ! Read the status bit, 
										JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
										JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"JTAGI2C Background Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,
							 			JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
										JTAGI2CFLASH_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	"JTAGI2C Refresh"	=	"JTAGI2CINIT_SVF 	! Initialize, 
							 JTAGI2CREAD_ID	! Check the IDCODE,	
							 JTAGI2CREFRESH ! Refresh";		
	
	"JTAGI2C Check Feature Row"	=	"JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;
	
	"JTAGI2C Check Protect Fuses" =  "JTAGI2CINIT_SVF 	! Initialize, 
									  JTAGI2CREAD_ID	! Check the IDCODE, 
									  SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;	
	
	"JTAGI2C Erase Feature Row with Password Key"	=	"JTAGI2CINIT 	! Initialize, 
													 JTAGI2CREAD_ID	! Check the IDCODE, 
													 SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
													 JTAGI2CFLASH_ENABLE	! Enable the Flash, 	
													 JTAGI2CFEATURE_ERASE	! Erase the Feature row, 
													 JTAGI2CFLASH_ERASE	! Erase the Flash,
													 JTAGI2CCHECK_STATUS ! Read the status bit,
													 JTAGI2CDISABLE ! Exit the programming mode"	;
																																																														
	"JTAGI2C Program Password Key" = "JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								  JTAGI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  JTAGI2CDISABLE ! Exit the programming mode" ;
							  
	"JTAGI2C Program Password Key with Lock" = "JTAGI2CINIT 	! Initialize, 
								  			JTAGI2CREAD_ID	! Check the IDCODE, 
								  			JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode" ;							  	
	
	"JTAGI2C EPV with Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	JTAGI2CDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C EPVS with Password Key Option" = "JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CPROGRAM_SECURITY ! Secure device,							 			 	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C EPV with my_ASSP, Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash, 
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,									 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
													JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													JTAGI2CDISABLE ! Exit the programming mode"	;
																				  								 
	"JTAGI2C Erase,Program,Verify with Password" =   "JTAGI2CINIT_SVF 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											         	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
														JTAGI2CFLASH_ERASE	! Erase the Flash,
														JTAGI2CCHECK_STATUS ! Read the status bit,
									 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
														JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
														JTAGI2CCHECK_STATUS ! Read the status bit,
														JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
														JTAGI2CFLASH_VERIFY	! Verify CFG,
														JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
														JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
														JTAGI2CCHECK_STATUS ! Read the status bit,	
														JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
									 			 		
	"JTAGI2C Fast Configuration with Password" = "JTAGI2CINIT_SVF 	! Initialize,   
													  JTAGI2CREAD_ID	! Check the IDCODE,
													  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
													  SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
													  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
													  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
													  JTAGI2CDISABLE ! Exit the programming mode"	;
													  
	"JTAGI2C Verify Only with Password" = "JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CFLASH_VERIFY	! Verify the Flash,
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
											JTAGI2CCHECK_STATUS ! Read the status bit, 
											JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C Erase Only with Password" =	"JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
										    JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
						 			 								 
	"I2CASC Erase,Program,Verify" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
									 
	"I2CASC Erase,Program,Verify,I2CSA" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify,I2CSA" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 
	"I2CASC I2CSA Program" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Program" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 			 			 		 	
	"I2CASC I2CSA Erase Only" =	"I2CASC_SVF_INIT 	! Initialize, 
								 I2CASCREAD_ID_SVF	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Erase Only" =	"I2CASC_SVF_INIT 	! Initialize, 
								 I2CASCREAD_ID_SVF	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_EXIT_USERMODE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	
	"I2CASC Program" =	 	"I2CASC_SVF_INIT 	! Initialize, 
						 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						 I2CASC_ENABLE	! Enable the ASC, 
						 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
						 I2CASC_PROGRAM_STATUS	! Program CFG,
						 I2CASCPROGRAM_USERCODE	! Program USERCODE,
						 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
						 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Program" =	 	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
						 			 		 
	"I2CASC Erase Only" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase Only" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"I2CASC Verify Only" = 	"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 I2CASC_VERIFY_SVF	! Verify ASC CFG,
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
							 
	"I2CASC Background Verify Only" = 	"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 I2CASC_VERIFY_SVF	! Verify ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
							 							 
	"I2CASC Read Status Register" = 	"I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,	
								     I2CASCSAVE_ID	,	
									 I2CASC_SAVE_STATUS";
	"I2CASC Background Read Status Register" = 	"I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,	
								     I2CASCSAVE_ID	,	
									 I2CASC_SAVE_STATUS";
									 									 
	"I2CASC Verify ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF	! Check the IDCODE";
	"I2CASC Background Verify ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF	! Check the IDCODE";
					     					     
	"I2CASC Display ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF";					     									 							 								 							 			 																													  
	
	"I2CASC Background Display ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF";	
					     
	"I2CASC Refresh" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_REFRESH	! Refresh"	;
	
	"I2CASC Background Refresh" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_REFRESH	! Refresh"	;
							 
	"I2CASC Read Shadow Registers" = "I2CASC_SVF_INIT 	! Initialize, 
								   I2CASCREAD_ID_SVF	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;

	"I2CASC Background Read Shadow Registers" = "I2CASC_SVF_INIT 	! Initialize, 
								   I2CASCREAD_ID_SVF	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;
								   
	"I2CASC Read FaultLog Registers" = "I2CASC_SVF_INIT 	! Initialize, 
									     I2CASCREAD_ID_SVF	! Check the IDCODE,	
									     I2CASCSAVE_ID,
										 I2CASC_ENABLE	! Enable the ASC, 
										 I2CASC_SAVE_FAULTLOG_REGISTERS,
										 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Registers" = "I2CASC_SVF_INIT 	! Initialize, 
									     I2CASCREAD_ID_SVF	! Check the IDCODE,	
									     I2CASCSAVE_ID,
										 I2CASC_ENABLE	! Enable the ASC, 
										 I2CASC_SAVE_FAULTLOG_REGISTERS,
										 I2CASC_EXIT_USERMODE ! Exit the programming mode";
										 
	"I2CASC Read FaultLog Memory" = "I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,
								     I2CASCSAVE_ID,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_MEMORY,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Memory" = "I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,
								     I2CASCSAVE_ID,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_MEMORY,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
									 
	"I2CASC FaultLog Erase Only" = "I2CASC_SVF_INIT 	! Initialize, 
							     I2CASCREAD_ID_SVF	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background FaultLog Erase Only" = "I2CASC_SVF_INIT 	! Initialize, 
							     I2CASCREAD_ID_SVF	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
								 							 
	"I2CASC Read and Save" = "I2CASC_SVF_INIT 	! Initialize, 
						     I2CASCREAD_ID_SVF	! Check the IDCODE,
						     I2CASCSAVE_ID,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCSAVE_USERCODE		! Read USERCODE,																																											 
							 I2CASC_SAVE	! Read ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read and Save" = "I2CASC_SVF_INIT 	! Initialize, 
						     I2CASCREAD_ID_SVF	! Check the IDCODE,
						     I2CASCSAVE_ID,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCSAVE_USERCODE		! Read USERCODE,																																											 
							 I2CASC_SAVE	! Read ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode";		 			 								 						 			 								 			 		
	
	"I2CASC Calculate Data CRC"	=	"I2CASC_SVF_INIT 	! Initialize, 
						     		 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						     		 I2CASCSAVE_ID,
						     		 I2CASC_ENABLE	! Enable the ASC, 
								     I2CASC_SAVE,
								     I2CASC_EXIT_USERMODE ! Exit the programming mode";
								     
	
	"I2CASC Background Calculate Data CRC"	=	"I2CASC_SVF_INIT 	! Initialize, 
						     		 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						     		 I2CASCSAVE_ID,
						     		 I2CASC_ENABLE	! Enable the ASC, 
								     I2CASC_SAVE,
								     I2CASC_EXIT_USERMODE ! Exit the programming mode";
													 																			 			 							
</Operation_List>
<Operation_List label="TurboOperation">
	"Bypass"	=	"INIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  														 															 			 							
</Operation_List>
<Operation_List label="ChainSVFOperation">	
	"Bypass"	=	"SVFINIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  																 			 		
</Operation_List>
<Operation_List label="SingleSVFOperationRevC">					 
	"Verify SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_MSPI ! Check the MSPI Setting,  
					 CHECK_SRAM_OTP ! Check the OTP fuses,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 CHECK_KEYLOCK ! Check the Key Protection fuses,  
					 PSUEDO_FLASH_ENABLE	! Enable the Flash Pseudo programming mode,
					 PSUEDO_FLASH_ERASE	! Erase the Shadow Feature Rows register,
					 CHECK_STATUS ! Read the status bit, 
					 SVF_SPI_FEATURE_PROGRAM ! Enable MSPI, 
					 DISABLE_REFRESH ! Exit the programming mode,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
		 			 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = "SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  											 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;
					 			 				 
	"Security Erase Feature Rows"	=	"SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses, 									
										FLASH_ENABLE	! Enable the programming mode, 	
										SVF_FEATURE_ERASE	! Erase the Feature row, 
										SVF_FLASH_ERASE	! Erase the CFG, 
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
										
														
	"Security Check Feature Row"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses"	;			
	
	
										
	"Security Program Feature Bits"	=	"SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the programming mode, 
										SVF_FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										SVF_PROGRAM_CONFIG_REGISTER ! Program the Feature Bits,
										DISABLE ! Exit the programming mode"	;
																													
	"Security Read Status Register" = "SVFINIT ! Initialize,
						 			 READ_ID	! Check the IDCODE,
						 			 SAVE_ID,
						 			 FLASH_ENABLE,
						 			 SVF_SAVE_STATUS,
						 			 DISABLE";
	
						   				 			 
	"Security Check Protect Fuses" =  "SVFINIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	"Verify ID with Password" = 		"SVFINIT 	! Initialize, 
						 				READ_ID ! Check the IDCODE,
						 				SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key";
						 												   																											
	"Security Read Feature Row with Password Key"	=	"SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														SAVE_ID,
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
														FEATURE_ROW_READ	! Read the Feature row, 
														DISABLE ! Exit the programming mode"	;
										
	"Security Erase Feature Row with Password Key"	=	"SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE,
														CHECK_FR_OTP ! Check the OTP fuses,
														SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 									
														FLASH_ENABLE	! Enable the programming mode, 	
														FEATURE_ERASE	! Erase the Feature row, 
														FLASH_ERASE	! Erase the CFG, 
														CHECK_STATUS ! Read the status bit,
														DISABLE ! Exit the programming mode"	;
																																																														
	"Security Program Password Key" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  CHECK_FR_OTP ! Check the OTP fuses,
									  CHECK_KEYLOCK ! Check the Key Protection fuses,  
									  FLASH_ENABLE	! Enable the programming mode,
									  PROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  DISABLE ! Exit the programming mode" ;
							  
	"Security Program Password Key with Lock" = "SVFINIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  CHECK_FR_OTP ! Check the OTP fuses,
												  CHECK_KEYLOCK ! Check the Key Protection fuses,  
												  FLASH_ENABLE	! Enable the programming mode,
												  PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
												  DISABLE ! Exit the programming mode" ;
							  
	"Security Check Password Key" =  "SVFINIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 																							
									   READ_PROTECT_KEY_FUSES ! Read the Protection Fuses,
									   DISABLE ! Exit the programming mode" ;
								   				 			 
	"Security Flash EPV with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 															   
	
	"Security Flash EPVS with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,									 			 		
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security Flash Program with Password" = "SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  
											FLASH_ENABLE	! Enable the programming mode,
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											DISABLE ! Exit the programming mode"	;
						 			 				 			 		
	"Security Flash Erase with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
													FLASH_ENABLE	! Enable the programming mode, 
													CHECK_CFG_UFM_OTP ! Check the OTP fuses,
													SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
							
	"Security Flash Verify with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													IO_STATE ! Program Bscan register,
													SVFCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,  											
													FLASH_ENABLE	! Enable the programming mode, 
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode,
													VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							
							
	"Security XFlash EPV with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode"	;
			 			 										 			 					 			 		
	
	"Security XFlash EPVS with Password" = "	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
												SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												CHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
												CHECK_STATUS ! Read the status bit,
							 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
							 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,				 			 		
							 			 		DISABLE ! Exit the programming mode"	;
			 			 			 			 															  
	"Security XFlash Program with Password" = "	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											CHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,	
											FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode"	;
						 			 		
	"Security XFlash Erase with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													CHECK_CFG_UFM_OTP ! Check the OTP fuses, 
													SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
													CHECK_STATUS ! Read the status bit,
													DISABLE ! Exit the programming mode"	;
		 			 					 			 		
	
	"Security XFlash Verify with Password"	=	"	SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE,
													FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													FLASH_VERIFY	! Verify CFG, 
													UFM_VERIFY          ! Verify the UFM,							
													VERIFY_USERCODE		! Verify USERCODE,
													CHECK_STATUS ! Read the status bit, 
													VERIFY_DONE_BIT ! Verify Done Bit,
													DISABLE ! Exit the programming mode"	;
							
	
	"Security Fast Program with Password" = "SVFINIT 	! Initialize,   
											READ_ID	! Check the IDCODE,
											IO_STATE ! Program Bscan register,
											CHECK_SRAM_OTP ! Check the OTP fuses,
									 		SRAM_ENABLE	! Enable SRAM programming mode,
									 		SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
											SRAM_ERASE	! Erase the SRAM, 
											BURST_PROGRAM	! Program Fuse Map,
											VERIFY_USERCODE		! Verify USERCODE,
											DISABLE ! Exit the programming mode"	;
	
	
	"Security SRAM EPV with Password" = "SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		SRAM_ENABLE	! Enable SRAM programming mode, 
						 		SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;						
			 			 		
	"Security SRAM Erase with Password"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;
	
	"Security SRAM Verify with Password"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	
	"Security XSRAM SEI Fast Program with Password" = "SVFINIT 	! Initialize,   
													READ_ID	! Check the IDCODE,
													CHECK_SRAM_OTP ! Check the OTP fuses,
													SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
													SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													BURST_PROGRAM	! Program Fuse Map,
													DISABLE ! Exit the programming mode,
													VERIFY_STATUS ! Verify Status Register"	;
	
	"Security XSRAM Verify with Password"	=	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,  
												SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
												SVFCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SRAM_VERIFY	! Verify Fuse Map, 
												SRAM_VERIFY_USERCODE		! Verify USERCODE, 
							 			 		DISABLE ! Exit the programming mode"	;	 			 		
	
	"Security EPV with Password Key Option" = 	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,								
												CHECK_STATUS ! Read the status bit,
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,		
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							 			 		
	"Security EPVS with Password Key Option" = "SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,	
												FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												PROGRAM_SECURITY ! Secure device,									 			 									 			 		
												PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPV with my_ASSP, Password Key Option" = 	"SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												FEATURE_PROGRAM_STATUS ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		FLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
															
	"Security EPV with OTP Option" = 	"	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											SVF_FEATURE_PROGRAM ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		PROGRAM_DONE_BIT	! Program DONE bit,
						 			 		SVF_OTP_PROGRAM_STATUS ! Program OTP, 	
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
										
 	
 	"Security EPVS with OTP Option" = 	"	SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_ENABLE	! Enable the Flash,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
											CHECK_STATUS ! Read the status bit,
											SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											SVF_FEATURE_PROGRAM ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,			 			 		
						 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		PROGRAM_SECURITY ! Secure device,							 			 		
						 			 		SVF_OTP_PROGRAM_STATUS ! Program OTP, 
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
						 			 		
	"Security EPV with Full OTP Option" =  	"	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												SVF_FEATURE_PROGRAM ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		PROGRAM_DONE_BIT	! Program DONE bit,
							 			 		SVF_OTP_FEATURE_ROW_STATUS ! Program OTP, 	
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Security EPVS with Full OTP Option" = "	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												SVF_FEATURE_PROGRAM ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		UFM_SECURITY ! Secure the UFM,
							 			 		PROGRAM_SECURITY ! Secure device,	
							 			 		SVF_OTP_FEATURE_ROW_STATUS ! Program OTP, 
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
								 			 		
	"Security EPV with my_ASSP Option" = 	"	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses,  
												FLASH_ENABLE	! Enable the Flash,
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
												CHECK_STATUS ! Read the status bit,
												SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												SVF_FEATURE_PROGRAM ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;	
										
	"Security EPVS with my_ASSP Option" = 	"	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												CHECK_KEYLOCK ! Check the Key Protection fuses, 
												FLASH_ENABLE	! Enable the Flash, 
												CHECK_FLASH_OTP ! Check the OTP fuses,
												SVF_DIRECT_FLASH_ERASE	! Erase the Flash, 
												CHECK_STATUS ! Read the status bit,
							 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
												SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
												PROGRAM_USERCODE	! Program USERCODE,
												CHECK_STATUS ! Read the status bit,
												FLASH_VERIFY	! Verify CFG,
												UFM_VERIFY          ! Verify the UFM,								 
												VERIFY_USERCODE		! Verify USERCODE,
												CHECK_STATUS ! Read the status bit,	
												SVF_FEATURE_PROGRAM ! Program Feature Rows,
												CHECK_STATUS ! Read the status bit,			 			 		
							 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		PROGRAM_SECURITY ! Secure device,									 			 		
							 			 		DISABLE ! Exit the programming mode,
							 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;							 			 								 			 					 			 		
		 			 		
	"FLASH Verify Feature Rows"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_ENABLE	! Enable the Flash, 
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;
	
	"FLASH Program Feature Rows"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  											 
					 					FLASH_ENABLE	! Enable the Flash, 
										SVF_FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
										SVF_FEATURE_PROGRAM_STATUS ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
	
	"Bypass"	=	"SVFINIT 	! Initialize";																			
	"FLASH Bypass"	=	"SVFINIT 	! Initialize";
	"FLASH Verify ID" = 	"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"Verify ID" = 		"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"FLASH Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	
	"FLASH Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 FLASH_ENABLE	! Enable the Flash, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"FLASH Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
					 			 FLASH_ENABLE	! Enable the Flash, 
					             CHECK_CFG_OTP ! Check the OTP fuses,
								 PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
					             
	"FLASH Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the Flash, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	; 								
	"FLASH Display USERCODE"	=	"SVFINIT, 
									 READ_ID	! Check the IDCODE,
									 FLASH_ENABLE	! Enable the Flash, 
									 SVF_SAVE_USERCODE,
									 DISABLE ! Exit the programming mode";
	"FLASH Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"FLASH Enable Only" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   IO_STATE ! Program Bscan register,
						   FLASH_ENABLE	! Enable the CFG"	;
	"FLASH Erase DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								FLASH_ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
		 			 			
	"FLASH Program DONE bit"	=	"SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 IO_STATE ! Program Bscan register,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
									 FLASH_ENABLE	! Enable the Flash, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"FLASH Read DONE bit" = 	"SVFINIT, 
								 READ_ID, 
								 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 SVF_SAVE_DONE_BIT,
								 DISABLE ! Exit the programming mode";
	
	"FLASH Re-Initialize" = "SVFINIT 	! Initialize,  
							 CHECK_KEYLOCK ! Check the Key Protection fuses,  											 					 					
						  	 FLASH_ENABLE	! Enable programming mode, 
						  	 DIRECT_FLASH_ERASE	! Erase the CFG, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"FLASH Program,Verify,skip Erase" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 		
	"Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	
	"FLASH CFG Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,								
								SVF_CFG_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"FLASH CFG and UFM Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,								
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 				 			 				 			 		
	"FLASH Erase,Program" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
								SVF_FLASH_PROGRAM_STATUS	! Program the Flash,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,			 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 					 			 			
	"FLASH Erase,Program,Verify,Secure" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
			 			 		
	"Erase,Program,Verify,Secure" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		

	"FLASH Erase,Program,Verify,Secure Plus" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash,
								CHECK_FLASH_OTP ! Check the OTP fuses,
								SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,								
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		UFM_SECURITY ! Secure the UFM,											 			 					 			 		
			 			 		PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;			 			 		
	
	"FLASH Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_CFG_OTP ! Check the OTP fuses,
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	"FLASH Secure Plus" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;			 			 		
			 			 		
	"FLASH Program"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							SVF_DIRECT_FLASH_ERASE	! Erase the Flash, 
							CHECK_STATUS ! Read the status bit,
							SVF_FLASH_PROGRAM_STATUS	! Program CFG,
							SVF_UFM_PROGRAM_STATUS  ! Program UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							SVF_FEATURE_PROGRAM ! Program Feature Rows,		 			 		
			 			 	PROGRAM_DONE_BIT	! Program DONE bit,								
							DISABLE ! Exit the programming mode"	;		
	
	"FLASH Program,skip Erase"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_FLASH_OTP ! Check the OTP fuses,
							CHECK_STATUS ! Read the status bit,
							SVF_FLASH_PROGRAM_STATUS	! Program CFG,
							SVF_UFM_PROGRAM_STATUS  ! Program UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							SVF_FEATURE_PROGRAM ! Program Feature Rows,		 			 		
			 			 	PROGRAM_DONE_BIT	! Program DONE bit,								
							DISABLE ! Exit the programming mode"	;	
							
	"FLASH Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE	! Verify USERCODE, 
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							CHECK_STATUS ! Read the status bit,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
	
	"Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE	! Verify USERCODE, 
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY ! Verify Feature Rows,
							CHECK_STATUS ! Read the status bit,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode,
							VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit"	;
							
	"FLASH Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			
	
	"Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_OTP ! Check the OTP fuses,
							SVF_CFG_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"FLASH Erase CFG and UFM Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"FLASH Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_ENABLE	! Enable programming mode, 
						             SVF_FLASH_CHECKSUM_ARRAY,
						             SVF_UFM_CHECKSUM_ARRAY,
								 	 SVF_FEATURE_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";
						             			 						 
	"FLASH Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 IO_STATE ! Program Bscan register,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_ENABLE, 
								 SVF_FLASH_SAVE_ARRAY,
								 SVF_UFM_SAVE_ARRAY,
								 SVF_FEATURE_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	
	"FLASH Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_ENABLE,
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";
	"FLASH Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;					 			 
	"FLASH Upload to Static RAM" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";
						
	"FLASH UFM Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_ENABLE	! Enable the Flash, 
								SVF_UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
	
	"FLASH Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"FLASH UFM Erase" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							SVF_UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"FLASH Display UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							SVF_SAVE_ID, 
							FLASH_ENABLE	! Enable the Flash, 
							SVF_UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
	
	"FLASH UFM Secure" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_ENABLE	! Enable the Flash, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;

	"XFLASH Verify Feature Rows"	=	"	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_KEYLOCK ! Check the Key Protection fuses,  
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										FEATURE_VERIFY ! Verify the Feature,	
										DISABLE ! Exit the programming mode"	;	

	"FLASH Refresh" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
							
	"XFLASH Upload to Static RAM" = " 	SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						UPLOAD_FUNCTION ! Uploaded";				 			 							 
	"XFLASH Bypass"	=	"SVFINIT 	! Initialize";
	"XFLASH Verify ID" = 	"SVFINIT 	! Initialize, 
						 	READ_ID ! Check the IDCODE"; 
	"XFLASH Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	"XFLASH Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	; 
	"Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;								
	"XFLASH Display USERCODE"	=	"SVFINIT, 
								     READ_ID	! Check the IDCODE,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 	SVF_SAVE_USERCODE,
								 	DISABLE ! Exit the programming mode";
	"XFLASH Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"XFLASH Enable Only" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode"	;
	"XFLASH Erase DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								ERASE_DONE_BIT	! Erase the done bit, 
		 			 			DISABLE ! Exit the programming mode"	;
	"XFLASH Program DONE bit"	=	"SVFINIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
									 CHECK_CFG_OTP ! Check the OTP fuses,
									 FLASH_PROGRAM_DONE_BIT	! Program DONE bit,
							   		 CHECK_STATUS ! Read the status bit,
		 			 				 DISABLE ! Exit the programming mode"	;
	"XFLASH Read DONE bit" = 	"SVFINIT, 
								 READ_ID, 
								 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								 SVF_SAVE_DONE_BIT,
								 DISABLE ! Exit the programming mode";
	
	"XFLASH Re-Initialize" = "SVF_INIT 	! Initialize,  
						  	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
							 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
						  	 FLASH_ERASE	! Erase the device, 
	 			 		  	 DISABLE ! Exit the programming mode"	;
	
	"XFLASH Clamping IO" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							FLASH_MDR ! Transparent Field Reconfiguration"	;
	
	"XFLASH Program and Clamping IO" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,	
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		IO_STATE ! Program Bscan register,
			 			 		FLASH_MDR ! Transparent Field Reconfiguration"	;
			 			 		
	"XFLASH TransFR" = "SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						REFRESH_FUNCTION ! Refresh"	;
	
	"XFLASH Program and TransFR" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
			 			 		CHECK_STATUS ! Read the status bit,	
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh"	;	 			 		
	
	
	"XFLASH Program Feature Rows" =    "SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										CHECK_FR_OTP ! Check the OTP fuses,
										CHECK_KEYLOCK ! Check the Key Protection fuses,   
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										SVF_FEATURE_ERASE	! Erase the Feature Rows,
										SVF_FEATURE_PROGRAM ! Program Feature Rows,
										DISABLE ! Exit the programming mode"	;
											 			 		
	
	"XFLASH Erase,Program,Verify,Feature" = "SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											CHECK_KEYLOCK ! Check the Key Protection fuses,  
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_FLASH_OTP ! Check the OTP fuses,
											SVF_FLASH_ERASE	! Erase the Flash, 
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
						 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
						 			 		PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify the Flash,
											UFM_VERIFY          ! Verify the UFM,									 
											VERIFY_USERCODE	! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											SVF_FEATURE_PROGRAM ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,				 			 		
						 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Erase,Program,Verify,Feature and TransFR" = "SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE, 
														CHECK_KEYLOCK ! Check the Key Protection fuses,  
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														CHECK_FLASH_OTP ! Check the OTP fuses,
														SVF_FLASH_ERASE	! Erase the Flash, 
														CHECK_STATUS ! Read the status bit,
									 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
									 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
									 			 		PROGRAM_USERCODE	! Program USERCODE,
														CHECK_STATUS ! Read the status bit,
														FLASH_VERIFY	! Verify the Flash,
														UFM_VERIFY          ! Verify the UFM,									 
														VERIFY_USERCODE	! Verify USERCODE,
														CHECK_STATUS ! Read the status bit,	
														SVF_FEATURE_PROGRAM ! Program Feature Rows,
														CHECK_STATUS ! Read the status bit,				 			 		
									 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		DISABLE ! Exit the programming mode,
										 			 	REFRESH_FUNCTION ! Refresh"	;
										 			 	
	"XFLASH Erase,Program,Verify,Feature,Secure and TransFR" = "SVFINIT 	! Initialize, 
														READ_ID	! Check the IDCODE, 
														CHECK_KEYLOCK ! Check the Key Protection fuses,  
														FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
														CHECK_FLASH_OTP ! Check the OTP fuses,
														SVF_FLASH_ERASE	! Erase the Flash, 
														CHECK_STATUS ! Read the status bit,
									 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
									 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
									 			 		PROGRAM_USERCODE	! Program USERCODE,
														CHECK_STATUS ! Read the status bit,
														FLASH_VERIFY	! Verify the Flash,
														UFM_VERIFY          ! Verify the UFM,									 
														VERIFY_USERCODE	! Verify USERCODE,
														CHECK_STATUS ! Read the status bit,	
														SVF_FEATURE_PROGRAM ! Program Feature Rows,
														CHECK_STATUS ! Read the status bit,				 			 		
									 			 		PROGRAM_DONE_BIT	! Program DONE bit,
									 			 		PROGRAM_SECURITY ! Secure device,	
									 			 		DISABLE ! Exit the programming mode,
										 			 	REFRESH_FUNCTION ! Refresh"	;
											 			 			 			 		
	"XFLASH Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,  
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Erase,Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_CFG_FLASH_ERASE	! Erase the Flash,  
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Erase,Program,Verify,Refresh" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,				 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Upload to SRAM"	;	
			 			 			
	"XFLASH Erase,Program,Verify,Secure" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,   
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Erase,Program,Verify,Secure and TransFR" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,   
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		PROGRAM_SECURITY ! Secure device,			 			 		
			 			 		DISABLE ! Exit the programming mode,
			 			 		REFRESH_FUNCTION ! Refresh"	;
			 			 		
	"XFLASH Erase,Program,Verify,Secure Plus" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								FEATURE_VERIFY_STATUS ! Verify the Feature,									
								SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,   
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
			 			 		PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify the Flash,
								UFM_VERIFY          ! Verify the UFM,									 
								VERIFY_USERCODE	! Verify USERCODE,								
								CHECK_STATUS ! Read the status bit,
								PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		UFM_SECURITY ! Secure the UFM,												 			 						 			 		
			 			 		PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode"	;			 			 		
	
	"XFLASH Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								PROGRAM_SECURITY ! Secure device,
			 			 		CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
	
	"XFLASH Secure Plus" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								CHECK_CFG_UFM_OTP ! Check the OTP fuses,
								UFM_SECURITY ! Secure the UFM,			 			 		
								PROGRAM_SECURITY ! Secure device,
								CHECK_STATUS ! Read the status bit,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 				 			 		
	"XFLASH Program"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FEATURE_VERIFY_STATUS ! Verify the Feature,									
							SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,   
							CHECK_STATUS ! Read the status bit,
							SVF_FLASH_PROGRAM_STATUS	! Program the CFG,
							SVF_UFM_PROGRAM_STATUS  ! Program the UFM,							
							PROGRAM_USERCODE	! Program USERCODE, 
							CHECK_STATUS ! Read the status bit,
							PROGRAM_DONE_BIT	! Program DONE bit,	
							DISABLE ! Exit the programming mode"	;		
	"XFLASH Verify Only" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							FEATURE_VERIFY_STATUS ! Verify the Feature,								
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							VERIFY_USERCODE	! Verify USERCODE,							
							CHECK_STATUS ! Read the status bit, 
							DISABLE ! Exit the programming mode"   ;
	"XFLASH Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 
							SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			
	"XFLASH Erase CFG Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_OTP ! Check the OTP fuses,
							SVF_CFG_FLASH_ERASE	! Erase the CFG,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 		
	"XFLASH Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 SVF_SAVE_ID, 
								 	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 FLASH_TRANSPARENT_ENABLE	! Enable programming mode, 
						             SVF_FLASH_CHECKSUM_ARRAY,
						             SVF_UFM_CHECKSUM_ARRAY,
								 	 SVF_FEATURE_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";					 						 
	"XFLASH Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 FLASH_TRANSPARENT_ENABLE, 
								 SVF_FLASH_SAVE_ARRAY, 
								 SVF_UFM_SAVE_ARRAY,
								 SVF_FEATURE_SAVE_ARRAY,
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	"XFLASH Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_TRANSPARENT_ENABLE, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";	
	"XFLASH Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
						
	"XFLASH UFM Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								SVF_UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
	
	"XFLASH Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"XFLASH UFM Erase" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							SVF_UFM_ERASE	! Erase the UFM, 
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"XFLASH Display UFM" = "SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							SVF_UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
	
	"XFLASH UFM Secure" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_UFM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							PROGRAM_SECURITY ! Secure device,
							UFM_SECURITY ! Secure the UFM,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 													 			 
	"SRAM Bypass"	=	"SVFINIT 	! Initialize";
	"SRAM Verify ID" = 	"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 
	"SRAM Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";
	"SRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								SRAM_VERIFY_USERCODE		! Verify USERCODE"	; 
	"SRAM Display USERCODE"	=	"SVFINIT, READ_ID, SRAM_ENABLE, SVF_SAVE_USERCODE, DISABLE";
	"SRAM Disable Only" = "	SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"SRAM Enable Only" = "SVFINIT 	! Initialize, 
						  READ_ID	! Check the IDCODE,
						  IO_STATE ! Program Bscan register,
						  SRAM_ENABLE	! Enable SRAM programming mode"	;
						  
	"SRAM Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SRAM_ENABLE	! Enable SRAM programming mode,
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"SRAM Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_OTP ! Check the OTP fuses,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode,
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
					             						  
	"SRAM Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"SRAM Erase,Program,Verify" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;

	"SRAM Program Only" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
						 		CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;


								
	"SRAM Secure Device" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								PROGRAM_SECURITY ! Secure device,
			 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"SRAM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode,  
							SRAM_ERASE	! Erase the SRAM,  
		 			 		DISABLE ! Exit the programming mode"	;
	
	"SRAM Verify Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,  
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							SRAM_VERIFY	! Verify the SRAM, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Re-Initialize" = "SVFINIT 	! Initialize,
					   CHECK_KEYLOCK ! Check the Key Protection fuses,  
					   SRAM_ENABLE	! Enable SRAM programming mode, 
					   SRAM_ERASE	! Erase the SRAM, 
					   DISABLE ! Exit the programming mode"	;
	"SRAM Re-Initialize" = "SVFINIT 	! Initialize,
						   CHECK_KEYLOCK ! Check the Key Protection fuses,  
						   SRAM_ENABLE	! Enable SRAM programming mode, 
						   SRAM_ERASE	! Erase the SRAM, 
						   DISABLE ! Exit the programming mode"	;
	"SRAM Erase DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
	"SRAM Program DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_ENABLE	! Enable SRAM programming mode, 
							ERASE_DONE_BIT	! Erase DONE bit,
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"SRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 SVF_SAVE_DONE_BIT	! Erase the done bit"	;
	
	"SRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 IO_STATE ! Program Bscan register,
					 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE	! Enable SRAM programming mode, 
					             SVF_SRAM_SAVE_ARRAY,
					             SVF_SAVE_USERCODE,
		 						 DISABLE";
	"SRAM Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID, 
								 	 SVF_SAVE_ID, 
								 	 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_ENABLE	! Enable programming mode, 
						             SVF_SRAM_CHECKSUM_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";	
		 						 		 						 
	"SRAM Read and Save"	=	"SVFINIT, 
						 		 READ_ID, 
								 SVF_SAVE_ID, 
								 IO_STATE ! Program Bscan register,
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SRAM_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	"SRAM Refresh" = " SVFINIT !Initialize,
						READ_ID !Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
					             
	"SRAM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SRAM_ENABLE, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE";							
	"SRAM Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;	
	
	"XSRAM SEI Fast Program" 	= "	SVFINIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									CHECK_SRAM_OTP ! Check the OTP fuses,
									CHECK_KEYLOCK ! Check the Key Protection fuses,  
									SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;
														
	"XSRAM Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode, 
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode"	;
	
	"XSRAM Fast Program,Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
								
	"XSRAM Erase,Program,Verify" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode"	;					
	
	"XSRAM Erase,Program,Verify,Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								CHECK_SRAM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses,  
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
								XSRAM_ERASE	! Erase the SRAM, 
								PROGRAM_CONTROL0	! Program Control Register,
								SRAM_PROGRAM	! Program Fuse Map,
								SRAM_PROGRAM_USERCODE	! Program USERCODE,
								SRAM_VERIFY	! Verify Fuse Map, 
								VERIFY_USERCODE		! Verify USERCODE, 
								PROGRAM_DONE_BIT	! Program DONE bit,
								DISABLE ! Exit the programming mode,
								REFRESH_FUNCTION ! Refresh"	;
	
	"XSRAM Refresh" = "	SVFINIT 	! Initialize,   
						READ_ID	! Check the IDCODE,
						REFRESH_FUNCTION ! Refresh" ;
								
	"XSRAM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_SRAM_OTP ! Check the OTP fuses,
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							XSRAM_ERASE	! Erase the SRAM, 
		 			 		DISABLE ! Exit the programming mode"	;
	
	"XSRAM Verify Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode,  
							SRAM_VERIFY	! Verify Fuse Map, 
							SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
		 			 												 			 
	"XSRAM Bypass"	=	"SVFINIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE"	; 
	"XSRAM Display ID" = "SVFINIT, READ_ID, SVF_SAVE_ID";							
	"XSRAM Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 CHECK_KEYLOCK ! Check the Key Protection fuses,  
								 SRAM_TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SRAM_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";					 
	"XSRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
									 READ_ID	! Check the IDCODE,
						 			 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SVF_SRAM_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
			 						 DISABLE";
	
	"XSRAM Calculate Checksum"	=	"SVFINIT ! Initialize,
									 READ_ID,
									 SVF_SAVE_ID,									 
									 CHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
						             SVF_CHECKSUM_ARRAY,
						             SVF_SAVE_USERCODE,
						             DISABLE";
			 						 	 			 		
	"XSRAM Verify Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses,  
							SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
							VERIFY	! Verify Fuse Map, 
		 			 		SRAM_VERIFY_USERCODE		! Verify USERCODE, 
		 			 		DISABLE ! Exit the programming mode"	;
	"XSRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE,
			 			 		DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;				             
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode, 
					 			 SVF_SAVE_STATUS,
					 			 DISABLE ! Exit the programming mode";	
	"XSRAM Capture Only" = "SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;	
	"XSRAM Display USERCODE"	=	"SVFINIT, READ_ID, SRAM_TRANSPARENT_READ_ENABLE, SVF_SAVE_USERCODE, DISABLE";
											 			 
	"Capture Only" = "SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;

	"Slave SPI Verify ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID";
	
	"Slave SPI Refresh" = "SPIINIT !Initialize,
						   SPIREAD_ID	! Check the IDCODE, 
						   SPIREFRESH ! Refresh";
						   
	"Slave SPI Read Status Register" = "SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
										 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
							             SPI_SAVE_STATUS !Read Status Register,
							             SPIDISABLE";							
	
	"Slave SPI Display USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
						             SPISAVE_USERCODE,
						             SPIDISABLE";
	
	"Slave SPI Verify USERCODE" = "SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPIFLASH_ENABLE	! Enable the Flash, 
									 SPIVERIFY_USERCODE		! Verify USERCODE,										
						             SPIDISABLE";
						             
	"Slave SPI Calculate Checksum"	=	"SPIINIT ! Initialize,
										 SPIREAD_ID, 
										 SPISAVE_ID,
							 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
										 SPIFLASH_ENABLE	! Enable the Flash, 
							             SPIFLASH_SAVE_ARRAY,
							             SPIUFM_SAVE_ARRAY,
							             SPIFEATURE_SAVE_ARRAY,
							             SPISAVE_USERCODE,
				 						 SPIDISABLE";			 						 
	"Slave SPI Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
						 			 SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SPIFLASH_ENABLE	! Enable the Flash, 
						             SPIFLASH_SAVE_ARRAY,
						             SPIUFM_SAVE_ARRAY,
						             SPIFEATURE_SAVE_ARRAY,
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";	
	
	"Slave SPI RAM Read and Save"	=	"SPIINIT ! Initialize,
									 SPIREAD_ID, 
									 SPISAVE_ID,
									 SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
									 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 	
									 SPISRAM_SAVE_CONTROL0,	
									 SPISRAM_SAVE_ARRAY,					 			 							
						             SPISAVE_USERCODE,
			 						 SPIDISABLE";
			 						 							 						             
	"Slave SPI Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses,
										SPIDIRECT_FLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_OTP ! Check the OTP fuses,
										SPICFG_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_FLASH_OTP ! Check the OTP fuses,
											SPIDIRECT_FLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,	
											SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											SPICHECK_STATUS ! Read the status bit,		 			 		
						 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIDISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
												SPIFLASH_ENABLE	! Enable the Flash, 
												SPICHECK_FLASH_OTP ! Check the OTP fuses,
												SPIDIRECT_FLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												SPICHECK_STATUS ! Read the status bit,		 			 		
							 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 																			 			 					 			 					 			 			
	"Slave SPI Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,
								SPICHECK_STATUS ! Read the status bit,
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPICHECK_FLASH_OTP ! Check the OTP fuses,
								SPIDIRECT_FLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIDISABLE ! Exit the programming mode"	;
			 			 		
			 			 		
	"Slave SPI Background Erase Only"	=	"SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
								SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
								SPIFLASH_ERASE	! Erase the Flash,
								SPICHECK_STATUS ! Read the status bit,
			 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Verify Only" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE, 
								SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
								SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
								SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,								
								SPIFLASH_VERIFY	! Verify the Flash, 
								SPIUFM_VERIFY          ! Verify the UFM,							
								SPIVERIFY_USERCODE	! Verify USERCODE, 
								SPICHECK_STATUS ! Read the status bit, 
								SPIVERIFY_DONE_BIT ! Verify Done Bit,
								SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Program Feature Rows" =    "SPIINIT 	! Initialize, 
													  SPIREAD_ID	! Check the IDCODE, 
													  SPICHECK_FR_OTP ! Check the OTP fuses,
													  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
													  SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
													  SPIFEATURE_ERASE	! Erase the Feature Rows,
													  SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
													  SPICHECK_STATUS ! Read the status bit,	
													  SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
									
	"Slave SPI Background Erase,Program,Verify,Feature" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_FLASH_OTP ! Check the OTP fuses,
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFEATURE_PROGRAM_STATUS ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 									
	"Slave SPI Background CFG Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_OTP ! Check the OTP fuses,
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPICFG_ERASE	! Erase the CFG,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	
	"Slave SPI Background Erase,Program" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses, 
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 		
	"Slave SPI Background Erase,Program,Verify" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
										SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
					 			 		
					 			 		
	"Slave SPI Background Erase,Program,Verify,Secure" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPICHECK_KEYLOCK ! Check the Key Protection fuses,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
											SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
											SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
											SPIFLASH_ERASE	! Erase the Flash,
											SPICHECK_STATUS ! Read the status bit,
						 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
											SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
											SPIPROGRAM_USERCODE	! Program USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_VERIFY	! Verify CFG,
											SPIUFM_VERIFY          ! Verify the UFM,								 
											SPIVERIFY_USERCODE		! Verify USERCODE,
											SPICHECK_STATUS ! Read the status bit,
											SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		SPIPROGRAM_SECURITY ! Secure device,
						 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 											 			 					 			 		
			 			 		
	"Slave SPI Background Erase,Program,Verify,Secure Plus" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPICHECK_KEYLOCK ! Check the Key Protection fuses,
												SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFEATURE_VERIFY_STATUS ! Verify Feature Rows,	 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIUFM_SECURITY ! Secure the UFM,
							 			 		SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;	 	
	
	"Slave SPI Display UFM" = "SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPISAVE_ID, 
								SPIFLASH_ENABLE	! Enable the Flash, 
								SPIUFM_SAVE_ARRAY, 
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI UFM Program,Verify" = "SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPICHECK_UFM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPIUFM_ERASE	! Erase the UFM, 
									SPICHECK_STATUS ! Read the status bit,
				 			 		SPIUFM_PROGRAM_STATUS  ! Program the UFM,	
				 			 		SPICHECK_STATUS ! Read the status bit,
									SPIUFM_VERIFY          ! Verify the UFM,
									SPICHECK_STATUS ! Read the status bit,
									SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Verify UFM" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_VERIFY          ! Verify the UFM,
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
		 			 		
	"Slave SPI UFM Erase" = "SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPICHECK_UFM_OTP ! Check the OTP fuses,
							SPICHECK_KEYLOCK ! Check the Key Protection fuses,
							SPIFLASH_ENABLE	! Enable the Flash, 
							SPIUFM_ERASE	! Erase the UFM, 
							SPICHECK_STATUS ! Read the status bit,
		 			 		SPIDISABLE ! Exit the programming mode"	;
		 			 																	 			 				 							 			 		
	"Slave SPI Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Program" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
															
	"Slave SPI Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Background Fast Configuration" = "SPIINIT 	! Initialize,   
								SPIREAD_ID	! Check the IDCODE,
								SPICHECK_SRAM_OTP ! Check the OTP fuses,
								SPICHECK_KEYLOCK ! Check the Key Protection fuses,
								SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								SPISRAM_ERASE	! Erase the SRAM, 
								SPIBURST_PROGRAM	! Program Fuse Map,
								SPIVERIFY_USERCODE		! Verify USERCODE,
								SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI Background SEI Fast Program" 	= "	SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,	
									SPICHECK_SRAM_OTP ! Check the OTP fuses,
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,
									SPI_SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPIBURST_PROGRAM	! Program Fuse Map,	
									SPICHECK_STATUS ! Read the status bit,	
									SPIDISABLE ! Exit the programming mode"	;
		
		
	"Slave SPI RAM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,  
									SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
									SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									SPISRAM_VERIFY	! Verify Fuse Map, 
									SPIVERIFY_USERCODE		! Verify USERCODE, 
				 			 		SPIDISABLE ! Exit the programming mode"	;
				 			 		
				 			 		
	"Slave SPI Check Protect Fuses" =  "SPIINIT 	! Initialize, 
									   SPIREAD_ID	! Check the IDCODE,
									   SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key" ;
	
	
	"Slave SPI Fast Configuration with Password" = "SPIINIT 	! Initialize,   
													SPIREAD_ID	! Check the IDCODE,
													SPICHECK_SRAM_OTP ! Check the OTP fuses,
													SPISRAM_ENABLE	! Enable SRAM programming mode, 
													SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													SPISRAM_ERASE	! Erase the SRAM, 
													SPIBURST_PROGRAM	! Program Fuse Map,
													SPIVERIFY_USERCODE		! Verify USERCODE,
													SPIDISABLE ! Exit the programming mode"	;
																		   				 			 
	"Slave SPI Erase,Program,Verify with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,	
										SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIDISABLE ! Exit the programming mode"	;					 			 						 			 		
													   
	
	"Slave SPI EPVS with Password" = "SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE, 
										SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
										SPIFLASH_ENABLE	! Enable the Flash, 
										SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
										SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										SPIFLASH_ERASE	! Erase the Flash,
										SPICHECK_STATUS ! Read the status bit,
					 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
										SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
										SPIPROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_STATUS ! Read the status bit,
										SPIFLASH_VERIFY	! Verify CFG,
										SPIUFM_VERIFY          ! Verify the UFM,								 
										SPIVERIFY_USERCODE		! Verify USERCODE,
										SPICHECK_STATUS ! Read the status bit,		 			 		
					 			 		SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		SPIPROGRAM_SECURITY ! Secure device,									 			 		
			 			 				SPIDISABLE ! Exit the programming mode"	;
			 			 		
	"Slave SPI Erase Only with Password"	=	"SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE,
												SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
												SPIFLASH_ENABLE	! Enable the programming mode, 
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
												SPIDISABLE ! Exit the programming mode"	;
														
	"Slave SPI Background EPV with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Background EPVS with Password" = "SPIINIT 	! Initialize, 
												SPIREAD_ID	! Check the IDCODE, 
												SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
												SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SPIFLASH_ERASE	! Erase the Flash,
												SPICHECK_STATUS ! Read the status bit,
							 			 		SPIFLASH_PROGRAM_STATUS	! Program CFG,
												SPIUFM_PROGRAM_STATUS  ! Program the UFM,								
												SPIPROGRAM_USERCODE	! Program USERCODE,
												SPICHECK_STATUS ! Read the status bit,
												SPIFLASH_VERIFY	! Verify CFG,
												SPIUFM_VERIFY          ! Verify the UFM,								 
												SPIVERIFY_USERCODE		! Verify USERCODE,
												SPICHECK_STATUS ! Read the status bit,	
												SPIFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												SPIPROGRAM_SECURITY ! Secure device,
							 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;			 			 						 			 					 				 			 					 			 															  
	
	"Slave SPI Background Erase with Password"	=	"SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE,
													SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
													SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  
													SPICHECK_CFG_UFM_OTP ! Check the OTP fuses,
													SPIFLASH_ERASE	! Erase the device, 
													SPICHECK_STATUS ! Read the status bit,
								 			 		SPIBACKGROUND_DISABLE ! Exit the programming mode"	;				 			 		
	
	"Slave SPI Verify Only with Password" = "SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											SVFSPICHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,  													
											SPIFLASH_VERIFY	! Verify the Flash, 
											SPIUFM_VERIFY          ! Verify the UFM,							
											SPIVERIFY_USERCODE	! Verify USERCODE, 
											SPICHECK_STATUS ! Read the status bit, 
											SPIVERIFY_DONE_BIT ! Verify Done Bit,
											SPIBACKGROUND_DISABLE ! Exit the programming mode"	;
																					
		
	"Slave SPI Program Password Key" = "SPIINIT 	! Initialize, 
									  SPIREAD_ID	! Check the IDCODE,
									  SPICHECK_FR_OTP ! Check the OTP fuses,
									  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									  SPIFLASH_ENABLE	! Enable the programming mode,
									  SPIPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
									  SPIDISABLE ! Exit the programming mode" ;	
	
	"Slave SPI Program Password Key with Lock" = "SPIINIT 	! Initialize, 
									  SPIREAD_ID	! Check the IDCODE,
									  SPICHECK_FR_OTP ! Check the OTP fuses,
									  SPICHECK_KEYLOCK ! Check the Key Protection fuses, 
									  SPIFLASH_ENABLE	! Enable the programming mode,
									  SPIPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
									  SPIDISABLE ! Exit the programming mode" ;	
												  
	"Slave SPI Read Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses,  
										SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
					 			 		
	
	"Slave SPI Erase Feature Rows"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_FR_OTP ! Check the OTP fuses,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses, 									
										SPIFLASH_ENABLE	! Enable the programming mode, 	
										SPIFEATURE_ERASE	! Erase the Feature row,
										SPIFLASH_ERASE	! Erase the CFG,  
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	
	"Slave SPI Check Feature Row"	=	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_KEYLOCK ! Check the Key Protection fuses"	;		
										
	"I2C Verify ID" = "	I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE";
	"I2C Display ID" = "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE,
						I2CSAVE_ID";						
	
	"I2C Program Feature Rows" =    "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_FR_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses,  
									I2CFEATURE_ENABLE	! Enable the Flash, 
									I2CFEATURE_SVF_ERASE	! Erase the Feature Rows,
									I2CCHECK_STATUS ! Read the status bit,
									I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
									I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Program Feature Rows" =    "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_FR_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFEATURE_ENABLE	! Enable the Flash, 
									I2CFEATURE_ERASE	! Erase the Feature Rows,
									I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
									I2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	
	"I2C Fast Program" = "I2CINIT 	! Initialize,   
						I2CREAD_ID	! Check the IDCODE,
						I2CCHECK_SRAM_OTP ! Check the OTP fuses,
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 
						I2CSRAM_ERASE	! Erase the SRAM, 
						I2CBURST_PROGRAM	! Program Fuse Map,
						I2CVERIFY_USERCODE		! Verify USERCODE,
						I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Fast Configuration" = "I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_ENABLE	! Enable SRAM programming mode, 
								I2CSRAM_ERASE	! Erase the SRAM, 
								I2CBURST_PROGRAM	! Program Fuse Map,
								I2CVERIFY_USERCODE		! Verify USERCODE,
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Program" = "I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CCHECK_SRAM_OTP ! Check the OTP fuses,
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									I2CSRAM_ERASE	! Erase the SRAM, 
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background Fast Configuration" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CCHECK_SRAM_OTP ! Check the OTP fuses,
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,	
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Background SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_SRAM_OTP ! Check the OTP fuses,
								I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
								I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
								I2CBURST_PROGRAM	! Program Fuse Map,		
								I2CCHECK_STATUS ! Read the status bit,	
								I2CDISABLE ! Exit the programming mode"	;
																						
	"I2C Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Feature,Secure Plus" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CUFM_SECURITY ! Secure the UFM,
											I2CPROGRAM_SECURITY ! Secure device,																						
						 			 		I2CFEATUREDISABLE ! Exit the programming mode"	;
						 			 					 			 					 			 		
	"I2C Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																																				
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,								 
									I2CCHECK_STATUS ! Read the status bit,	
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Program" =   "I2CINIT 	! Initialize, 
						I2CREAD_ID	! Check the IDCODE, 
						I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
						I2CFLASH_ENABLE	! Enable the Flash, 
						I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
						I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
						I2CFLASH_ERASE	! Erase the Flash,
						I2CCHECK_STATUS ! Read the status bit,
	 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
	 			 		I2CPROGRAM_USERCODE	! Program USERCODE,
	 			 		I2CUFM_PROGRAM_STATUS  ! Program the UFM,							
						I2CCHECK_STATUS ! Read the status bit,
						I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
	 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,	
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"I2C Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CCHECK_FLASH_OTP ! Check the OTP fuses,
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Full Erase"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_ENABLE	! Enable the Flash, 
							I2CCHECK_FLASH_OTP ! Check the OTP fuses,
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CDISABLE ! Exit the programming mode"	;
			 			 						 			 								
	"I2C Background Program Feature Rows" =    "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CCHECK_FR_OTP ! Check the OTP fuses,
												I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
												I2CFEATURE_ERASE	! Erase the Feature Rows,
												I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												I2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"I2C Background Erase,Program,Verify,Feature" =   "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											I2CCHECK_STATUS ! Read the status bit,	
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
						 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"I2C Background Erase,Program,Verify" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"I2C Background Program" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,								
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"I2C Background Erase,Program,Verify,Secure" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,  
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,
									I2CCHECK_STATUS ! Read the status bit,								 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"I2C Background Erase,Program,Verify,Secure Plus" =   "I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,									 
									I2CFLASH_ERASE	! Erase the Flash,
									I2CCHECK_STATUS ! Read the status bit,
				 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
									I2CPROGRAM_USERCODE	! Program USERCODE,
									I2CCHECK_STATUS ! Read the status bit,
									I2CVERIFY_USERCODE		! Verify USERCODE,																											
									I2CFLASH_VERIFY	! Verify CFG,
									I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
									I2CUFM_VERIFY          ! Verify the UFM,	
									I2CCHECK_STATUS ! Read the status bit,							 
									I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									I2CUFM_SECURITY ! Secure the UFM,	
									I2CPROGRAM_SECURITY ! Secure device,
				 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"I2C Background Verify Only" = "	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE, 
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
							I2CFEATURE_VERIFY_STATUS ! Verify Feature Rows,							
							I2CFLASH_VERIFY	! Verify the Flash, 
							I2CUFM_VERIFY          ! Verify the UFM,							
							I2CVERIFY_USERCODE	! Verify USERCODE, 
							I2CCHECK_STATUS ! Read the status bit, 
							I2CVERIFY_DONE_BIT ! Verify Done Bit,
							I2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"I2C Background Erase Only"	=	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
							I2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
							I2CFLASH_ERASE	! Erase the Flash,
							I2CCHECK_STATUS ! Read the status bit,
		 			 		I2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	
	"I2C Check Feature Row"	=	"I2CINIT 	! Initialize, 
								 I2CREAD_ID	! Check the IDCODE, 
								 I2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;
	
	"I2C Check Protect Fuses"	=	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key"	;
	
	"I2C Erase Feature Row with Password Key"	=	"I2CINIT 	! Initialize, 
													 I2CREAD_ID	! Check the IDCODE, 
													 I2CCHECK_FR_OTP ! Check the OTP fuses,
													 SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
													 I2CFLASH_ENABLE	! Enable the Flash, 	
													 SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
													 I2CFEATURE_ERASE	! Erase the Feature row, 
													 I2CFLASH_ERASE	! Erase the Flash,
													 I2CCHECK_STATUS ! Read the status bit,
													 I2CDISABLE ! Exit the programming mode"	;
																																																														
	"I2C Program Password Key" = "I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CCHECK_FR_OTP ! Check the OTP fuses,
								  I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  SVFI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  I2CDISABLE ! Exit the programming mode" ;
							  
	"I2C Program Password Key with Lock" = "I2CINIT 	! Initialize, 
								  			I2CREAD_ID	! Check the IDCODE, 
								  			I2CCHECK_FR_OTP ! Check the OTP fuses,
								  			I2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			I2CFLASH_ENABLE	! Enable the Flash, 
											SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode" ;							  	
	
	"I2C EPV with Password Key Option" = 	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	I2CDISABLE ! Exit the programming mode"	;
							 			 		
	"I2C EPVS with Password Key Option" = "I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											I2CFLASH_ENABLE	! Enable the Flash, 
											I2CCHECK_FLASH_OTP ! Check the OTP fuses,
											I2CFLASH_ERASE	! Erase the Flash,
											I2CCHECK_STATUS ! Read the status bit,
						 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
											I2CPROGRAM_USERCODE	! Program USERCODE,
											I2CCHECK_STATUS ! Read the status bit,
											I2CVERIFY_USERCODE		! Verify USERCODE,																																				
											I2CFLASH_VERIFY	! Verify CFG,
											I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											I2CUFM_VERIFY          ! Verify the UFM,
											I2CCHECK_STATUS ! Read the status bit,									 
											I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											I2CPROGRAM_SECURITY ! Secure device,							 			 	
											I2CFEATURE_ERASE	! Erase the Feature Rows,
											I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											I2CDISABLE ! Exit the programming mode"	;
	
	"I2C EPV with my_ASSP, Password Key Option" = 	"I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													I2CFLASH_ENABLE	! Enable the Flash, 
													I2CCHECK_FLASH_OTP ! Check the OTP fuses,
													I2CFLASH_ERASE	! Erase the Flash,
													I2CCHECK_STATUS ! Read the status bit,
								 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
													I2CPROGRAM_USERCODE	! Program USERCODE,
													I2CCHECK_STATUS ! Read the status bit,
													I2CVERIFY_USERCODE		! Verify USERCODE,																																				
													I2CFLASH_VERIFY	! Verify CFG,
													I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													I2CUFM_VERIFY          ! Verify the UFM,
													I2CCHECK_STATUS ! Read the status bit,									 
													I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													I2CFEATURE_ERASE	! Erase the Feature Rows,
													I2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													I2CDISABLE ! Exit the programming mode"	;
																				 							 
	"I2C Erase,Program,Verify with Password" =   "I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
												I2CFLASH_ENABLE	! Enable the Flash, 
												I2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
												SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
												I2CFLASH_ERASE	! Erase the Flash,
												I2CCHECK_STATUS ! Read the status bit,
							 			 		I2CFLASH_PROGRAM_STATUS	! Program CFG,
												I2CPROGRAM_USERCODE	! Program USERCODE,
												I2CCHECK_STATUS ! Read the status bit,
												I2CVERIFY_USERCODE		! Verify USERCODE,																																				
												I2CFLASH_VERIFY	! Verify CFG,
												I2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
												I2CUFM_VERIFY          ! Verify the UFM,								 
												I2CCHECK_STATUS ! Read the status bit,	
												I2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
							 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C Fast Configuration with Password" = "I2CINIT 	! Initialize,   
											I2CREAD_ID	! Check the IDCODE,
											I2CCHECK_SRAM_OTP ! Check the OTP fuses,
											I2CSRAM_ENABLE	! Enable SRAM programming mode, 
											SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
											I2CSRAM_ERASE	! Erase the SRAM, 
											I2CBURST_PROGRAM	! Program Fuse Map,
											I2CVERIFY_USERCODE		! Verify USERCODE,
											I2CDISABLE ! Exit the programming mode"	;
											
	"I2C Verify Only with Password" = "	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_VERIFY	! Verify the Flash, 
										I2CUFM_VERIFY          ! Verify the UFM,							
										I2CVERIFY_USERCODE	! Verify USERCODE, 
										I2CCHECK_STATUS ! Read the status bit, 
										I2CVERIFY_DONE_BIT ! Verify Done Bit,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C Erase Only with Password" =	"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
										I2CFLASH_ENABLE	! Enable the Flash, 
										I2CCHECK_FLASH_OTP ! Check the OTP fuses,
										SVFI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key, 
										I2CFLASH_ERASE	! Erase the Flash,
										I2CCHECK_STATUS ! Read the status bit,
					 			 		I2CDISABLE ! Exit the programming mode"	;
		 			 		
	"I2C Refresh"	=	"I2CINIT 	! Initialize, 
						 I2CREAD_ID	! Check the IDCODE,	
						 I2CREFRESH ! Refresh";	
	
	"PTM Bypass"	=	"SVFINIT 	! Initialize,
						 FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";	
	"PTM Background Bypass"	=	"SVFINIT 	! Initialize,
								 FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";
							 		
	"PTM Verify ID" = 	"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE,
						 FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";  
						 
	"PTM Background Verify ID" = 	"SVFINIT 	! Initialize, 
									 READ_ID ! Check the IDCODE,
									 FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";
						 					 
	"PTM Display ID" = "SVFINIT, SAVE_ID";	
	"PTM Background Display ID" = "SVFINIT, SAVE_ID";	
	
	"PTM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_ENABLE	! Enable the CFG, 
								VERIFY_USERCODE		! Verify USERCODE,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Verify USERCODE"	=	"SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											VERIFY_USERCODE		! Verify USERCODE,
											DISABLE ! Exit the programming mode"	;
												             								 								
	"PTM Display USERCODE"	=	"SVFINIT, 
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
								 FLASH_ENABLE	! Enable the CFG, 
								 SAVE_USERCODE,
								 DISABLE_REFRESH ! Exit the programming mode";
								 
	"PTM Background Display USERCODE"	=	"SVFINIT, 
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
											 SAVE_USERCODE,
											 DISABLE ! Exit the programming mode";
								 								 
	"PTM Disable Only" = "DISABLE ! Exit the programming mode"	;	
	 			 		  
	
	"PTM Background Program Feature Rows"  =    "SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE,
												CHECK_KEYLOCK ! Check the Key Protection fuses,   
												FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
												SVF_FEATURE_ERASE	! Erase the Feature Rows,
												SVF_FEATURE_PROGRAM ! Program Feature Rows,
												DISABLE ! Exit the programming mode"	;
												 			 		  					 
	"PTM Erase,Program,Verify" = "SVF_INIT,
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
								SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
								PROGRAM_USERCODE	! Program USERCODE,
								CHECK_STATUS ! Read the status bit,
								FLASH_VERIFY	! Verify CFG,
								UFM_VERIFY          ! Verify the UFM,								 
								VERIFY_USERCODE		! Verify USERCODE,
								CHECK_STATUS ! Read the status bit,	
								SVF_FEATURE_PROGRAM ! Program Feature Rows,
								CHECK_STATUS ! Read the status bit,		 			 		
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode";			 			 					 			 				 			 			
	
	"PTM Background Erase,Program,Verify,Refresh" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode,
			 			 					REFRESH_FUNCTION ! Refresh";
	
	"PTM Background Program,Verify and TransFR" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,
											CHECK_STATUS ! Read the status bit,	
											PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		DISABLE ! Exit the programming mode,
			 			 					FLASH_MDR ! Transparent Field Reconfiguration";
			 			 							 			 				 			 		
	"PTM Erase,Program,Verify,Secure" = "SVF_INIT,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_STATUS ! Read the status bit,
					 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
										SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										SVF_FEATURE_PROGRAM ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,		 			 		
					 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,			 			 		
					 			 		DISABLE ! Exit the programming mode,
					 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify,Secure" = "SVF_INIT,
										FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
										CHECK_STATUS ! Read the status bit,
					 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
										SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
										PROGRAM_USERCODE	! Program USERCODE,
										CHECK_STATUS ! Read the status bit,
										FLASH_VERIFY	! Verify CFG,
										UFM_VERIFY          ! Verify the UFM,								 
										VERIFY_USERCODE		! Verify USERCODE,
										CHECK_STATUS ! Read the status bit,	
										PROGRAM_DONE_BIT	! Program DONE bit,	
					 			 		PROGRAM_SECURITY ! Secure device,			 			 		
					 			 		DISABLE ! Exit the programming mode";					 			 				 			 		 			 					 			 		
	
	"PTM Erase,Program,Verify,Secure Plus" = "SVF_INIT,
											FLASH_ENABLE	! Enable the Flash,
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,								
											CHECK_STATUS ! Read the status bit,	
											SVF_FEATURE_PROGRAM ! Program Feature Rows,
											CHECK_STATUS ! Read the status bit,		 			 		
						 			 		PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		UFM_SECURITY ! Secure the UFM,											 			 					 			 		
						 			 		PROGRAM_SECURITY ! Secure device,
						 			 		DISABLE ! Exit the programming mode,
						 			 		VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
	
	"PTM Background Erase,Program,Verify,Secure Plus" = "SVF_INIT,
											FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											CHECK_STATUS ! Read the status bit,
						 			 		SVF_FLASH_PROGRAM_STATUS	! Program CFG,
											SVF_UFM_PROGRAM_STATUS  ! Program the UFM,								
											PROGRAM_USERCODE	! Program USERCODE,
											CHECK_STATUS ! Read the status bit,
											FLASH_VERIFY	! Verify CFG,
											UFM_VERIFY          ! Verify the UFM,								 
											VERIFY_USERCODE		! Verify USERCODE,								
											CHECK_STATUS ! Read the status bit,	
											PROGRAM_DONE_BIT	! Program DONE bit,	
						 			 		UFM_SECURITY ! Secure the UFM,											 			 					 			 		
						 			 		PROGRAM_SECURITY ! Secure device,
						 			 		DISABLE ! Exit the programming mode";
						 			 				 			 					 			 		 
	"PTM Program"	=	"	SVF_INIT,
							FLASH_ENABLE	! Enable the Flash,
							CHECK_STATUS ! Read the status bit,
							SVF_FLASH_PROGRAM_STATUS	! Program CFG,
							SVF_UFM_PROGRAM_STATUS  ! Program UFM,							
							PROGRAM_USERCODE	! Program USERCODE,
							CHECK_STATUS ! Read the status bit,	
							SVF_FEATURE_PROGRAM ! Program Feature Rows,		 			 		
			 			 	PROGRAM_DONE_BIT	! Program DONE bit,								
							DISABLE ! Exit the programming mode";
	
	"PTM Background Program"	=	"SVF_INIT,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									CHECK_STATUS ! Read the status bit,
									SVF_FLASH_PROGRAM_STATUS	! Program CFG,
									SVF_UFM_PROGRAM_STATUS  ! Program UFM,							
									PROGRAM_USERCODE	! Program USERCODE,
									CHECK_STATUS ! Read the status bit,	
									PROGRAM_DONE_BIT	! Program DONE bit,								
									DISABLE ! Exit the programming mode";														
															
	"PTM Verify Only" =	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses,   
							FLASH_ENABLE	! Enable the Flash, 
							FLASH_VERIFY	! Verify the Flash, 
							UFM_VERIFY          ! Verify the UFM,							
							VERIFY_USERCODE	! Verify USERCODE, 
							CHECK_STATUS ! Read the status bit, 
							FEATURE_VERIFY_STATUS ! Verify Feature Rows,
							CHECK_STATUS ! Read the status bit,
							VERIFY_DONE_BIT ! Verify Done Bit,
							DISABLE ! Exit the programming mode,
							FPGA_TRANSPARENT_ENABLE	! Enable XPROGRAM mode";
	
	"PTM Background Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									CHECK_KEYLOCK ! Check the Key Protection fuses,   
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									FEATURE_VERIFY_STATUS ! Verify Feature Rows,
									FLASH_VERIFY	! Verify the Flash, 
									UFM_VERIFY          ! Verify the UFM,							
									VERIFY_USERCODE	! Verify USERCODE, 
									CHECK_STATUS ! Read the status bit, 
									VERIFY_DONE_BIT ! Verify Done Bit,
									DISABLE ! Exit the programming mode";								
								 			 			
	"PTM Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 																			
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							SVF_DIRECT_FLASH_ERASE	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";
	
	"PTM Background Erase Only"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							FEATURE_VERIFY_STATUS ! Verify Feature Rows, 
							SVF_FLASH_ERASE_NO_FEA	! Erase the Flash,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode";			 			 																 			 			 			 								 
	
	"PTM UFM Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 									
								FLASH_ENABLE	! Enable the Flash, 
								SVF_UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background UFM Program,Verify" = "SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								CHECK_UFM_OTP ! Check the OTP fuses,
								CHECK_KEYLOCK ! Check the Key Protection fuses, 									
								FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
								SVF_UFM_ERASE	! Erase the UFM, 
								CHECK_STATUS ! Read the status bit,
			 			 		SVF_UFM_PROGRAM_STATUS  ! Program the UFM,
			 			 		CHECK_STATUS ! Read the status bit,
								UFM_VERIFY          ! Verify the UFM,
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;
								
	"PTM Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_ENABLE	! Enable the Flash, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE_REFRESH ! Exit the programming mode"	;
		 			 		
	"PTM Background Verify UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							UFM_VERIFY          ! Verify the UFM,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			 			 		
	"PTM UFM Erase" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						CHECK_UFM_OTP ! Check the OTP fuses,
						CHECK_KEYLOCK ! Check the Key Protection fuses, 									
						FLASH_ENABLE	! Enable the Flash, 
						UFM_ERASE	! Erase the UFM, 
						CHECK_STATUS ! Read the status bit,
	 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background UFM Erase" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE, 
						CHECK_UFM_OTP ! Check the OTP fuses,
						CHECK_KEYLOCK ! Check the Key Protection fuses, 									
						FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
						SVF_UFM_ERASE	! Erase the UFM, 
						CHECK_STATUS ! Read the status bit,
	 			 		DISABLE ! Exit the programming mode"	;
	 			 				 			 		
	"PTM Display UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash, 
							UFM_SAVE_ARRAY, 
							DISABLE_REFRESH ! Exit the programming mode"	;
	
	"PTM Background Display UFM" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							UFM_SAVE_ARRAY, 
							DISABLE ! Exit the programming mode"	;
													
	"PTM Secure Device" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							PROGRAM_SECURITY ! Secure device,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Background Secure Device" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							PROGRAM_SECURITY ! Secure device,
		 			 		CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
	
	"PTM Secure Plus" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							IO_STATE ! Program Bscan register,
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_ENABLE	! Enable the Flash, 
							CHECK_FLASH_OTP ! Check the OTP fuses,
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
		 			 			 			 			 			 		
	"PTM Background Secure Plus" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							CHECK_KEYLOCK ! Check the Key Protection fuses, 									
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
							CHECK_CFG_UFM_OTP ! Check the OTP fuses,
							UFM_SECURITY ! Secure the UFM,			 			 		
							PROGRAM_SECURITY ! Secure device,
							CHECK_STATUS ! Read the status bit,
		 			 		DISABLE ! Exit the programming mode"	;
			 			 		
	"PTM Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_ENABLE,
					 			 SAVE_STATUS,
					 			 DISABLE_REFRESH";
	
	"PTM Background Read Status Register" = "SVFINIT ! Initialize,
					 			 READ_ID	! Check the IDCODE,
					 			 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 
					 			 SAVE_STATUS,
					 			 DISABLE";
					 			 					 			 					 			 									 						 						 				 			 					 			 
	"PTM Capture Only" = "SVFINIT 	! Initialize,
						  READ_ID	! Check the IDCODE,
						  IO_STATE ! Capture Bscan register"	;		
						  			 			 							 
	"PTM Upload to Static RAM" = "SVFINIT !Initialize,
								  READ_ID !Check the IDCODE,
								  UPLOAD_FUNCTION ! Uploaded";
						
	"PTM Refresh" = " 	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						REFRESH_FUNCTION ! Refresh";
	
	"PTM Background Refresh" = " 	SVFINIT 	! Initialize,
						  			READ_ID	! Check the IDCODE,
									REFRESH_FUNCTION ! Refresh";
						
	"ASC Erase,Program,Verify" =	"ASC_SVF_INIT 	! Initialize, 
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS_SVF ! Read the status,
				 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
									 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
									 ASCCHECK_STATUS_SVF ! Read the status bit,
									 ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
									 ASC_VERIFY_SVF	! Verify ASC CFG,
									 ASCCHECK_STATUS_SVF ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
									 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	
	"ASC Background Erase,Program,Verify" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
											 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
											 ASCREAD_ID_SVF	! Check the IDCODE,	
											 ASC_ENABLE_SVF	! Enable the ASC, 
											 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
											 ASCCHECK_STATUS_SVF ! Read the status,
						 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
											 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
											 ASCCHECK_STATUS_SVF ! Read the status bit,
											 ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
											 ASC_VERIFY_SVF	! Verify ASC CFG,
											 ASCCHECK_STATUS_SVF ! Read the status bit,	
											 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
											 ASC_EXIT_USERMODE_BACKGROUND_SVF ! Exit the programming mode"	;
									 
									 
	"ASC Erase,Program,Verify,I2CSA" =	"ASC_SVF_INIT 	! Initialize, 
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS_SVF ! Read the status,
				 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
									 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
									 ASCCHECK_STATUS_SVF ! Read the status bit,
									 ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
									 ASC_VERIFY_SVF	! Verify ASC CFG,
									 ASCCHECK_STATUS_SVF ! Read the status bit,	
									 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
									 ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
									 ASC_PROGRAM_I2CSA_SVF ! Program I2CSA,
									 ASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
	
	"ASC Background Erase,Program,Verify,I2CSA" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
											 		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
													 ASCREAD_ID_SVF	! Check the IDCODE,	
											 		 ASC_ENABLE_SVF	! Enable the ASC, 
													 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
													 ASCCHECK_STATUS_SVF ! Read the status,
								 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
													 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
													 ASCCHECK_STATUS_SVF ! Read the status bit,
													 ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
													 ASC_VERIFY_SVF	! Verify ASC CFG,
													 ASCCHECK_STATUS_SVF ! Read the status bit,	
													 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
													 ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
													 ASC_PROGRAM_I2CSA_SVF ! Program I2CSA,
													 ASC_EXIT_USERMODE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
									 
									 								 
	"ASC I2CSA Program" =	"ASC_SVF_INIT 	! Initialize, 
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
									 ASC_PROGRAM_I2CSA_SVF ! Program I2CSA,
									 ASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
	
	"ASC Background I2CSA Program" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
										 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
									     ASCREAD_ID_SVF	! Check the IDCODE,	
										 ASC_ENABLE_SVF	! Enable the ASC, 
									     ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
									     ASC_PROGRAM_I2CSA_SVF ! Program I2CSA,
									     ASC_EXIT_USERMODE_WITH_NEW_ADDR_SVF ! Exit the programming mode"	;
									 
	"ASC I2CSA Erase Only" =	"ASC_SVF_INIT 	! Initialize, 
								 ASCREAD_ID_SVF	! Check the IDCODE,	
								 ASC_ENABLE_SVF	! Enable the ASC, 
								 ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
								 ASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
	
	"ASC Background I2CSA Erase Only" =	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
										 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
										 ASCREAD_ID_SVF	! Check the IDCODE,	
										 ASC_ENABLE_SVF	! Enable the ASC, 
										 ASC_ERASE_I2CSA_SVF ! Erase the I2CSA,
										 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
							 								 			 			 		 	
	"ASC Program" =	 	"ASC_SVF_INIT 	! Initialize, 
						 ASCREAD_ID_SVF	! Check the IDCODE,	
						 ASC_ENABLE_SVF	! Enable the ASC, 
						 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
						 ASCCHECK_STATUS_SVF ! Read the status,
	 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
						 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
						 ASCCHECK_STATUS_SVF ! Read the status bit,
						 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
						 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	 
	 "ASC Background Program" =	 	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
									 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
									 ASCREAD_ID_SVF	! Check the IDCODE,	
									 ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
									 ASCCHECK_STATUS_SVF ! Read the status,
				 			 		 ASC_PROGRAM_STATUS_SVF	! Program CFG,
									 ASCPROGRAM_USERCODE_SVF	! Program USERCODE,
									 ASCCHECK_STATUS_SVF ! Read the status bit,
									 ASC_PROGRAM_DONE_BIT_SVF	! Program CFG DONE bit,	
									 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
						 
						 			 		 
	"ASC Erase Only" = "ASC_SVF_INIT 	! Initialize, 
						 ASCREAD_ID_SVF	! Check the IDCODE,	
						 ASC_ENABLE_SVF	! Enable the ASC, 
						 ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
						 ASCCHECK_STATUS_SVF ! Read the status,
	 			 		 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	
	"ASC Background Erase Only" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								   ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
								   ASCREAD_ID_SVF	! Check the IDCODE,	
								   ASC_ENABLE_SVF	! Enable the ASC, 
								   ASC_ERASE_BECFG_SVF	! Erase the ASC CFG,									 
								   ASCCHECK_STATUS_SVF ! Read the status,
			 			 		   ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"ASC Verify Only" = "ASC_SVF_INIT 	! Initialize, 
						 ASCREAD_ID_SVF	! Check the IDCODE,	
						 ASC_ENABLE_SVF	! Enable the ASC, 
						 ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
						 ASC_VERIFY_SVF	! Verify ASC CFG,
						 ASCCHECK_STATUS_SVF ! Read the status bit,	
						 ASC_DIRECT_DISABLE_SVF ! Exit the programming mode"	;
	
	"ASC Background Verify Only" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								    ASC_CHECK_MUTEX_SVF ! Check the Mutex,
									ASCREAD_ID_SVF	! Check the IDCODE,	
								    ASC_ENABLE_SVF	! Enable the ASC, 
									ASCVERIFY_USERCODE_SVF		! Verify USERCODE,																																				
									ASC_VERIFY_SVF	! Verify ASC CFG,
									ASCCHECK_STATUS_SVF ! Read the status bit,	
									ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
							 						 
	"ASC Read Status Register" = "ASC_SVF_INIT 	! Initialize, 
							     ASCREAD_ID_SVF	! Check the IDCODE,	
							     ASC_SAVE_STATUS_SVF,
								 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read Status Register" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								    		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								     		 ASCREAD_ID_SVF	! Check the IDCODE,	
								    		 ASC_SAVE_STATUS_SVF,
									 		 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
									 								 
	"ASC Verify ID" = "ASC_SVF_INIT 	! Initialize, 
					     ASCREAD_ID_SVF	! Check the IDCODE";
					     
	"ASC Background Verify ID" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
					              ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								  ASCREAD_ID_SVF	! Check the IDCODE,
					              ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
					     					     
	"ASC Display ID" = "ASC_SVF_INIT 	! Initialize, 
					     ASCSAVE_ID_SVF";					     									 							 								 							 			 																													  
	
	"ASC Background Display ID" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
					     		   ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								   ASCSAVE_ID_SVF,
					     		   ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";	
					     
	"ASC Refresh" = 		"ASC_SVF_INIT 	! Initialize, 
							 ASCREAD_ID_SVF	! Check the IDCODE,	
							 ASC_REFRESH	! Refresh"	;
	
	"ASC Background Refresh" = 		"ASC_BACKGROUND_SVF_INIT 	! Initialize,
								     ASC_CHECK_MUTEX_SVF ! Check the Mutex,
							 		 ASCREAD_ID_SVF	! Check the IDCODE,	
								     ASC_REFRESH	! Refresh,
							 		 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;
							 						 
	"ASC Read Shadow Registers" = "ASC_SVF_INIT 	! Initialize, 
								   ASCREAD_ID_SVF	! Check the IDCODE,	
								   ASC_READ_SHADOW_REGISTERS_SVF	! Read ASC Shadow"	;

	"ASC Background Read Shadow Registers" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								     		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								   			 ASCREAD_ID_SVF	! Check the IDCODE,	
								     		 ASC_READ_SHADOW_REGISTERS_SVF	! Read ASC Shadow,
								   			 ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode"	;

	"ASC Read FaultLog Registers" = "ASC_SVF_INIT 	! Initialize, 
									     ASCREAD_ID_SVF	! Check the IDCODE,	
									     ASC_ENABLE_SVF	! Enable the ASC, 
										 ASC_SAVE_FAULTLOG_REGISTERS_SVF,
										 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Registers" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								     		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,	
									         ASCREAD_ID_SVF	! Check the IDCODE,	
								     		 ASC_ENABLE_SVF	! Enable the ASC, 
										     ASC_SAVE_FAULTLOG_REGISTERS_SVF,
										     ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
										 
	"ASC Read FaultLog Memory" = "ASC_SVF_INIT 	! Initialize, 
								     ASCREAD_ID_SVF	! Check the IDCODE,
								     ASC_ENABLE_SVF	! Enable the ASC, 
									 ASC_SAVE_FAULTLOG_MEMORY_SVF,
									 ASC_EXIT_USERMODE ! Exit the programming mode";
	
	"ASC Background Read FaultLog Memory" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								     		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								             ASCREAD_ID_SVF	! Check the IDCODE,	
								     		 ASC_ENABLE_SVF	! Enable the ASC, 
									         ASC_SAVE_FAULTLOG_MEMORY_SVF,
									         ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
	
	"ASC FaultLog Erase Only" = "ASC_SVF_INIT 	! Initialize, 
							     ASCREAD_ID_SVF	! Check the IDCODE,
							     ASC_ENABLE_SVF	! Enable the ASC, 
								 ASC_ERASE_FAULTLOG_MEMORY,
								 ASC_EXIT_USERMODE ! Exit the programming mode";
								 								 	 			 		
	"ASC Read and Save" = "ASC_SVF_INIT 	! Initialize, 
						     ASCREAD_ID_SVF	! Check the IDCODE,
						     ASC_ENABLE	! Enable the ASC, 
							 ASC_SAVE	! Read ASC CFG,
							 ASCSAVE_USERCODE		! Read USERCODE,																																											 
							 ASC_EXIT_USERMODE ! Exit the programming mode";
			 			 								 						 			 								 			 		
	"ASC Background Read and Save" = "ASC_BACKGROUND_SVF_INIT 	! Initialize,
								      ASC_CHECK_MUTEX_SVF ! Check the Mutex,
						              ASCREAD_ID_SVF	! Check the IDCODE,	
								      ASC_ENABLE	! Enable the ASC, 
							          ASC_SAVE	! Read ASC CFG,
							          ASCSAVE_USERCODE		! Read USERCODE,																																											 
							          ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
							 
	"ASC Calculate Data CRC"	=	"ASC_SVF_INIT 	! Initialize, 
						     		 ASCREAD_ID_SVF	! Check the IDCODE,	
						     		 ASC_ENABLE	! Enable the ASC, 
								     ASC_SAVE,
								     ASC_EXIT_USERMODE ! Exit the programming mode";	
	
	"ASC Background Calculate Data CRC"	=	"ASC_BACKGROUND_SVF_INIT 	! Initialize,
								      		 ASC_CHECK_MUTEX_SVF ! Check the Mutex,
								     		 ASCREAD_ID_SVF	! Check the IDCODE,	
								             ASC_ENABLE	! Enable the ASC, 
										     ASC_SAVE,
										     ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF ! Exit the programming mode";
	


	"JTAGI2C Verify ID" = "JTAGI2CINIT_SVF 	! Initialize, 
						   JTAGI2CREAD_ID	! Check the IDCODE";
	"JTAGI2C Display ID" = "JTAGI2CINIT_SVF 	! Initialize, 
						JTAGI2CREAD_ID	! Check the IDCODE,
						JTAGI2CSAVE_ID";						
	
	"JTAGI2C Program Feature Rows" =    "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFEATURE_ENABLE	! Enable the Flash, 
									JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
									JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
									JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
				 			 		
	"JTAGI2C Read Feature Rows"	=	"JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CFEATURE_SAVE_ARRAY	! Read the Feature row, 
									 JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C Display USERCODE"	=	"JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Read Status Register" = "JTAGI2CINIT_SVF 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CFLASH_ENABLE	! Enable the Flash, 
					 			 	 JTAGI2C_SAVE_STATUS,
					 			 	 JTAGI2CDISABLE ! Exit the programming mode";
	
	"JTAGI2C Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Fast Configuration" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C Background Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Fast Configuration" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  
	"JTAGI2C SEI Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background SEI Fast Program" = "JTAGI2CINIT_SVF 	! Initialize,   
							  JTAGI2CREAD_ID	! Check the IDCODE,
							  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
							  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							  JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM programming mode, 
							  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
							  JTAGI2CCHECK_STATUS ! Read the status bit,
							  JTAGI2CDISABLE ! Exit the programming mode"	;
							  						  						  				 			 								
	"JTAGI2C Erase,Program,Verify,Feature" =   "JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																						
						 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Feature,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
												JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,		
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C Erase,Program,Verify,Feature,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
												JTAGI2CFLASH_ENABLE	! Enable the Flash, 
												JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
												JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
												JTAGI2CCHECK_STATUS ! Read the status bit,
							 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
												JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
												JTAGI2CCHECK_STATUS ! Read the status bit,
												JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
												JTAGI2CFLASH_VERIFY	! Verify CFG,
												JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
												JTAGI2CUFM_VERIFY          ! Verify the UFM,
												JTAGI2CCHECK_STATUS ! Read the status bit,									 
												JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,		
												JTAGI2CUFM_SECURITY ! Secure the UFM,	
												JTAGI2CPROGRAM_SECURITY ! Secure device,																						
							 			 		JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
							 			 					 			 					 			 		
	"JTAGI2C Erase,Program,Verify" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
									JTAGI2CCHECK_STATUS ! Read the status bit,	
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program" =   "JTAGI2CINIT_SVF 	! Initialize, 
						JTAGI2CREAD_ID	! Check the IDCODE, 
						JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
						JTAGI2CFLASH_ENABLE	! Enable the Flash, 
						JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
						JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
						JTAGI2CCHECK_STATUS ! Read the status bit,
	 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
	 			 		JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
	 			 		JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,							
						JTAGI2CCHECK_STATUS ! Read the status bit,
						JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
	 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase,Program,Verify,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,
									JTAGI2CCHECK_STATUS ! Read the status bit,								 
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									JTAGI2CPROGRAM_SECURITY ! Secure device,
				 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,
									JTAGI2CCHECK_STATUS ! Read the status bit,								 
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									JTAGI2CUFM_SECURITY ! Secure the UFM,	
									JTAGI2CPROGRAM_SECURITY ! Secure device,
				 			 		JTAGI2CDISABLE ! Exit the programming mode"	;			 			 		
				 			 		
	"JTAGI2C Verify Only" = "JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							JTAGI2CFLASH_ENABLE	! Enable the Flash,
							JTAGI2CFLASH_VERIFY	! Verify the Flash,
							JTAGI2CUFM_VERIFY          ! Verify the UFM,
							JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
							JTAGI2CCHECK_STATUS ! Read the status bit, 
							JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
							JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
							JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
							JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Full Erase"	=	"JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							JTAGI2CFLASH_ENABLE	! Enable the Flash, 
							JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
							JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
							JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
		 			 		
	"JTAGI2C Recovery Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
										JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
										JTAGI2CCHECK_STATUS ! Read the status bit,
					 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
					 			 				 			 						 			 								
	"JTAGI2C Background Program Feature Rows" =    "JTAGI2CINIT_SVF 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
												JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
												JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
												JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
												JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;
									
	
	"JTAGI2C Background Erase,Program,Verify,Feature" =   "JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,
											JTAGI2CCHECK_STATUS ! Read the status bit,	
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,												
						 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
						 			 										
	"JTAGI2C Background Erase,Program,Verify" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,
									JTAGI2CCHECK_STATUS ! Read the status bit,								 
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
	
	"JTAGI2C Background Program" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,								
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
				 			 					 			 		
	"JTAGI2C Background Erase,Program,Verify,Secure" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses, 
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,
									JTAGI2CCHECK_STATUS ! Read the status bit,								 
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									JTAGI2CPROGRAM_SECURITY ! Secure device,
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;

	"JTAGI2C Background Erase,Program,Verify,Secure Plus" =   "JTAGI2CINIT_SVF 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
									JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
									JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
									JTAGI2CCHECK_STATUS ! Read the status bit,
				 			 		JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
									JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																											
									JTAGI2CFLASH_VERIFY	! Verify CFG,
									JTAGI2CUFM_SVF_PROGRAM_STATUS  ! Program the UFM,																																																					
									JTAGI2CUFM_VERIFY          ! Verify the UFM,	
									JTAGI2CCHECK_STATUS ! Read the status bit,							 
									JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,
									JTAGI2CUFM_SECURITY ! Secure the UFM,	
									JTAGI2CPROGRAM_SECURITY ! Secure device,
				 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;					 			 		
	
	"JTAGI2C Background Verify Only" = "JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE, 
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash,
							JTAGI2CFLASH_VERIFY	! Verify the Flash, 
							JTAGI2CUFM_VERIFY          ! Verify the UFM,							
							JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 
							JTAGI2CCHECK_STATUS ! Read the status bit, 
							JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
							JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;	
							
	"JTAGI2C Background Erase Only"	=	"JTAGI2CINIT_SVF 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
							JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Background Flash, 
							JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
							JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
							JTAGI2CCHECK_STATUS ! Read the status bit,
		 			 		JTAGI2CBACKGROUND_DISABLE ! Exit the programming mode"	;
		 			 		
	"JTAGI2C Refresh"	=	"JTAGI2CINIT_SVF 	! Initialize, 
						 JTAGI2CREAD_ID	! Check the IDCODE,	
						 JTAGI2CREFRESH ! Refresh";	
						 
	
	"JTAGI2C Check Feature Row"	=	"JTAGI2CINIT 	! Initialize, 
									 JTAGI2CREAD_ID	! Check the IDCODE,
									 JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses"	;
	
	"JTAGI2C Check Protect Fuses"	=	"JTAGI2CINIT_SVF 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key"	;
	
	"JTAGI2C Erase Feature Row with Password Key"	=	"JTAGI2CINIT 	! Initialize, 
													 JTAGI2CREAD_ID	! Check the IDCODE, 
													 JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
													 SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key, 
													 JTAGI2CFLASH_ENABLE	! Enable the Flash, 	
													 JTAGI2CFEATURE_ERASE	! Erase the Feature row, 
													 JTAGI2CFLASH_ERASE	! Erase the Flash,
													 JTAGI2CCHECK_STATUS ! Read the status bit,
													 JTAGI2CDISABLE ! Exit the programming mode"	;
																																																														
	"JTAGI2C Program Password Key" = "JTAGI2CINIT 	! Initialize, 
								  JTAGI2CREAD_ID	! Check the IDCODE, 
								  JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
								  JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
								  SVFJTAGI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK ! Program the Protection Key,
								  JTAGI2CDISABLE ! Exit the programming mode" ;
							  
	"JTAGI2C Program Password Key with Lock" = "JTAGI2CINIT 	! Initialize, 
								  			JTAGI2CREAD_ID	! Check the IDCODE, 
								  			JTAGI2CCHECK_FR_OTP ! Check the OTP fuses,
								  			JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses,   
								  			JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											SVFJTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode" ;							  	
	
	"JTAGI2C EPV with Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFJTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
							 			 	JTAGI2CDISABLE ! Exit the programming mode"	;
							 			 		
	"JTAGI2C EPVS with Password Key Option" = "JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
											JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
											JTAGI2CFLASH_VERIFY	! Verify CFG,
											JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CCHECK_STATUS ! Read the status bit,									 
											JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
											JTAGI2CPROGRAM_SECURITY ! Secure device,							 			 	
											JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
											JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
											SVFJTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
											JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"JTAGI2C EPV with my_ASSP, Password Key Option" = 	"JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CCHECK_KEYLOCK ! Check the Key Protection fuses, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash, 
													JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
													JTAGI2CFLASH_ERASE	! Erase the Flash,
													JTAGI2CCHECK_STATUS ! Read the status bit,
								 			 		JTAGI2CFLASH_PROGRAM_STATUS	! Program CFG,
													JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
													JTAGI2CCHECK_STATUS ! Read the status bit,
													JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
													JTAGI2CFLASH_VERIFY	! Verify CFG,
													JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
													JTAGI2CUFM_VERIFY          ! Verify the UFM,
													JTAGI2CCHECK_STATUS ! Read the status bit,									 
													JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
													JTAGI2CFEATURE_ERASE	! Erase the Feature Rows,
													JTAGI2CFEATURE_PROGRAM_STATUS ! Program Feature Rows,																												 			 		
													SVFJTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK ! Program the Protection Key,
													JTAGI2CDISABLE ! Exit the programming mode"	;	
																												 
	"JTAGI2C Erase,Program,Verify with Password" =   "JTAGI2CINIT_SVF 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											         	JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											         	JTAGI2CCHECK_CFG_UFM_OTP ! Check the OTP fuses,
														JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
														JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 					JTAGI2CFLASH_SVF_PROGRAM_STATUS	! Program CFG,
														JTAGI2CPROGRAM_USERCODE	! Program USERCODE,
														JTAGI2CCHECK_STATUS ! Read the status bit,
														JTAGI2CVERIFY_USERCODE		! Verify USERCODE,																																				
														JTAGI2CFLASH_VERIFY	! Verify CFG,
														JTAGI2CUFM_PROGRAM_STATUS  ! Program the UFM,																																																					
														JTAGI2CUFM_VERIFY          ! Verify the UFM,								 
														JTAGI2CCHECK_STATUS ! Read the status bit,	
														JTAGI2CFLASH_PROGRAM_DONE_BIT	! Program DONE bit,	
									 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
									 			 		
	"JTAGI2C Fast Configuration with Password" = "JTAGI2CINIT_SVF 	! Initialize,   
													  JTAGI2CREAD_ID	! Check the IDCODE,
													  JTAGI2CCHECK_SRAM_OTP ! Check the OTP fuses,
													  JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
													  SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY ! Verify the Protection Key,
													  JTAGI2CSRAM_ERASE	! Erase the SRAM, 
													  JTAGI2CBURST_PROGRAM	! Program Fuse Map,
													  JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
													  JTAGI2CDISABLE ! Exit the programming mode"	;
													  
	"JTAGI2C Verify Only with Password" = "JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CFLASH_VERIFY	! Verify the Flash,
											JTAGI2CUFM_VERIFY          ! Verify the UFM,
											JTAGI2CVERIFY_USERCODE	! Verify USERCODE, 							 																		 
											JTAGI2CCHECK_STATUS ! Read the status bit, 
											JTAGI2CVERIFY_DONE_BIT ! Verify Done Bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C Erase Only with Password" =	"JTAGI2CINIT_SVF 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE ! Verify the Protection Key,
										    JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											JTAGI2CCHECK_FLASH_OTP ! Check the OTP fuses,
											JTAGI2CFLASH_SVF_ERASE	! Erase the Flash,
											JTAGI2CCHECK_STATUS ! Read the status bit,
						 			 		JTAGI2CDISABLE ! Exit the programming mode"	;
						 			 		
	"I2CASC Erase,Program,Verify" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
									 
	"I2CASC Erase,Program,Verify,I2CSA" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background Erase,Program,Verify,I2CSA" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
									 I2CASC_VERIFY_SVF	! Verify ASC CFG,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 
	"I2CASC I2CSA Program" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Program" =	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
									 I2CASC_PROGRAM_I2CSA ! Program I2CSA,
									 I2CASC_EXIT_USERMODE_WITH_NEW_ADDR ! Exit the programming mode"	;
									 								 			 			 		 	
	"I2CASC I2CSA Erase Only" =	"I2CASC_SVF_INIT 	! Initialize, 
								 I2CASCREAD_ID_SVF	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	"I2CASC Background I2CSA Erase Only" =	"I2CASC_SVF_INIT 	! Initialize, 
								 I2CASCREAD_ID_SVF	! Check the IDCODE,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_I2CSA ! Erase the I2CSA,
								 I2CASC_EXIT_USERMODE_WITH_DEFAULT_ADDR ! Exit the programming mode"	;
	
	
	"I2CASC Program" =	 	"I2CASC_SVF_INIT 	! Initialize, 
						 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						 I2CASC_ENABLE	! Enable the ASC, 
						 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
						 I2CASC_PROGRAM_STATUS	! Program CFG,
						 I2CASCPROGRAM_USERCODE	! Program USERCODE,
						 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
						 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Program" =	 	"I2CASC_SVF_INIT 	! Initialize, 
									 I2CASCREAD_ID_SVF	! Check the IDCODE,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
									 I2CASC_PROGRAM_STATUS	! Program CFG,
									 I2CASCPROGRAM_USERCODE	! Program USERCODE,
									 I2CASC_PROGRAM_DONE_BIT	! Program CFG DONE bit,	
									 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
						 			 		 
	"I2CASC Erase Only" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
	
	"I2CASC Background Erase Only" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASC_ERASE_BECFG	! Erase the ASC CFG,									 
							 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
		 			 		 			 			 		 			
	"I2CASC Verify Only" = 	"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 I2CASC_VERIFY_SVF	! Verify ASC CFG,
							 I2CASC_DIRECT_DISABLE ! Exit the programming mode"	;
							 
	"I2CASC Background Verify Only" = 	"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCVERIFY_USERCODE		! Verify USERCODE,																																				
							 I2CASC_VERIFY_SVF	! Verify ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode"	;
							 							 
	"I2CASC Read Status Register" = 	"I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,	
								     I2CASCSAVE_ID	,	
									 I2CASC_SAVE_STATUS";
	"I2CASC Background Read Status Register" = 	"I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,	
								     I2CASCSAVE_ID	,	
									 I2CASC_SAVE_STATUS";
									 									 
	"I2CASC Verify ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF	! Check the IDCODE";
	"I2CASC Background Verify ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF	! Check the IDCODE";
					     					     
	"I2CASC Display ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF";					     									 							 								 							 			 																													  
	
	"I2CASC Background Display ID" = "I2CASC_SVF_INIT 	! Initialize, 
					     I2CASCREAD_ID_SVF";	
					     
	"I2CASC Refresh" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_REFRESH	! Refresh"	;
	
	"I2CASC Background Refresh" = 		"I2CASC_SVF_INIT 	! Initialize, 
							 I2CASCREAD_ID_SVF	! Check the IDCODE,	
							 I2CASC_REFRESH	! Refresh"	;
							 
	"I2CASC Read Shadow Registers" = "I2CASC_SVF_INIT 	! Initialize, 
								   I2CASCREAD_ID_SVF	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;

	"I2CASC Background Read Shadow Registers" = "I2CASC_SVF_INIT 	! Initialize, 
								   I2CASCREAD_ID_SVF	! Check the IDCODE,	
								   I2CASCSAVE_ID,
								   I2CASC_READ_SHADOW_REGISTERS	! Read ASC Shadow"	;
								   
	"I2CASC Read FaultLog Registers" = "I2CASC_SVF_INIT 	! Initialize, 
									     I2CASCREAD_ID_SVF	! Check the IDCODE,	
									     I2CASCSAVE_ID,
										 I2CASC_ENABLE	! Enable the ASC, 
										 I2CASC_SAVE_FAULTLOG_REGISTERS,
										 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Registers" = "I2CASC_SVF_INIT 	! Initialize, 
									     I2CASCREAD_ID_SVF	! Check the IDCODE,	
									     I2CASCSAVE_ID,
										 I2CASC_ENABLE	! Enable the ASC, 
										 I2CASC_SAVE_FAULTLOG_REGISTERS,
										 I2CASC_EXIT_USERMODE ! Exit the programming mode";
										 
	"I2CASC Read FaultLog Memory" = "I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,
								     I2CASCSAVE_ID,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_MEMORY,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read FaultLog Memory" = "I2CASC_SVF_INIT 	! Initialize, 
								     I2CASCREAD_ID_SVF	! Check the IDCODE,
								     I2CASCSAVE_ID,	
									 I2CASC_ENABLE	! Enable the ASC, 
									 I2CASC_SAVE_FAULTLOG_MEMORY,
									 I2CASC_EXIT_USERMODE ! Exit the programming mode";
									 
	"I2CASC FaultLog Erase Only" = "I2CASC_SVF_INIT 	! Initialize, 
							     I2CASCREAD_ID_SVF	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background FaultLog Erase Only" = "I2CASC_SVF_INIT 	! Initialize, 
							     I2CASCREAD_ID_SVF	! Check the IDCODE,
							     I2CASCSAVE_ID,	
								 I2CASC_ENABLE	! Enable the ASC, 
								 I2CASC_ERASE_FAULTLOG_MEMORY,
								 I2CASC_EXIT_USERMODE ! Exit the programming mode";
								 							 
	"I2CASC Read and Save" = "I2CASC_SVF_INIT 	! Initialize, 
						     I2CASCREAD_ID_SVF	! Check the IDCODE,
						     I2CASCSAVE_ID,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCSAVE_USERCODE		! Read USERCODE,																																											 
							 I2CASC_SAVE	! Read ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Read and Save" = "I2CASC_SVF_INIT 	! Initialize, 
						     I2CASCREAD_ID_SVF	! Check the IDCODE,
						     I2CASCSAVE_ID,	
							 I2CASC_ENABLE	! Enable the ASC, 
							 I2CASCSAVE_USERCODE		! Read USERCODE,																																											 
							 I2CASC_SAVE	! Read ASC CFG,
							 I2CASC_EXIT_USERMODE ! Exit the programming mode";		 			 								 						 			 								 			 		
	
	"I2CASC Calculate Data CRC"	=	"I2CASC_SVF_INIT 	! Initialize, 
						     		 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						     		 I2CASCSAVE_ID,
						     		 I2CASC_ENABLE	! Enable the ASC, 
								     I2CASC_SAVE,
								     I2CASC_EXIT_USERMODE ! Exit the programming mode";
	
	"I2CASC Background Calculate Data CRC"	=	"I2CASC_SVF_INIT 	! Initialize, 
						     		 I2CASCREAD_ID_SVF	! Check the IDCODE,	
						     		 I2CASCSAVE_ID,
						     		 I2CASC_ENABLE	! Enable the ASC, 
								     I2CASC_SAVE,
								     I2CASC_EXIT_USERMODE ! Exit the programming mode";
												 
</Operation_List>
<Operation_List label="ChainSVFOperationRevC">	
	"Bypass"	=	"SVFINIT 	! Initialize";	
</Operation_List>
<Script>
<![CDATA[
int32   Temp_Row_Count = 0;
int32   Temp_UFM_Count = 0;
int32   MutexOn = 0;
function INIT {
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}


function SVFINIT {
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SVF_INIT {
	STATE IDLE;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function PRELOAD {
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
}

function INI_PRELOAD {				
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length);
}
function SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}

function INI_SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}
function CAPTURE {	
	datastream SavedBScanTDO[1][BSCAN_Length];	
	file NewFile = "FILE_SAVE";		
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length)
   					TDO(SavedBScanTDO[1]);
   Bscan[1] = SavedBScanTDO[1];	
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
   // Write To file 
   fopen NewFile att "w"
					 format "SVF_Plus";	
   fwrite NewFile (BSCAN_TDO, Bscan);
   fclose 	NewFile;
   
}

function DYNAMIC {	
   ENDDR DRPAUSE;
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1])
   					DMASK(BscanMask[1]);
   STATE IDLE;
}
function REFRESH_SRAM_ENABLE {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
    RUN_TEST IDLE TCK 2 ;
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function PSUEDO_FLASH_ERASE
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x02);
	RUN_TEST 	TCK 2 DELAY 1000;
}
function FLASH_ENABLE {
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1000;
	
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x00)
									MASK(0xC0);	
									
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function PSUEDO_FLASH_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x0A);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function FLASH_TRANSPARENT_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function FPGA_TRANSPARENT_ENABLE {
	STATE IDLE;
	! NOTE: Comment out 3 lines below if the FPGA device is blank (erased);
	SIR Instruction_Length TDI (LSC_ENABLE_X);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 1002 ;
	! END NOTE;
}
function SRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
	RUN_TEST	IDLE	TCK 2 ;

	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY PWP;
}
function VERIFY_STATUS {
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
	    SDR_VERIFY	32	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00002100);
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 200;         
		print (1, "Failed to Program DONE bit /see log file for more details/ ");
	}	
}
function SRAM_ENABLE {
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SRAM_TRANSPARENT_READ_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function DISABLE {
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 100 DELAY 100;
}
function DISABLE_REFRESH {	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;   
	
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100;
}
function READ_ID {
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length 	TDI (IDCODE_PUB);
	SDR_VERIFY	ID_Length	TDI (#0^ID_Length)
					        TDO	(IDTDI[1])
					        MASK (DEVICE_ID_MASK);
}
function PROGRAM_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		Control_Register_0_TDI[1] = $Control_Register_0_TDI[1];
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL0);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1])
					   MASK(0xFFFFFFFF);
	}
}
function VERIFY_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		Control_Register_0_TDI[1] = $Control_Register_0_TDI[1];
		! Shift in LSCC READ CONTROL 0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(Control_Register_0_TDI[1])
				       MASK(0xFFFFFFFF);
	}
	
}
function CHECK_STATUS {
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x00003000);
}
function CHECK_MSPI {
	TRY 1{
		! Shift in ISC ENABLE(0xC6) instruction;
    	SIR Instruction_Length TDI (ISC_ENABLE);
    	SDR 8 TDI(0x08);
		RUN_TEST	IDLE	TCK 2 DELAY 1;
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    	SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    	RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    	SDR_VERIFY 16   TDI(#0^16)
    		 	 		TDO(0x0800)
    		 	 		MASK(0xC800);
    	! Shift in ISC DISABLE(0x26) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;     
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1; 				  
		print (1,"The MSPI Persistent Fuse is disabled. Cannot continue.");
	}
}
function CHECK_FLASH_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00024040);
	}
	ELSE
	{				  
		print (1,"The OTP is set. Cannot continue.");
	}
}
function CHECK_SRAM_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{				  
		print (1,"The SRAM OTP is set. Cannot continue.");
	}
}
function CHECK_UFM_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00020000);
	}
	ELSE
	{				  
		print (1,"The UFM OTP is set. Cannot continue.");
	}
}
function CHECK_CFG_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"The CFG OTP is set. Cannot continue.");
	}
}
function CHECK_CFG_UFM_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00020040);
	}
	ELSE
	{		
		! Shift in ISC DISABLE(0x26) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;		  
		print (1,"The FLASH OTP is set. Cannot continue.");
	}
}
function CHECK_FR_OTP
{
	TRY 1{
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00004000);
	}
	ELSE
	{				  
		print (1,"The Feature Row OTP is set. Cannot continue.");
	}
}
function CHECK_SECURITY_PROTECT_KEY_ENABLE
{
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00010000);	
		print (0,"Note: The device does not need a Password Key.");		  			  
	}
	ELSE
	{
		IF (ProtectKey.row = 1)
		{
			! Shift in ISC ENABLE(0xC6) instruction;
		    SIR Instruction_Length TDI (ISC_ENABLE);
		    SDR 8 TDI(0x00);
			RUN_TEST	IDLE	TCK 2 DELAY 1;
				  
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
			SDR  64  TDI(ProtectKey[1]);
			RUN_TEST IDLE TCK 2 DELAY PWP; 
			
			TRY 1 {
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010020);										  
			}
			ELSE
			{
				! Shift in ISC DISABLE(0x26) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1;				  
				set_return_code (-93);
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{			
			set_return_code (-93);
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}	
}
function SVFCHECK_SECURITY_PROTECT_KEY_ENABLE
{
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x00024040);
	IF (ProtectKey.row = 1)
	{			  
		! Shift in ISC ENABLE(0xC6) instruction;
	    SIR Instruction_Length TDI (ISC_ENABLE);
	    SDR 8 TDI(0x00);
		RUN_TEST	IDLE	TCK 2 DELAY 1;
	
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  64  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00010000)
				  		MASK(0x00010020);										  
	}	
}
function CHECK_SECURITY_PROTECT_KEY
{
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00010000);	
		print (0,"Note: The device does not need a Password Key.");		  			  
	}
	ELSE
	{
		IF (ProtectKey.row = 1)
		{
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
			SDR  64  TDI(ProtectKey[1]);
			RUN_TEST IDLE TCK 2 DELAY PWP; 
			
			TRY 1 {
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010020);										  
			}
			ELSE
			{
				! Shift in ISC DISABLE(0x26) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1;				  
				set_return_code (-93);
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{			
			set_return_code (-93);
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}	
}
function SVFCHECK_SECURITY_PROTECT_KEY
{
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x00024040);
	IF (ProtectKey.row = 1)
	{			  			
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  64  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00010000)
				  		MASK(0x00010020);										  
	}	
}
function CHECK_KEYLOCK 
{
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);			  			  
	}
	ELSE
	{	
		print (1,"A Password Key is required. Please select a different operation in the Advanced Security Programming Mode.");
	}	
	
}
function CHECK_KEYLOCK_OPTION
{	
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);			  			  
	}
	ELSE
	{	
		print (1,"The Password Key is already programmed. Please Erase the Feature Row first.");		
	}	
	
}
function SRAM_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1000;
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY Instruction_Length TDI (BYPASS)
    					   		  TDO (0x00)
    					   		  MASK(0xC4);
}
function XSRAM_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1000;
}
function DIRECT_FLASH_ERASE {								
	// FLASH Erase				
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0E);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_DIRECT_FLASH_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);										
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0E);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function CFG_FLASH_ERASE {								
	// FLASH Erase				
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x04);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_CFG_FLASH_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);										
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x04);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function FLASH_ERASE_NO_FEA {	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0C);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_FLASH_ERASE_NO_FEA {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);			
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0C);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
    
}
function FLASH_ERASE {	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0E);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_FLASH_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);			
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x0E);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
    
}
function UFM_ERASE {

	! Shift in LSC_ERASE_UFM(0xCB) instruction;
    SIR Instruction_Length TDI (LSC_ERASE_UFM);
    RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_UFM_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);			
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
    SIR Instruction_Length TDI (LSC_ERASE_UFM);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function FEATURE_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x02);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SVF_FEATURE_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);			
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x02);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
    SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function BURST_PROGRAM {
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x01);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SIR Instruction_Length	TDI (LSC_BITSTREAM_BURST);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
	RUN_TEST	IDLE TCK 100 DELAY PWP;
}
function FLASH_FULL_PROGRAM_STATUS {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	PWP;
	repeat Temp_Row_Count{
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
		! Shift in Data Row = RowCount; 			
		SDR	128	TDI	(FuseArray_TDI[RowCount]);
		RUN_TEST IDLE TCK 2 ;	
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		RowCount = RowCount +1;		
	} 	
}
function FLASH_PROGRAM_STATUS {
	int32	RowCount = 1;
	int32   Adrr = 0;
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	repeat Temp_Row_Count{
		Adrr = Adrr + 1;
		IF (FuseArray_TDI[RowCount] == 0x00000000000000000000000000000000)
		{		
			! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
	    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
	    	SDR 32 TDI(Adrr); 
	    	RUN_TEST	IDLE TCK 2 ;
		}
		ELSE
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	  
		} 
		RowCount = RowCount +1;		
	} 	
}
function SVF_FLASH_PROGRAM_STATUS {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	repeat Temp_Row_Count{	
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    				
		! Shift in Data Row = RowCount;
		SDR	128	TDI	(FuseArray_TDI[RowCount]);	
		RUN_TEST IDLE TCK 2  DELAY PWP;	 
		RowCount = RowCount +1; 
	} 
}
function UFM_FULL_PROGRAM_STATUS {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	    RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count{				
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	 
			RowCount = RowCount +1;
		} 
			   
	}
}
function UFM_PROGRAM_STATUS {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	    RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	 
			RowCount = RowCount +1;
		} 
			   
	}
}
function SVF_UFM_PROGRAM_STATUS {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    						
			! Shift in Data Row = RowCount;
			SDR	128	TDI	(EFuseArray_TDI);	
			RUN_TEST IDLE TCK 2  DELAY PWP;	  
			RowCount = RowCount +1; 
		}
	} 
}
function SRAM_PROGRAM {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_PROG_INCR_RTI(0x82) instruction;
    SIR Instruction_Length	TDI	(LSC_PROG_INCR_RTI);
	repeat Address_Length {
		! Shift Out Data Row = RowCount;
	    SDR	Row_Width	TDI	(FuseArray_TDI);	    
	    RUN_TEST	IDLE TCK 2 DELAY 	PWP;						
		RowCount = RowCount +1;
	}				
}
function SRAM_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x00);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    SIR Instruction_Length	TDI	(LSC_VERIFY_INCR_RTI);
		repeat Address_Length {
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function FLASH_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x04);
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
		repeat Temp_Row_Count{	
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift out Data Row = RowCount; 
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}
					
}
function UFM_VERIFY {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	    	RUN_TEST	IDLE  TCK 2 DELAY 1;      	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM_Count{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI);
				RowCount = RowCount +1;
			}
			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM_VERIFY /see log file for more details/ ");
		}
	}
					
}
function SPI_FEATURE_PROGRAM
{
	datastream FeatureBitsArray[1][16];
	FeatureBitsArray[1] = #0000100000100000;
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    SDR 16 TDI(FeatureBitsArray[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 16   TDI(#0^16)
    				TDO(FeatureBitsArray[1]);
}
function SVF_SPI_FEATURE_PROGRAM
{
	datastream FeatureBitsArray[1][16];
	FeatureBitsArray[1] = #0000100000100000;
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    SDR 16 TDI(FeatureBitsArray[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;	
    ! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 16   TDI(#0^16)
    				TDO(FeatureBitsArray[1]);
}
function BOOT_EXTERNAL_FEATURE_PROGRAM
{
	datastream FeatureBitsArray[1][16];
	// 000 Single 	CFG
	// 001 Dual 	CFG-EXT
	// 011 Single	EXT
	// 101 Dual		EXT - CFG
	// 111 Dual 	EXT - EXT
	// 110 Dual 	CFG - UFM
	// 010 Dual		UFM - CFG
	// 100 NOBOOT
	
	FeatureBitsArray[1] = #0001100000100000;
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    SDR 16 TDI(FeatureBitsArray[1]);
    RUN_TEST IDLE TCK 2 ;
    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 16   TDI(#0^16)
    				TDO(FeatureBitsArray[1]);
}
function BOOT_INTERNAL_FEATURE_PROGRAM
{
	datastream FeatureBitsArray[1][16];
	// 000 Single 	CFG
	// 001 Dual 	CFG-EXT
	// 011 Single	EXT
	// 101 Dual		EXT - CFG
	// 111 Dual 	EXT - EXT
	// 110 Dual 	CFG - UFM
	// 010 Dual		UFM - CFG
	// 100 NOBOOT
	
	FeatureBitsArray[1] = #0011000000100000;
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    SDR 16 TDI(FeatureBitsArray[1]);
    RUN_TEST IDLE TCK 2 ;
    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 16   TDI(#0^16)
    				TDO(FeatureBitsArray[1]);
}
function FEATURE_PROGRAM_STATUS
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
	
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	    SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 64 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 64   TDI(#0^64)
	    				TDO(FeatureArray[1]);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFF2);
	    
	}
}
function SVF_FEATURE_PROGRAM_STATUS
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
	
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	    SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 64 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK 2 DELAY PWP;
	    ! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 64   TDI(#0^64)
	    				TDO(FeatureArray[1]);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 DELAY PWP;
	    ! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFF2);
	    
	}
}
function FEATURE_VERIFY_STATUS
{
	datastream FeatureBitsArray[1][16];
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);			  			  
	}
	ELSE
	{	
		print (1,"The FEATURE ROW is protected. Cannot verify. Please select a different operation.");
	}	
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureBitsArray[1] = ArchArray_TDI[1];
		    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
		    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0xFFF2);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1,"The FEATURE ROW Setting does not match the Setting in the Device. Cannot continue.");			
		}
	    
	}	
}
function FEATURE_VERIFY
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureArray[1] = ArchArray_TDI[1] << 16;			  
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
		    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
		    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		    SDR_VERIFY 64   TDI(#0^64)
		    				TDO(FeatureArray[1]);
		    		
		    FeatureBitsArray[1] = ArchArray_TDI[1];
		    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
		    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0xFFF2);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1,"The FEATURE ROW Setting does not match the Setting in the Device. Cannot continue.");			
		}
	    
	}	
}
function SVF_FEATURE_PROGRAM
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
	
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	    SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 64 TDI(FeatureArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 64  TDI(#0^64)
	    		       TDO(FeatureArray[1]);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    		        TDO(FeatureBitsArray[1])
	    		        MASK(0xFFF2);
	    
	}	
}
function OTP_PROGRAM_STATUS
{
	datastream OTPBitsArray[1][8];
	//OTP CFG, UFM, SRAM
	IF (ISSECURED == 7)
	{
		OTPBitsArray[1] = #11011101;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}	
	//OTP CFG, UFM, SRAM
	ELSEIF (ISSECURED == 6)
	{
		OTPBitsArray[1] = #11011101;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 5)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 15)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 4)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 13)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 3)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 2)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 11)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
}
function SVF_OTP_PROGRAM_STATUS
{
	datastream OTPBitsArray[1][8];
	//OTP CFG, UFM, SRAM
	IF (ISSECURED == 7)
	{
		OTPBitsArray[1] = #11011101;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;
	    ! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}	
	//OTP CFG, UFM, SRAM
	ELSEIF (ISSECURED == 6)
	{
		OTPBitsArray[1] = #11011101;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, SRAM
	ELSEIF (ISSECURED == 15)
	{
		OTPBitsArray[1] = #11011101;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 5)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 4)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM
	ELSEIF (ISSECURED == 13)
	{
		OTPBitsArray[1] = #11001100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 3)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 2)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG
	ELSEIF (ISSECURED == 11)
	{
		OTPBitsArray[1] = #01000100;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
}


function OTP_FEATURE_ROW_STATUS
{
	datastream OTPBitsArray[1][8];
	//OTP CFG, UFM, FEA, SRAM
	IF (ISSECURED == 7)
	{
		OTPBitsArray[1] = #11111111;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}	
	//OTP CFG, UFM, FEA, SRAM
	ELSEIF (ISSECURED == 6)
	{
		OTPBitsArray[1] = #11111111;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 5)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 15)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 4)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 13)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 3)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 2)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 11)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
}
function SVF_OTP_FEATURE_ROW_STATUS
{
	datastream OTPBitsArray[1][8];
	//OTP CFG, UFM, FEA, SRAM
	IF (ISSECURED == 7)
	{
		OTPBitsArray[1] = #11111111;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;
	    ! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}	
	//OTP CFG, UFM, FEA, SRAM
	ELSEIF (ISSECURED == 6)
	{
		OTPBitsArray[1] = #11111111;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA, SRAM
	ELSEIF (ISSECURED == 15)
	{
		OTPBitsArray[1] = #11111111;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, , UFM, FEA
	ELSEIF (ISSECURED == 5)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 4)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, UFM, FEA
	ELSEIF (ISSECURED == 13)
	{
		OTPBitsArray[1] = #11101110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 3)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 2)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
	//OTP CFG, FEA
	ELSEIF (ISSECURED == 11)
	{
		OTPBitsArray[1] = #01100110;
		! Shift in in LSC_PROG_OTP(0xF9) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_OTP);
	    SDR 8 TDI(OTPBitsArray[1]);
	    RUN_TEST	IDLE TCK 2 DELAY PWP;	  
		! Shift in in LSC_READ_OTP(0xFA) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_OTP);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 8   TDI(#0^8)
	    			   TDO(OTPBitsArray[1]);
	}
}
function SRAM_PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function PROGRAM_SECURITY {
	! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
    SIR Instruction_Length	TDI	(ISC_PROGRAM_SECURITY);
	RUN_TEST	TCK 2 DELAY PWP;	
}
function UFM_SECURITY {
	! Shift in LSC_PROGRAM_SECPLUS(0xCF) instruction;
    SIR Instruction_Length	TDI	(LSC_PROGRAM_SECPLUS);
	RUN_TEST	TCK 2 DELAY PWP;
}
function FLASH_PROGRAM_DONE_BIT {
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST	IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}	
		
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0xC4);
}
function PROGRAM_DONE_BIT {
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST	IDLE TCK 2 DELAY PWP;				
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0xC4);
}
function VERIFY_SRAM_DONE_BIT {
	RUN_TEST	IDLE  TCK 100 DELAY 5000;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000100)
			  		MASK(0x00002100);
			  	
	//! Shift in BYPASS(0xFF) instruction;
    //SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
	//								TDO(0x04)
	//								MASK(0x84);	
}
function VERIFY_DONE_BIT {	
	RUN_TEST	IDLE  TCK 100 DELAY 5000;
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0x84);	   	      	
}
function ERASE_DONE_BIT {
	! Shift in ISC_ERASE_DONE(0x24) instruction;
    SIR	Instruction_Length 	TDI (ISC_ERASE_DONE);
	RUN_TEST	TCK 2 DELAY PWP;
}
function VERIFY_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI)
									MASK(0xFFFFFFFF);
	}
}
function SRAM_VERIFY_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
	}
}
function SAVE_TRACEID
{
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE"; 
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SIR Instruction_Length	TDI	(LSC_UIDCODE_PUB);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}
function SAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE"; 
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length	TDI	(IDCODE_PUB);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SVF_SAVE_ID	{
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length 	TDI (IDCODE_PUB);
	SDR_VERIFY	ID_Length	TDI (#0^ID_Length)
							TDO	(IDTDI[1])
							MASK (#0^ID_Length);
}

function SAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0);
				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}

function SVF_SAVE_CONTROL0 
{
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 TDI(0x00000000)
				   TDO(0x00000000)
				   MASK(0x00000000);
}
function SAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SVF_SAVE_USERCODE {
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
								TDO	(#1^Usercode_Length)
								MASK(#0^Usercode_Length);
}

function READ_DONE_BIT {
	datastream SavedDONE_BIT[1][Instruction_Length];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI	(BYPASS)
							TDO (SavedDONE_BIT);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (DONE_BIT, SavedDONE_BIT);
	fclose 	NewFile;
}
function SVF_SAVE_DONE_BIT {
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY Instruction_Length	TDI	(BYPASS)
				TDO (#1^Instruction_Length)
				MASK(#0^Instruction_Length);
}


function FLASH_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";

	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
		SDR	128	TDI	(#1^128)
				TDO	(SavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SVF_FLASH_SAVE_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count {
		RUN_TEST	TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	128	TDI	(#1^128)
						TDO	(#1^128)
						MASK(#0^128);
		RowCount = RowCount +1;
	}
}
function SVF_FLASH_CHECKSUM_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count {
		RUN_TEST	TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	128	TDI	(#1^128)
						TDO	(#1^128)
						CMASK (#0^128);
		RowCount = RowCount +1;
	}
}
function UFM_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream UFMSavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	RUN_TEST	IDLE TCK 2 DELAY 	1;								
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#1^128)
				TDO	(UFMSavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, UFMSavedFuseMap);
	fclose 	NewFile;			
}
function SVF_UFM_SAVE_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	 SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR_VERIFY	128	TDI	(#1^128)
						TDO	(#0^128)
						MASK(#0^128);
		RowCount = RowCount +1;
	}			
}
function SVF_UFM_CHECKSUM_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	 SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR_VERIFY	128	TDI	(#1^128)
						TDO	(#0^128)
						CMASK(#0^128);
		RowCount = RowCount +1;
	}			
}
function FEATURE_SAVE_ARRAY
{
	datastream SaveFeatureArray[1][64];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][80];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x02);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 64   TDI(#1^64)
    		 TDO(SaveFeatureArray[1]);
	    
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 16   TDI(#1^16)
    		 TDO(SaveFeatureBitsArray[1]);
    
    FeatureSavedFuseMap[1] = (SaveFeatureBitsArray[1] @ SaveFeatureArray[1]); 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (ArchArray_TDI, FeatureSavedFuseMap);
	fclose 	NewFile;    
	
}
function SVF_FEATURE_SAVE_ARRAY
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x02);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 64   TDI(#1^64)
    		 		TDO(#0^64)
    		 		MASK(#0^64);
	    
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 16   TDI(#1^16)
    		 		TDO(#0^16)
    		 		MASK(#0^16); 
}
function EBR_SAVE_ARRAY 
{
	int32	Addr = 0;
	int32	RowCount = 1;
	datastream SavedEBRFuseMap[128][72];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	
	repeat 128{
		! Shift in LSC_WRITE_BUS_ADDR(0xF6) instruction;
		SIR Instruction_Length	TDI (LSC_WRITE_BUS_ADDR);
		SDR	24	TDI	(Addr);	
		RUN_TEST	IDLE TCK 2 DELAY 	PWP;
		! Shift in LSC_EBR_READ(0xB0) instruction;
	    SIR Instruction_Length	TDI	(LSC_EBR_READ);
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		SDR	72	TDI	(#1^72)
				TDO	(SavedEBRFuseMap[RowCount]);
		Addr = Addr + 1;
		RowCount = RowCount + 1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedEBRFuseMap);
	fclose 	NewFile;

}

function SRAM_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";

	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_VERIFY_INCR_RTI);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR	Row_Width	TDI	(#1^Row_Width);
    ! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_VERIFY_INCR_RTI);
	repeat Address_Length{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#1^Row_Width)
						TDO	(SavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SVF_SRAM_SAVE_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_VERIFY_INCR_RTI);
	repeat Address_Length {
		RUN_TEST	TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	Row_Width	TDI	(#1^Row_Width)
								TDO	(#1^Row_Width)
								MASK(#0^Row_Width);
		RowCount = RowCount +1;
	}
}
function SVF_SRAM_CHECKSUM_ARRAY {
	int32	RowCount = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_VERIFY_INCR_RTI);
	repeat Address_Length {
		RUN_TEST	TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	Row_Width	TDI	(#1^Row_Width)
								TDO	(#1^Row_Width)
								CMASK (#0^Row_Width);
		RowCount = RowCount +1;
	}
}

function SAVE_STATUS {
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS);
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SVF_SAVE_STATUS {
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS);
	SDR_VERIFY 	32 TDI (#0^32)
				   TDO	(#1^32)
				   MASK(#0^32);
}
function REFRESH_FUNCTION {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
    RUN_TEST IDLE TCK 2 DELAY 1000; 

	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 5000;
}

function UPLOAD_FUNCTION {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
	RUN_TEST IDLE TCK 2 DELAY 1000; 

	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 5000;
}
function FLASH_MDR{
    // SRAM Erase
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1;
	! Phase 2 Boundary Scan Locks Outputs;
    ! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;     
	! Phase 3 Device Configuration;
	! Shift in CLAMP(0x78) instruction;
	SIR	Instruction_Length	TDI(CLAMP);
	RUN_TEST	IDLE  DELAY MDRDelay;
	! Phase 4 Boundary Scan Released;     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
}

function PROGRAM_MANUFACTURING_REGISTER
{
	IF (Config_Register_TDI.row = 1)
	{
		print (0,Config_Register_TDI);
		! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
	    SDR 128 TDI(Config_Register_TDI[1]);
	    RUN_TEST IDLE TCK 2 DELAY PWP;
	}
}
function PROGRAM_BG_OFF
{
	datastream Manufacturing[1][128];
	Manufacturing[1] = 0x00000C8000200000000000000000004D;
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(Manufacturing[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;
    Manufacturing[1] = 0x00002C8000200000000000000000004D;
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(Manufacturing[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;
    Manufacturing[1] = 0x00000C8000200000000000000000004D;
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(Manufacturing[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;
}

function READ_MANUFACTURING_REGISTER
{
	datastream Manufacturing[1][128];
	file	NewFile = "FILE_SAVE"; 
			    
	//! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    //SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    //RUN_TEST IDLE TCK 2 DELAY PWV;
    //SDR 128 TDI(0x00000000000000000000000000000000)
    //	    TDO(Manufacturing[1]);	     
   	//print (0,Manufacturing);
    //SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    //RUN_TEST IDLE TCK 2 DELAY PWV;
    //SDR 128 TDI(0x00000000000000000000000000000000);
    
    Manufacturing[1] = 0x0000000000000000000000000000004D;
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, Manufacturing);
	fclose 	NewFile;
}
function READ_PES_FUSES
{
	datastream SavedPESFuse[1][128];
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000034D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_PES(0x11) instruction;
    SIR Instruction_Length	TDI (LSC_READ_PES);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR	 128	TDI(#0^128)
				TDO(SavedPESFuse[1]);
	
	print (0,SavedPESFuse);
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000); 
	 	
}
function READ_STATUS_FUSES
{
	datastream SavedStatusFuse[1][128];
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000004D);
    RUN_TEST IDLE TCK 2 DELAY 200;
    ! Shift in LSC_READ_STATUS(0x3C) instruction;
    SIR Instruction_Length	TDI (LSC_READ_STATUS);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR	 128	TDI(#0^128)
				TDO(SavedStatusFuse[1]);
	
	print (0,SavedStatusFuse);
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000); 
	 	
}
function READ_MES_REGISTER
{
	datastream MESArray[1][64];
	datastream tmpMESArray[1][128];
	file	NewFile = "FILE_SAVE";
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000014D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_PES(0x11) instruction;
    SIR Instruction_Length	TDI (LSC_READ_PES);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR 128 TDI(0x00000000000000000000000000000000)
    	   TDO(tmpMESArray[1]);
   	MESArray[1] = tmpMESArray[1];
    print (0,MESArray);
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000); 
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, MESArray);
	fclose 	NewFile;
}
function READ_DTR_REGISTER
{
	datastream DTRArray[1][8];
	file	NewFile = "FILE_SAVE"; 
	//82:82	mfgbit_dtr_en	Digital Temp Readout Enable Bit via Mnfg Mode
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000040000000000000000004D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_TEMP(0xE8) instruction;
    SIR Instruction_Length	TDI (LSC_READ_TEMP);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR 8 TDI(0x00)
    	   TDO(DTRArray[1]);
    
    print (0,DTRArray);
    
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, DTRArray);
	fclose 	NewFile;
}
function READ_CONFIG_REGISTER
{
	datastream FeatureBitsArray[1][16];
	file	NewFile = "FILE_SAVE"; 
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 16  TDI(#0^16)
    		TDO(FeatureBitsArray[1]);
    FeatureBitsArray[1] = $FeatureBitsArray[1];
    print (0,FeatureBitsArray);
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, FeatureBitsArray);
	fclose 	NewFile;
	
}
function PROGRAM_CONFIG_REGISTER
{
	IF (Config_Register_TDI.row = 1)
	{
	 	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(Config_Register_TDI[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(Config_Register_TDI[1]);
	}
}	
function SVF_PROGRAM_CONFIG_REGISTER
{
	IF (Config_Register_TDI.row = 1)
	{
	 	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(Config_Register_TDI[1]);
	    RUN_TEST IDLE TCK 2 DELAY PWP;
	    ! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(Config_Register_TDI[1]);
	}
}		
function FEATURE_ROW_READ
{
	datastream FeatureRow[1][80];
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	file	NewFile = "FILE_SAVE"; 
	
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00010000);	
	}
	ELSE
	{
		print (0,"The Feature Row is secured.");
	}
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x02);
	RUN_TEST	IDLE TCK 2 DELAY 	PWP;
	
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 64  TDI(#0^64)
    		TDO(FeatureArray[1]);   	
   	
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 16  TDI(#0^16)
    		TDO(FeatureBitsArray[1]);
    
    FeatureRow[1] = (FeatureBitsArray[1] @ FeatureArray[1]);
	//print (0,FeatureRow);
	
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureRow);
	fclose 	NewFile;
}
function READ_PROTECT_KEY_FUSES
{
	datastream PasswordArray[1][64];
	TRY 1 {
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00010000);	
		print (0,"Password Key is Disabled");
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SIR Instruction_Length TDI (LSC_READ_PASSWORD);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR 64  TDI(#0^64)
				TDO(PasswordArray[1]);
		print (0,"The password is");
		print (0,PasswordArray);
		 		  			  
	}
	ELSE
	{	
		TRY 1 {
			print (0,"Password Key is Enabled");
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00000020);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR 64  TDI(#0^64)
					TDO(PasswordArray[1]);
			print (0,"The password is");
			print (0,PasswordArray);						  	
					  			  
		}
		ELSE
		{	
			print (1,"The Password is protected. Cannot continue.");
		}
	}	
}
function PROGRAM_PROTECT_KEY_NO_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		//print (0,ProtectKey);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	PWP;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE  TCK 2 DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		print (0,"Verify the Password Key...");
		//Verify the Password Key;
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);					  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key.");
		}	
					  		  		
		print (0, "Programming the Password Key Enable...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    	! Shift in Data; 
		SDR 16 TDI(0x000C);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE  TCK 2 DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00010000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key Enable.");
		}							  								  		
	}				  				  		  		  
}
function SVF_PROGRAM_PROTECT_KEY_NO_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		//print (0,ProtectKey);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	PWP;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		print (0,"Verify the Password Key...");
		//! Verify the Password Key;
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);					  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key.");
		}				  		  		
		print (0, "Programming the Password Key Enable...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    	! Shift in Data; 
		SDR 16 TDI(0x000C);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00010000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key Enable.");
		}						  								  		
	}				  				  		  		  
}
function PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	PWP;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE  TCK 2 DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);					  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key.");
		}	
		
					  		  		
		print (0, "Programming the Password Key Enable and Keylock...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    	! Shift in Data; 
		SDR 16 TDI(0x000D);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE  TCK 2 DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		
		print (0,"Verify the Password Key Enable and Keylock...");
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00010020)
					  	MASK(0x00013020);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		
	}				  				  		  		  
}
function SVF_PROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);					  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key.");
		}	
		
					  		  		
		print (0, "Programming the Password Key Enable and Keylock...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    	! Shift in Data; 
		SDR 16 TDI(0x0005);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key Enable and Keylock...");
		TRY 1 {
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00010020)
					  	MASK(0x00013020);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		
	}				  				  		  		  
}
function SAVE_COMPARE_STATUS {
	datastream SavedSTATUS[1][8];
	file NewFile = "FILE_SAVE";

	//! Shift in LSCC RESET ADDRESS(0x21) instruction;
    //SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	//RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		
	! Shift in PROTECT_SHIFT(0x41) instruction;
	SIR Instruction_Length TDI (PROTECT_SHIFT);
	SDR  64  TDI(ProtectKey[1]);
	RUN_TEST IDLE TCK 2 DELAY PWP; 
		
	! Shift in READ STATUS(0xB2) instruction;
	SIR Instruction_Length TDI (READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR	8	TDI(#1^8)
			TDO(SavedSTATUS[1]);
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}

function SAVE_FEATURE_ROW_STATUS {
	datastream SavedSTATUS[1][8];
	file NewFile = "FILE_SAVE";
	SecurityKey.row = 1;

		
	! Shift in PROTECT_SHIFT(0x41) instruction;
	SIR Instruction_Length TDI (PROTECT_SHIFT);
	SDR  128  TDI(SecurityKey[1]);
	RUN_TEST IDLE TCK 2 DELAY PWP; 
		
	! Shift in READ STATUS(0xB2) instruction;
	SIR Instruction_Length TDI (READ_STATUS);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR	8	TDI(#1^8)
			TDO(SavedSTATUS[1]);
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}

function SPIINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	setpin ISPEN HIGH;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SPIREAD_ID {
	IDTDI[1] = $IDTDI[1];
	setpin ISPEN LOW;
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	32	TDI (0x00000007);
	SDR_VERIFY	32	TDI (0x00000000)
					TDO	(IDTDI[1])
					MASK (0xFFFFFFFF);
					
	setpin ISPEN HIGH;				        
}
function SPISAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	setpin ISPEN LOW; 
	
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	setpin ISPEN HIGH;				
	SavedID[1] = $SavedID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SPISVFSAVE_ID	{
	setpin ISPEN LOW; 
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(#0^ID_Length)
					MASK(#0^ID_Length);
	setpin ISPEN HIGH;					
}
function SPIFLASH_ENABLE	{
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
	RUN_TEST IDLE DELAY PWE;
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    setpin ISPEN HIGH;	
    RUN_TEST DELAY PWV;
}
function SPIFLASH_TRANSPARENT_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
}
function SPI_SRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 24	TDI (0x00009E);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function SPISRAM_ENABLE {
	setpin ISPEN LOW;
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 1000;
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function SPISRAM_TRANSPARENT_READ_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function SPIBACKGROUND_DISABLE	{
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in NO-OP(0xFF) instruction;
    SDR	32 	TDI (0xFFFFFFFF);
    setpin ISPEN HIGH;
}
function SPIDISABLE {
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
    setpin ISPEN LOW;
	! Shift in NO-OP(0xFF) instruction;
    SDR	32 	TDI (0xFFFFFFFF);
    setpin ISPEN HIGH;
}
function SPISRAM_SAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	setpin ISPEN LOW;
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SDR 32 TDI (0x00000004);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0[1]);
	setpin ISPEN HIGH;	
	SavedControl0[1] = $SavedControl0[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function SPISRAM_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
    setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
    SDR 32	TDI	(0xFFFF0456);
    SDR	Row_Width	TDI	(#1^Row_Width);
    SDR	128	TDI	(#1^128);
    repeat Address_Length{			
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#1^Row_Width)
						TDO	(SavedFuseMap[RowCount]);
		SDR 32	TDI	(#1^32);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SPICHECK_FLASH_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02024000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		print (1,"The OTP is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		print (1,"The SRAM OTP is set. Cannot continue.");
	}
}
function SPICHECK_CFG_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1,"The CFG OTP is set. Cannot continue.");
	}
}
function SPICHECK_UFM_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00004000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		print (1,"The UFM OTP is set. Cannot continue.");
	}
}
function SPICHECK_CFG_UFM_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02004000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1,"The FLASH OTP is set. Cannot continue.");
	}
}
function SPICHECK_FR_OTP 
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00020000);
		setpin ISPEN HIGH;				  	
	}
	ELSE
	{	
		setpin ISPEN HIGH;		
		print (1,"The Feature Row OTP is set. Cannot continue.");
	}
}
function SPICHECK_KEYLOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		print (1,"A Password Key is required. Please select a different operation.");
	}		
}
function SPIDIRECT_FLASH_ERASE {
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00007070);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
	loop PWE {
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function SPICFG_ERASE {
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
	loop PWE {
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function SPIFLASH_ERASE {	
	setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00003070);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
	loop PWE {
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function SPIUFM_ERASE {
	setpin ISPEN LOW;
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
    SDR 32 TDI (0x000000D3);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
	loop PWE {
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function SPISRAM_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWE;
}
function SPIFEATURE_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
	loop PWE {
		RUN_TEST DELAY 10;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function SPIBURST_PROGRAM {
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
}
function SPIFLASH_PROGRAM_STATUS {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;	
	repeat Temp_Row_Count{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SDR 32	TDI (0x0000000E);    
    	! Shift in Data Row = RowCount; 			
		SDR	128	TDI	(FuseArray_TDI[RowCount]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	   
		RowCount = RowCount +1;	
		setpin ISPEN HIGH;		
	} 	
}
function SPIUFM_PROGRAM_STATUS {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000000E2);
	    setpin ISPEN HIGH;
		repeat Temp_UFM_Count{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 
			   
	}
}
function SPIFEATURE_PROGRAM_STATUS
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 64 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    SDR_VERIFY 64   TDI(#0^64)
	    				TDO(FeatureArray[1]);
	    setpin ISPEN HIGH;	
	    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    setpin ISPEN LOW; 
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFF);
	    setpin ISPEN HIGH;			
	}
}
function SPIPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST IDLE DELAY 1;
	}
}
function SPIFLASH_PROGRAM_DONE_BIT {
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;	
	loop PWP {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}	
	setpin ISPEN HIGH;	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00800000)
			  	MASK(0x008C0000);
	setpin ISPEN HIGH;
}
function SPIPROGRAM_SECURITY {
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
    SDR 32	TDI	(0x00000073);
	setpin ISPEN HIGH;	
}
function SPIUFM_SECURITY {
	setpin ISPEN LOW;
	! Shift in LSC_PROGRAM_SECPLUS(0xCF) instruction;
    SDR 32	TDI	(0x000000F3);
	setpin ISPEN HIGH;
}
function SPICHECK_STATUS {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x000C0000);
	setpin ISPEN HIGH;
}
function SPIFLASH_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00000062);
    	setpin ISPEN HIGH;    
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SDR 160	TDI	(0x00000000000000000000000000000000FFFF08CE);
	    repeat Temp_Row_Count{	
	    	! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI[RowCount]);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function SPISRAM_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00000062);
    	setpin ISPEN HIGH; 
    	setpin ISPEN LOW;
		! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    SDR 32	TDI	(0xFFFF0856);
	    SDR	Row_Width	TDI	(#0^Row_Width);
		repeat Address_Length {
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function SPIUFM_VERIFY {
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SDR 32	TDI (0x000000E2);
	    	setpin ISPEN HIGH;		
	    	repeat Temp_UFM_Count{	
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000000CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI);
				RowCount = RowCount +1;	
				setpin ISPEN HIGH;			
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function UFM_VERIFY /see log file for more details/ ");
		}
	}
					
}
function SPIFEATURE_VERIFY_STATUS
{
	datastream FeatureBitsArray[1][16];
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{
		print (1,"The FEATURE ROW is protected. Cannot verify. Please select a different operation.");
	}
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureBitsArray[1] = ArchArray_TDI[1];
		    setpin ISPEN LOW; 				    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SDR 32	TDI (0x000000DF);
		    FeatureBitsArray[1] = $FeatureBitsArray[1];
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0x4FFF);
			setpin ISPEN HIGH;		    				
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			setpin ISPEN HIGH;
			print (1,"The FEATURE ROW Setting does not match the Setting in the Device. Cannot continue.");			
		}
	    
	}	
}
function SPIFEATURE_VERIFY
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureArray[1] = ArchArray_TDI[1] << 16;	
			setpin ISPEN LOW; 		  
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
		    SDR 32	TDI (0x000000E7);
		    FeatureArray[1] = $FeatureArray[1];		    
		    SDR_VERIFY 64   TDI(#0^64)
		    				TDO(FeatureArray[1]);
		    setpin ISPEN HIGH;
			FeatureBitsArray[1] = ArchArray_TDI[1];
		    setpin ISPEN LOW; 				    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SDR 32	TDI (0x000000DF);
		    FeatureBitsArray[1] = $FeatureBitsArray[1];
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0x4FFF);
			setpin ISPEN HIGH;		    				
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			setpin ISPEN HIGH;
			print (1,"The FEATURE ROW Setting does not match the Setting in the Device. Cannot continue.");			
		}
	    
	}	
}
function SPIVERIFY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}
function SPIVERIFY_DONE_BIT {	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	setpin ISPEN HIGH;  	      	
}
function SPI_SAVE_STATUS	{
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS);
	setpin ISPEN HIGH;			
	print (0,SavedSTATUS);
	SavedSTATUS[1] = $SavedSTATUS[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SPISAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPIFLASH_SAVE_ARRAY {
	datastream SavedFuseMap[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;    
	setpin ISPEN LOW;
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SDR 32	TDI	(0xFFFF08CE);
    SDR	128	TDI	(#0^128);	
    repeat Temp_Row_Count{	
    	SDR	128	TDI	(#1^128)
				TDO	(SavedFuseMap);
	}
	setpin ISPEN HIGH;
	SDR 8 TDI(0xFF);
		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SPIUFM_SAVE_ARRAY {
	datastream UFMSavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW; 
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	SDR 32	TDI (0x000000E2);
	setpin ISPEN HIGH;		
	setpin ISPEN LOW;      	
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SDR 32	TDI	(0xFFFF08CE);
    SDR	128	TDI	(#0^128);	
	repeat Temp_UFM_Count{					
    	SDR	128	TDI	(#1^128)
				TDO	(UFMSavedFuseMap);					
	}
	setpin ISPEN HIGH;
	SDR 8 TDI(0xFF);			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, UFMSavedFuseMap);
	fclose 	NewFile;			
}
function SPIFEATURE_SAVE_ARRAY
{
	datastream SaveFeatureArray[1][64];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][80];
	file NewFile = "FILE_SAVE";		
	setpin ISPEN LOW; 		  
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
    SDR 64   TDI(#1^64)
    		 TDO(SaveFeatureArray[1]);
	setpin ISPEN HIGH;
	SaveFeatureArray[1] = $SaveFeatureArray[1];		     
	setpin ISPEN LOW; 				    	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR 32	TDI (0x000000DF);
    SDR 16   TDI(#1^16)
    		 TDO(SaveFeatureBitsArray[1]);
    setpin ISPEN HIGH;
    SaveFeatureBitsArray[1] = $SaveFeatureBitsArray[1];
    FeatureSavedFuseMap[1] = (SaveFeatureBitsArray[1] @ SaveFeatureArray[1]); 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (ArchArray_TDI, FeatureSavedFuseMap);
	fclose 	NewFile;    	
}
function SPIREFRESH {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 24	TDI (0x00009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
}
function SPIVERIFY_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(Control_Register_0_TDI[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function SPIPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK 
{	   
	datastream SaveProtectKey[1][64];
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		//print (0,ProtectKey);
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00004062);
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 64 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable...");
		setpin ISPEN LOW; 
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0x3000);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00008000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to Program the Password Key Enable.");
		}							  								  		
	}				  				  		  		  
}
function SPIPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK 
{
	datastream SaveProtectKey[1][64];
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		//print (0,ProtectKey);
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00004062);
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 64 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable...");
		setpin ISPEN LOW; 
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0xB000);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00008000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to Program the Password Key Enable.");
		}							  								  		
	}	
}	
function SPICHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00008000);
		setpin ISPEN HIGH;	
		print (0,"Note: The device does not need a Password Key.");					  				  			  
	}
	ELSE
	{
		IF (ProtectKey.row = 1)
		{			  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC ENABLE(0xC6) instruction;
		    SDR 24 TDI (0x000063);
		    setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR 32 TDI (0x0000003D);
			SaveProtectKey[1] = ProtectKey[1];
			SaveProtectKey[1] = $SaveProtectKey[1];
			SDR  64  TDI(SaveProtectKey[1]);
			setpin ISPEN HIGH;
			
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x04008000);
				setpin ISPEN HIGH;										  
			}
			ELSE
			{				  
				setpin ISPEN HIGH;		
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	24 	TDI (0x000064);
			    setpin ISPEN HIGH;		
				set_return_code (-93);
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;		
			set_return_code (-93);
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SVFSPICHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x02024000);
	setpin ISPEN HIGH;				  	
	IF (ProtectKey.row = 1)
	{			  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC ENABLE(0xC6) instruction;
	    SDR 24 TDI (0x000063);
	    setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  64  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00008000)
				  		MASK(0x04008000);
		setpin ISPEN HIGH;										  
	}	
}
function SPICHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00008000);
		setpin ISPEN HIGH;	
		print (0,"Note: The device does not need a Password Key.");					  				  			  
	}
	ELSE
	{
		IF (ProtectKey.row = 1)
		{			  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR 32 TDI (0x0000003D);
			SaveProtectKey[1] = ProtectKey[1];
			SaveProtectKey[1] = $SaveProtectKey[1];
			SDR  64  TDI(SaveProtectKey[1]);
			setpin ISPEN HIGH;
			
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x04008000);
				setpin ISPEN HIGH;										  
			}
			ELSE
			{				  
				setpin ISPEN HIGH;		
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	24 	TDI (0x000064);
			    setpin ISPEN HIGH;		
				set_return_code (-93);
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;		
			set_return_code (-93);
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SVFSPICHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x02024000);
	setpin ISPEN HIGH;				  	
	IF (ProtectKey.row = 1)
	{			  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  64  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00008000)
				  		MASK(0x04008000);
		setpin ISPEN HIGH;										  
	}	
}
function SPIFEATURE_ROW_READ
{
	datastream SaveFeatureArray[1][64];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][80];
	file NewFile = "FILE_SAVE";
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00008000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		print (0,"The Feature Row is secured.");
	}		
	setpin ISPEN LOW; 		  
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
    SDR 64   TDI(#0^64)
    		 TDO(SaveFeatureArray[1]);
	setpin ISPEN HIGH;
	SaveFeatureArray[1] = $SaveFeatureArray[1];		     
	setpin ISPEN LOW; 				    	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR 32	TDI (0x000000DF);
    SDR 16   TDI(#0^16)
    		 TDO(SaveFeatureBitsArray[1]);
    setpin ISPEN HIGH;
    SaveFeatureBitsArray[1] = $SaveFeatureBitsArray[1];
    FeatureSavedFuseMap[1] = (SaveFeatureBitsArray[1] @ SaveFeatureArray[1]); 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureSavedFuseMap);
	fclose 	NewFile;    	
}

function I2CINIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function I2CREAD_ID {
	IDTDI[1] = $IDTDI[1];
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		I2C_STOP;
	}	
	ELSE
	{	
		I2C_STOP;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function I2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	I2C_STOP;				
	SavedID[1] = $SavedID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function I2CSRAM_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    I2C_STOP;
    RUN_TEST DELAY 1000;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
}
function I2CBURST_PROGRAM {
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    I2C_STOP;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    I2C_STOP;
	RUN_TEST DELAY PWP;
}
function I2CFLASH_ENABLE	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    I2C_STOP;
    RUN_TEST DELAY 1000;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    I2C_STOP;	
    RUN_TEST DELAY PWV;
}
function I2CFLASH_ENABLE_READ_ID
{
	IDTDI[1] = $IDTDI[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    I2C_STOP;
    RUN_TEST DELAY 1000;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    I2C_STOP;	
    RUN_TEST DELAY PWV;
    TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		I2C_STOP;
	}	
	ELSE
	{	
		I2C_STOP;		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
	    I2C_STOP;
	    RUN_TEST DELAY 200;   
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}
}
function I2CFEATURE_ENABLE	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    I2C_STOP;	
    RUN_TEST DELAY PWV;
}
function I2CFLASH_TRANSPARENT_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_ENABLE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 24	TDI (0x00009E);
    I2C_STOP;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function I2CDISABLE	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function I2CFEATUREDISABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function I2CBACKGROUND_DISABLE	{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    I2C_STOP;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in NO-OP(0xFF) instruction;
    SDR	32 	TDI (0xFFFFFFFF);
    I2C_STOP;
}
function I2CCHECK_FLASH_OTP
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02024000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;		
		print (1,"The OTP is set. Cannot continue.");
	}
}
function I2CCHECK_SRAM_OTP
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02000000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;		
		print (1,"The SRAM OTP is set. Cannot continue.");
	}
}
function I2CCHECK_CFG_OTP
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02000000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		I2C_STOP;
		print (1,"The CFG OTP is set. Cannot continue.");
	}
}
function I2CCHECK_UFM_OTP
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00004000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;		
		print (1,"The UFM OTP is set. Cannot continue.");
	}
}
function I2CCHECK_CFG_UFM_OTP
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x02004000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		I2C_STOP;	
		print (1,"The FLASH OTP is set. Cannot continue.");
	}
}
function I2CCHECK_FR_OTP
{
	datastream SaveProtectKey[1][64];
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00020000);
		I2C_STOP;				  	
	}
	ELSE
	{	
		I2C_STOP;		
		print (1,"The Feature Row OTP is set. Cannot continue.");
	}
}
function I2CCHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];	
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00008000);
		I2C_STOP;	
		print (0,"Note: The device does not need a Password Key.");					  				  			  
	}
	ELSE
	{	
		IF (ProtectKey.row = 1)
		{
			I2C_STOP;
			I2C_START;
		    ! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC ENABLE(0xC6) instruction;
		    SDR 24 TDI (0x000063);
		    I2C_STOP;
			RUN_TEST DELAY PWV;			  
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR 32 TDI (0x0000003D);
			SaveProtectKey[1] = ProtectKey[1];
			SaveProtectKey[1] = $SaveProtectKey[1];
			SDR  64  TDI(SaveProtectKey[1]);
			I2C_STOP;
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x04008000);
				I2C_STOP;										  
			}
			ELSE
			{	
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	24 	TDI (0x000064);
				I2C_STOP;		
				set_return_code (-93);			
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			I2C_STOP;
			set_return_code (-93);		
			print (1,"A Password Key is required. Please select a different operation.");
		}
	}		
}
function SVFI2CCHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x02024000);
	I2C_STOP;				  	
	IF (ProtectKey.row = 1)
	{
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC ENABLE(0xC6) instruction;
	    SDR 24 TDI (0x000063);
	    I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  64  TDI(SaveProtectKey[1]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00008000)
				  		MASK(0x04008000);
		I2C_STOP;										  
	}	
}
function I2CCHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];	
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00008000);
		I2C_STOP;	
		print (0,"Note: The device does not need a Password Key.");					  				  			  
	}
	ELSE
	{	
		IF (ProtectKey.row = 1)
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR 32 TDI (0x0000003D);
			SaveProtectKey[1] = ProtectKey[1];
			SaveProtectKey[1] = $SaveProtectKey[1];
			SDR  64  TDI(SaveProtectKey[1]);
			I2C_STOP;
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x04008000);
				I2C_STOP;										  
			}
			ELSE
			{	
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	24 	TDI (0x000064);
				I2C_STOP;		
				set_return_code (-93);			
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			I2C_STOP;
			set_return_code (-93);		
			print (1,"A Password Key is required. Please select a different operation.");
		}
	}		
}
function SVFI2CCHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x02024000);
	I2C_STOP;				  	
	IF (ProtectKey.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  64  TDI(SaveProtectKey[1]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00008000)
				  		MASK(0x04008000);
		I2C_STOP;										  
	}	
}
function I2CCHECK_KEYLOCK 
{		
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x04000000);
		I2C_STOP;					  				  			  
	}
	ELSE
	{	
		
		I2C_STOP;    		
		print (1,"A Password Key is required. Please select a different operation.");
	}		
}
function I2CDIRECT_FLASH_ERASE {
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00003070);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function I2CDIRECT_SVF_FLASH_ERASE {
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00003070);
    RUN_TEST DELAY 5000;
    I2C_STOP;
}
function I2CFLASH_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00003070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function I2CFLASH_SVF_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00003070);
    RUN_TEST DELAY 5000;
    I2C_STOP;    
}
function I2CUFM_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
    SDR 32 TDI (0x000000D3);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);		
	}
	I2C_STOP;
}
function I2CUFM_SVF_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
    SDR 32 TDI (0x000000D3);
    RUN_TEST DELAY 5000;
    I2C_STOP;    
}
function I2CFEATURE_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    RUN_TEST DELAY 5000;
    I2C_STOP;    
}
function I2CFEATURE_SVF_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    RUN_TEST DELAY 5000;
    I2C_STOP;
}
function I2CFLASH_PROGRAM_STATUS {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    repeat Temp_Row_Count{
    	I2C_STOP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SDR 32	TDI (0x0000000E);    
    	! Shift in Data Row = RowCount; 			
		SDR	128	TDI	(FuseArray_TDI[RowCount]);
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);	
		}
		RowCount = RowCount +1;			
	} 	
	I2C_STOP;
}
function I2CFLASH_SVF_PROGRAM_STATUS {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    I2C_STOP;	
	repeat Temp_Row_Count{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SDR 32	TDI (0x0000000E);    
    	! Shift in Data Row = RowCount; 			
		SDR	128	TDI	(FuseArray_TDI[RowCount]);
		RUN_TEST DELAY PWV;
		I2C_STOP;
		RowCount = RowCount +1;			
	} 	
	I2C_STOP;
}
function I2CUFM_PROGRAM_STATUS {
	int32	RowCount = 1;
	datastream TmpArray[1][128];
	IF (EFuseArray_TDI.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000000E2);
	    repeat Temp_UFM_Count{
	    	TmpArray[1] = (EFuseArray_TDI[RowCount]);	
			I2C_STOP;			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(TmpArray[1]);
			loop PWP {
				I2C_STOP;	
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
		    	I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function I2CUFM_SVF_PROGRAM_STATUS {
	int32	RowCount = 1;
	datastream TmpArray[1][128];
	IF (EFuseArray_TDI.row = 1)
	{	
		TmpArray[1] = (EFuseArray_TDI[RowCount]);	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000000E2);
	    I2C_STOP;
		repeat Temp_UFM_Count{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(TmpArray[1]);
			RUN_TEST DELAY PWV;
			I2C_STOP;	
			RowCount = RowCount +1;
		} 
			   
	}
}
function I2CFEATURE_PROGRAM_STATUS
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;			    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (0x81);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFF);
	    I2C_STOP;
	    FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 64 TDI(FeatureArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_READ );
	    SDR_VERIFY 64   TDI(#0^64)
	    				TDO(FeatureArray[1]);
	    I2C_STOP;			
	}
}
function I2CFEATURE_SVF_PROGRAM_STATUS
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;			    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (0x81);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFF);
	    I2C_STOP;
	    FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 64 TDI(FeatureArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_READ );
	    SDR_VERIFY 64   TDI(#0^64)
	    				TDO(FeatureArray[1]);
	    I2C_STOP;			
	}
}
function I2CPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY 10;
	}
}
function I2CFLASH_PROGRAM_DONE_BIT {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00800000)
			  	MASK(0x008C0000);
	I2C_STOP;
}
function I2CPROGRAM_SECURITY {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
    SDR 32	TDI	(0x00000073);
	I2C_STOP;	
}
function I2CUFM_SECURITY {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_PROGRAM_SECPLUS(0xCF) instruction;
    SDR 32	TDI	(0x000000F3);
	I2C_STOP;
}
function I2CCHECK_STATUS {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x000C0000);
	I2C_STOP;
}
function I2CFLASH_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;   
    
    RUN_TEST DELAY 1000;
    	
	TRY 1 {		     			
		repeat Temp_Row_Count {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000008CE);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI[RowCount]);
			I2C_STOP;
			RowCount = RowCount +1;
		}
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in NO-OP(0xFF) instruction;
	    SDR	32 	TDI (0xFFFFFFFF);
	    I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	24 	TDI (0x000064);
		I2C_STOP;		
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function I2CUFM_VERIFY {
	int32	RowCount = 1;
	datastream TmpArray[1][128];
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDR_EBR(0x47) instruction;
	SDR 32	TDI (0x000000E2);
	I2C_STOP;			    	
	
	RUN_TEST DELAY 1000;
	    	
	IF (EFuseArray_TDI.row = 1)
	{		
		TRY 1 {
			repeat Temp_UFM_Count{	
				TmpArray[1] = (EFuseArray_TDI[RowCount]);
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(TmpArray[1]);
				I2C_STOP;																
				RowCount = RowCount +1;				
			}
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			I2C_STOP;			
			print (1, "Failed in Function UFM_VERIFY /see log file for more details/ ");
		}
	}		
}
function I2CFEATURE_VERIFY_STATUS
{
	datastream FeatureBitsArray[1][16];
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x04000000);
		I2C_STOP;					  				  			  
	}
	ELSE
	{
		print (1,"The FEATURE ROW is protected. Cannot verify. Please select a different operation.");
	}
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureBitsArray[1] = ArchArray_TDI[1];
		    I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 				    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SDR 32	TDI (0x000000DF);
		    FeatureBitsArray[1] = $FeatureBitsArray[1];
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0x4FFF);
			I2C_STOP;		    				
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			I2C_STOP;
			print (1,"The FEATURE Row setting does not match the setting in the Device. Please program the FEATURE Row first.");			
		}
	    
	}	
}
function I2CFEATURE_VERIFY
{
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{
			FeatureArray[1] = ArchArray_TDI[1] << 16;	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
		    SDR 32	TDI (0x000000E7);
		    FeatureArray[1] = $FeatureArray[1];	
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);	    
		    SDR_VERIFY 64   TDI(#0^64)
		    				TDO(FeatureArray[1]);
		    I2C_STOP;
			FeatureBitsArray[1] = ArchArray_TDI[1];
		    I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 				    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		    SDR 32	TDI (0x000000DF);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
		    FeatureBitsArray[1] = $FeatureBitsArray[1];
		    SDR_VERIFY 16   TDI(#0^16)
		    				TDO(FeatureBitsArray[1])
		    				MASK(0x4FFF);
			I2C_STOP;		    				
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
			I2C_STOP;
			print (1,"The FEATURE ROW Setting does not match the Setting in the Device. Cannot continue.");			
		}
	    
	}	
}
function I2CVERIFY_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function I2CVERIFY_DONE_BIT {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	I2C_STOP;  	      	
}
function I2C_SAVE_STATUS	{
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS);
	I2C_STOP;			
	print (0,SavedSTATUS);
	SavedSTATUS[1] = $SavedSTATUS[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function I2CSAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CFLASH_SAVE_ARRAY {
	datastream SavedFuseMap[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;    
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SDR 32	TDI	(0xFFFF00CE);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	128	TDI	(#1^128)
					TDO(#0^128)
					MASK(#0^128);
    repeat Temp_Row_Count{	
    	RUN_TEST DELAY PWV;
    	SDR	128	TDI	(#1^128)
				TDO	(SavedFuseMap);
	}
	SDR_VERIFY	32	TDI	(#1^32)
					TDO (#0^32)
					MASK(#0^32);
	I2C_STOP;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function I2CUFM_SAVE_ARRAY {
	datastream UFMSavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);  
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	SDR 32	TDI (0x000000E2);
	I2C_STOP;		
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SDR 32	TDI	(0xFFFF00CE);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	128	TDI	(#1^128)
					TDO(#0^128)
					MASK(#0^128);
    repeat Temp_UFM_Count{	
    	RUN_TEST DELAY PWV;			
    	SDR	128	TDI	(#1^128)
				TDO	(UFMSavedFuseMap);					
	}
	SDR_VERIFY	32	TDI	(#1^32)
					TDO (#0^32)
					MASK(#0^32);
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, UFMSavedFuseMap);
	fclose 	NewFile;			
}
function I2CFEATURE_SAVE_ARRAY
{
	datastream SaveFeatureArray[1][64];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][80];
	file NewFile = "FILE_SAVE";		
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 	  
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR 64   TDI(#1^64)
    		 TDO(SaveFeatureArray[1]);
	I2C_STOP;
	SaveFeatureArray[1] = $SaveFeatureArray[1];		     
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);  				    	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR 16   TDI(#1^16)
    		 TDO(SaveFeatureBitsArray[1]);
    I2C_STOP;
    SaveFeatureBitsArray[1] = $SaveFeatureBitsArray[1];
    FeatureSavedFuseMap[1] = (SaveFeatureBitsArray[1] @ SaveFeatureArray[1]); 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (ArchArray_TDI, FeatureSavedFuseMap);
	fclose 	NewFile;    	
}
function I2CREFRESH {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 24	TDI (0x00009E);
    I2C_STOP;
    RUN_TEST DELAY 200;	
}
function I2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK
{
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x000C8000);
			I2C_STOP;						  		  		    
		}
		ELSE {	
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	  
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");
		ProtectKey[1] = $ProtectKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;	
	    
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			I2C_START;
	    	! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);	
			I2C_STOP;					  	   				  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable...");
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0x3000);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO (0x00008000)
					  		MASK(0x000C8000);	
					  							  			
			I2C_STOP;					  					  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		
	}		
}
function SVFI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK
{
	IF (ISPROTECTED == 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x000C8000);
		I2C_STOP;						  		  		    
		print (0,"Programming the Password Key...");
		ProtectKey[1] = $ProtectKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;	
	    
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		print (0,"Verify the Password Key...");
		I2C_START;
    	! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR 32 TDI (0x0000004F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  64 TDI(#0^64)
				  	   TDO(ProtectKey[1]);	
		I2C_STOP;					  	   				  		  		    
		print (0, "Programming the Password Key Enable...");
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0x3000);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key Enable...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO (0x00008000)
				  		MASK(0x000C8000);	
				  							  			
		I2C_STOP;					  					  		  		    							  								  		
	}		
}
function I2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x000C8000);
			I2C_STOP;						  		  		    
		}
		ELSE {	
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	  
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");
		ProtectKey[1] = $ProtectKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;	
	    
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			I2C_START;
	    	! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  64 TDI(#0^64)
					  	   TDO(ProtectKey[1]);	
			I2C_STOP;					  	   				  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable and Keylock...");
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0xB000);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key Enable and Keylock...");
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO (0x04008000)
					  		MASK(0x040C8000);	
			I2C_STOP;					  					  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		
	}				  				  		  		  
}
function SVFI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK 
{	   
	IF (ISPROTECTED == 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x000C8000);
		I2C_STOP;						  		  		    
		print (0,"Programming the Password Key...");
		ProtectKey[1] = $ProtectKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	    SDR 32	TDI (0x00004062);
	    I2C_STOP;	
	    
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 64 TDI(ProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		print (0,"Verify the Password Key...");
		I2C_START;
    	! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR 32 TDI (0x0000004F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  64 TDI(#0^64)
				  	   TDO(ProtectKey[1]);	
		I2C_STOP;					  	   				  		  		    
		print (0, "Programming the Password Key Enable and Keylock...");
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0xB000);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key Enable and Keylock...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO (0x04008000)
				  		MASK(0x040C8000);	
		I2C_STOP;					  					  		  		    									  								  		
	}					  				  		  		  
}
function ASC_INIT {
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	TRY 1{
		! Shift in BYPASS(0xFF) instruction;
	    SIR_TRY_VERIFY	Instruction_Length 	TDI (BYPASS)
										    TDO(0x04)
										    MASK(0x84);
		! Shift in LSC_ENABLE_X(0x74) instruction;
	    SIR Instruction_Length TDI (LSC_ENABLE_X);
	    SDR 8 TDI(0x00);
		RUN_TEST	IDLE	TCK 2 DELAY 10;
	}	
	ELSE
	{
	}
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
} 
function ASC_BACKGROUND_INIT {
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	TRY 1{
		! Shift in BYPASS(0xFF) instruction;
	    SIR_TRY_VERIFY	Instruction_Length 	TDI (BYPASS)
										    TDO(0x04)
										    MASK(0x84);
		! Shift in LSC_ENABLE_X(0x74) instruction;
	    SIR Instruction_Length TDI (LSC_ENABLE_X);
	    SDR 8 TDI(0x00);
		RUN_TEST	IDLE	TCK 2 DELAY 10;
	}
	ELSE
	{
	}
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
} 
function ASC_BACKGROUND_SVF_INIT {
	STATE IDLE;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;	
	//! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	//SIR 8 TDI (0x9C);
	//! I2C Prescale Control Register Setting;
	//SDR 16 TDI(0x8000);                  
	//RUN_TEST	IDLE TCK 2 DELAY 1;		
}
function ASC_SVF_INIT {
	STATE IDLE;
	//! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	//SIR 8 TDI (0x9C);
	//! I2C Prescale Control Register Setting;
	//SDR 16 TDI(0x8000);                  
	//RUN_TEST	IDLE TCK 2 DELAY 1;		
} 
function ASC_CHECK_MUTEX_PRINT 
{
	int32	MutexBusy = 0;
	MutexOn = 0;
	TRY 1{
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Select ROMDATA;
		SDR 21 TDI (#100000000000000000110);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Enable ER2;
		SIR 8 TDI (0x38);
		! Read ROMDATA;
		SDR_TRY_VERIFY 256 TDI (0x0000000000000000000000000000000000000000000000000000000000000000) 
					       TDO (0x0000000000000000000000000000000000000000000000000000000070000143) 
					       MASK (0x00000000000000000000000000000000000000000000000000000000F00000FF);
		print (0,"The Mutex is Enabled.");
		! Set Target Hubs;
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Set MTX core;
		SDR 21 TDI (#000000000000000010110);
		RUN_TEST IDLE TCK 2 DELAY 1;
		// Write/read 18bit control register for mutex core;
		// bit17: 1;
		// bit16: 1=read, 0=write;
		// bit15-12: not used;
		// bit11-8: mutex register number;
		// bit7-4: ID;
		// bit3-0: VALUE;
		! Enable ER2;
		SIR 8 TDI (0x38);
		SDR 18 TDI (#110000000000000000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		TRY 1{
			SDR_TRY_VERIFY 18 TDI(#110000000000000000) 
					  	      TDO (#000000000000000000)
					          MASK(#000000000000001111);
		}
		ELSE
		{	  
			print (0,"The Mutex is currently busy. Please wait..."); 
			MutexBusy = 1;   
			loop 1000 {
				RUN_TEST IDLE TCK 2 DELAY 1000;
				SIR 8 TDI (0x38);
				SDR 18 TDI (#110000000000000000);
				RUN_TEST IDLE TCK 2 DELAY 1;
				SDR_VERIFY 18 TDI(#110000000000000000) 
						  	  TDO (#000000000000000000)
						      MASK(#000000000000001111);				
			}
			MutexBusy = 0;
			
		}
		! Enable ER2;
		SIR 8 TDI (0x38);
		//! Write Mutex0 with ID=0x5, VALUE=0x5;
		! Write Mutex 0;
		SDR 18 TDI (#100000000001010101);
		RUN_TEST IDLE TCK 2 DELAY 1;
		MutexOn = 1;
	}
	ELSE
	{
		IF (MutexBusy == 0x01)
		{
			print (1,"The Mutex is currently busy. Cannot continue.");
		}
	}
}
function ASC_CHECK_MUTEX 
{
	int32	MutexBusy = 0;
	MutexOn = 0;
	TRY 1{
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Select ROMDATA;
		SDR 21 TDI (#100000000000000000110);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Enable ER2;
		SIR 8 TDI (0x38);
		! Read ROMDATA;
		SDR_TRY_VERIFY 256 TDI (0x0000000000000000000000000000000000000000000000000000000000000000) 
					       TDO (0x0000000000000000000000000000000000000000000000000000000070000143) 
					       MASK (0x00000000000000000000000000000000000000000000000000000000F00000FF);
		! Set Target Hubs;
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Set MTX core;
		SDR 21 TDI (#000000000000000010110);
		RUN_TEST IDLE TCK 2 DELAY 1;
		// Write/read 18bit control register for mutex core;
		// bit17: 1;
		// bit16: 1=read, 0=write;
		// bit15-12: not used;
		// bit11-8: mutex register number;
		// bit7-4: ID;
		// bit3-0: VALUE;
		! Enable ER2;
		SIR 8 TDI (0x38);
		SDR 18 TDI (#110000000000000000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		TRY 1{
			SDR_TRY_VERIFY 18 TDI(#110000000000000000) 
					  	      TDO (#000000000000000000)
					          MASK(#000000000000001111);
		}
		ELSE
		{	
			print (0,"The Mutex is currently busy. Please wait...");   
			MutexBusy = 1;   
			loop 1000 {
				RUN_TEST IDLE TCK 2 DELAY 1000;
				SIR 8 TDI (0x38);
				SDR 18 TDI (#110000000000000000);
				RUN_TEST IDLE TCK 2 DELAY 1;
				SDR_VERIFY 18 TDI(#110000000000000000) 
						  	  TDO (#000000000000000000)
						      MASK(#000000000000001111);				
			}
			MutexBusy = 0;
			
		}
		! Enable ER2;
		SIR 8 TDI (0x38);
		//! Write Mutex0 with ID=0x5, VALUE=0x5;
		! Write Mutex 0;
		SDR 18 TDI (#100000000001010101);
		RUN_TEST IDLE TCK 2 DELAY 1;
		MutexOn = 1;
	}
	ELSE
	{
		IF (MutexBusy == 0x01)
		{
			print (1,"The Mutex is currently busy. Cannot continue.");
		}
	}
}
function ASC_CHECK_MUTEX_SVF 
{
	! Set Target Hubs;
	! Enable ER1;
	SIR 8 TDI (0x32);
	! Set MTX core;
	SDR 21 TDI (#000000000000000010110);
	RUN_TEST IDLE TCK 2 DELAY 1;
	// Write/read 18bit control register for mutex core;
	// bit17: 1;
	// bit16: 1=read, 0=write;
	// bit15-12: not used;
	// bit11-8: mutex register number;
	// bit7-4: ID;
	// bit3-0: VALUE;
	SIR 8 TDI (0x38);
	SDR 18 TDI (#110000000000000000);
	RUN_TEST IDLE TCK 2 DELAY 1;
	SDR_VERIFY 18 TDI(#110000000000000000) 
						  TDO (#000000000000000000)
						  MASK(#000000000000001111);
	RUN_TEST IDLE TCK 2 DELAY 1000;
	! Enable ER2;
	SIR 8 TDI (0x38);
	//! Write Mutex0 with ID=0x5, VALUE=0x5;
	! Write Mutex 0;
	SDR 18 TDI (#100000000001010101);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function ASCREAD_ID	{
	datastream	IDArray[1][8];
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	16	TDI (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (IDArray[1]);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	IF (IDArray[1] == ASCID)
	{
	}
	ELSEIF (IDArray[1] == 0x8A)
	{
	}
	ELSEIF (IDArray[1] == 0x89)
	{
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}		
		print (1,"Failed to read the Device's IDCODE.");
	}
}	
function ASCREAD_ID_INTERNAL {
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI ((0x50) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;	
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}	
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
		SDR	16	TDI (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (ISPID)
						MASK (0xFF);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;	
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}	
		print (1,"Failed to read the Device's IDCODE. ");
	}
}	
function ASCREAD_ID_SVF	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI ((0x50) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	16	TDI (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (ASCID)
					MASK (0x00);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASCSAVE_ID	{
	datastream SavedID[1][8];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	16	TDI (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (SavedID[1]);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;			
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function ASCSAVE_ID_SVF	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	16	TDI (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function ASC_ENABLE	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_ENPROG(0x04) instruction;
	SDR	16	TDI (0x1004); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in PROG MODE KEY1;
	SDR	16	TDI (0x103D); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in PROG MODE KEY2;
	SDR	16	TDI (0x10E5); 
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	TRY 1{
		SDR_VERIFY 8 TDI(0x00)
					 TDO(0x10)
					 MASK(0x90);	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}
		print (1,"Failed to enter the programming mode. Cannot continue.");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
} 
function ASC_ENABLE_SVF	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_ENPROG(0x04) instruction;
	SDR	16	TDI (0x1004); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in PROG MODE KEY1;
	SDR	16	TDI (0x103D); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in PROG MODE KEY2;
	SDR	16	TDI (0x10E5); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				 TDO(0x10)
				 MASK(0x90);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;		
} 
function ASC_ERASE_I2CSA	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_ERASEI2CSA(0x11) instruction;
	SDR	16	TDI (0x1011); 
	RUN_TEST	IDLE TCK 2 DELAY PWE;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($DEFAULT_ADDR_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	TRY 1{
		SDR_VERIFY 8 TDI(0x00)
					 TDO(0x00)
					 MASK(0xA1);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1; 
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}
		print (1,"Failed to erase the I2CSA. Cannot continue.");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function ASC_ERASE_I2CSA_SVF	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_ERASEI2CSA(0x11) instruction;
	SDR	16	TDI (0x1011); 
	RUN_TEST	IDLE TCK 2 DELAY PWE;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($DEFAULT_ADDR_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				 TDO(0x00)
				 MASK(0xA1);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
		
}
function ASC_PROGRAM_I2CSA	{
	datastream JTAGI2CNWRITE[1][8];
	datastream NADDRWRITE[1][8];
	datastream JTAGI2CSLAVENADDRREAD[1][8];
	
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	NADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	NADDRWRITE[1] = $NADDRWRITE[1];
	NADDRWRITE[1] = (NADDRWRITE[1] & 0x0F);
	NADDRWRITE[1] = (NADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	JTAGI2CSLAVENADDRREAD[1] = (NADDRWRITE[1] | 0x01);

	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE)); 
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_WRITEI2CSA(0x12) instruction;
	SDR	16	TDI (0x1012); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x10) @ (JTAGI2CNWRITE[1])); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE)); 
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_PROGI2CSA(0x14) instruction;
	SDR	16	TDI (0x1014); 
	RUN_TEST	IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 100;
		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (NADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ (JTAGI2CSLAVENADDRREAD[1]));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	TRY 1{
		SDR_VERIFY 8 TDI(0x00)
					 TDO(0x20)
					 MASK(0x20);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1; 
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}
		print (1,"Failed to program the I2CSA. Cannot continue.");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;					
}
function ASC_PROGRAM_I2CSA_SVF	{
	datastream JTAGI2CNWRITE[1][8];
	datastream NADDRWRITE[1][8];
	datastream JTAGI2CSLAVENADDRREAD[1][8];
	
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	NADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	NADDRWRITE[1] = $NADDRWRITE[1];
	NADDRWRITE[1] = (NADDRWRITE[1] & 0x0F);
	NADDRWRITE[1] = (NADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	JTAGI2CSLAVENADDRREAD[1] = (NADDRWRITE[1] | 0x01);

	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE)); 
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_WRITEI2CSA(0x12) instruction;
	SDR	16	TDI (0x1012); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x10) @ (JTAGI2CNWRITE[1])); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($DEFAULT_ADDR_WRITE)); 
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_PROGI2CSA(0x14) instruction;
	SDR	16	TDI (0x1014); 
	RUN_TEST	IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 100;
		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (NADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ (JTAGI2CSLAVENADDRREAD[1]));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				 TDO(0x20)
				 MASK(0x20);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;    		
}
function ASC_ERASE_BECFG
{
	TRY 1{
		! Erase ASC;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_BECFG(0x21) instruction;
		SDR	16	TDI (0x1021); 
		loop 1000 {
			RUN_TEST IDLE TCK 2 DELAY 10;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
			SDR	16	TDI (0x1003); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2800);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY 8 TDI(0x00)
				  		 TDO(0x00)
				         MASK(0x01);		
		}	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	16	TDI (0x1005); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 20;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
	    {
	    	MutexOn = 0;
		}		
		print (1, "Failed in Function ERASE /see log file for more details/ ");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	 
}
function ASC_ERASE_BECFG_SVF {
	! Erase ASC;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_BECFG(0x21) instruction;
	SDR	16	TDI (0x1021); 
	RUN_TEST IDLE TCK 2 DELAY 100; 
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY 8 TDI(0x00)
		  		 TDO(0x00)
		         MASK(0x00);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST	IDLE TCK 1000 ;
}
function ASCCHECK_STATUS {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	TRY 1{
		SDR_VERIFY 8 TDI(0x00)
					 TDO(0x00)
					 MASK(0x81);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	16	TDI (0x1005); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 20;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1; 
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}
		print (1,"CRC Error. Cannot continue.");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST	IDLE TCK 1000 ;
	
}

function ASCCHECK_STATUS_SVF {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				 TDO(0x00)
				 MASK(0x81);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;		
}
function ASC_PROGRAM_STATUS	
{
	datastream ASCTmpDataArray[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	CFGArray_TDI.row = 1;
	Address_CFG.row = 1;
	TRY 1{
		repeat 14 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			ASCTmpDataArray[1] = CFGArray_TDI[RowCount]; 
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR 8 TDI(0x9D);
			! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
			SDR	16	TDI (0x1022); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = ASCTmpDataArray[1];
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 8);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 16);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (ASCTmpDataArray[1] << 24);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 32);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 40);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 48);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ASCTmpDataArray[1] << 56);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
			SDR	16	TDI (0x1024); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Row Address;
			SDR	16	TDI ( Address_CFG[RowAddr]);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 100;
			RowAddr = RowAddr + 1;
			RowCount = RowCount +1;	
		}	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	16	TDI (0x1005); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 20;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}	
		ELSE
		{
			MutexOn = 0;
		}	
		print (1, "Failed in Function PROGRAM /see log file for more details/ ");
	}
}		
function ASC_PROGRAM_STATUS_SVF	
{
	datastream ASCTmpDataArray[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	
	CFGArray_TDI.row = 1;
	Address_CFG.row = 1;
	repeat 14 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		ASCTmpDataArray[1] = CFGArray_TDI[RowCount]; 
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR 8 TDI(0x9D);
		! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	16	TDI (0x1022); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = ASCTmpDataArray[1];
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 8);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 16);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ASCTmpDataArray[1] << 24);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 32);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 40);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 48);		
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ASCTmpDataArray[1] << 56);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	16	TDI (0x1024); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI (Address_CFG[RowAddr]); 
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 50;
		RowAddr = RowAddr + 1;
		RowCount = RowCount +1;	
	}		
}																																				
function ASC_VERIFY	{
	datastream DataByte[1][8];
	datastream TmpVerifyDataArray[1][64];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	CFGArray_TDI.row = 1;
	Address_CFG.row = 1;
	TRY 1 {	
		repeat 14 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
			SDR	16	TDI (0x1025); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Row Address;
			SDR	16	TDI (Address_CFG[RowAddr]); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x2000); 
			RUN_TEST IDLE TCK 1000 ;
			TmpVerifyDataArray[1] = CFGArray_TDI[RowCount];
			! Shift out Data Row = RowCount; 	
	    	DataByte[1] = (TmpVerifyDataArray[1]);
	    	DataByte[1] = $DataByte[1];
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 8);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 16);			
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 24);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpVerifyDataArray[1] << 32);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 40);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 48);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpVerifyDataArray[1] << 56);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x2800);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			RowAddr = RowAddr + 1;
			RowCount = RowCount +1;	
		}			
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	16	TDI (0x1005); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 20;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}		
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}		
}	
function ASC_VERIFY_SVF	{
	datastream DataByte[1][8];
	datastream TmpVerifyDataArray[1][64];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	CFGArray_TDI.row = 1;
	Address_CFG.row = 1;	
	repeat 14 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	16	TDI (0x1025); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI (Address_CFG[RowAddr]); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x2000); 
		RUN_TEST IDLE TCK 1000 ;
		TmpVerifyDataArray[1] = CFGArray_TDI[RowCount];
		! Shift out Data Row = RowCount; 	
    	DataByte[1] = (TmpVerifyDataArray[1]);
    	DataByte[1] = $DataByte[1];
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 8);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 16);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 24);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;	
		DataByte[1] = (TmpVerifyDataArray[1] << 32);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 40);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 48);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpVerifyDataArray[1] << 56);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		RowAddr = RowAddr + 1;
		RowCount = RowCount +1;	
	}
}	
function ASC_PROGRAM_DONE_BIT {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_PROGDONE(0x27) instruction;
	SDR	16	TDI (0x1027); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 100;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	TRY 1{
		SDR_VERIFY 8 TDI(0x00)
					 TDO(0x40)
					 MASK(0xC0);
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	16	TDI (0x1005); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 20;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		IF (MutexOn == 0x01)
		{
			! Restore Mutex;
			! Enable ER1;
			SIR 8 TDI (0x32);
			! Set MTX core;
			SDR 21 TDI (0x000016);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Enable ER2;
			SIR 8 TDI (0x38);
			! Write Mutex0 with ID=0x5, VALUE=0x0;
			SDR 18 TDI (0x020050);
			RUN_TEST IDLE TCK 2 DELAY 1;
			MutexOn = 0;
		}
		ELSE
		{
			MutexOn = 0;
		}
		print (1,"Failed to program the DONE. Cannot continue.");
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}	
function ASC_PROGRAM_DONE_BIT_SVF {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_PROGDONE(0x27) instruction;
	SDR	16	TDI (0x1027); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 100;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				 TDO(0x40)
				 MASK(0xC0);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function ASC_DIRECT_DISABLE_WITH_NEW_ADDR {
	datastream JTAGI2CNWRITE[1][8];
	datastream DISABLENADDRWRITE[1][8];
	
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	DISABLENADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	DISABLENADDRWRITE[1] = $DISABLENADDRWRITE[1];
	DISABLENADDRWRITE[1] = (DISABLENADDRWRITE[1] & 0x0F);
	DISABLENADDRWRITE[1] = (DISABLENADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (DISABLENADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (DISABLENADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;
	DISABLENADDRWRITE[1] = (DISABLENADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,DISABLENADDRWRITE);			
}
function ASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF {
	datastream JTAGI2CNWRITE[1][8];
	datastream DISABLENADDRWRITE[1][8];
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	DISABLENADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	DISABLENADDRWRITE[1] = $DISABLENADDRWRITE[1];
	DISABLENADDRWRITE[1] = (DISABLENADDRWRITE[1] & 0x0F);
	DISABLENADDRWRITE[1] = (DISABLENADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (DISABLENADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (DISABLENADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;
	
}
function ASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;
	JTAGI2CSLAVEADDRWRITE[1] = (JTAGI2CSLAVEADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address:");
	print (0,JTAGI2CSLAVEADDRWRITE);
}
function ASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;	
}
function ASC_DIRECT_DISABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;
}
function ASC_DIRECT_DISABLE_SVF {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;
}
function ASC_EXIT_USERMODE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
}
function ASC_EXIT_USERMODE_BACKGROUND {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	IF (MutexOn == 0x01)
	{
		! Restore Mutex;
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Set MTX core;
		SDR 21 TDI (0x000016);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Enable ER2;
		SIR 8 TDI (0x38);
		! Write Mutex0 with ID=0x5, VALUE=0x0;
		SDR 18 TDI (0x020050);
		RUN_TEST IDLE TCK 2 DELAY 1;
		MutexOn = 0;
	}
	
}
function ASC_EXIT_USERMODE_BACKGROUND_SVF {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	! Restore Mutex;
	! Enable ER1;
	SIR 8 TDI (0x32);
	! Set MTX core;
	SDR 21 TDI (0x000016);
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Enable ER2;
	SIR 8 TDI (0x38);
	! Write Mutex0 with ID=0x5, VALUE=0x0;
	SDR 18 TDI (0x020050);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function ASC_EXIT_USERMODE_WITH_NEW_ADDR {
	datastream JTAGI2CNWRITE[1][8];
	datastream EXITNADDRWRITE[1][8];
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	EXITNADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	EXITNADDRWRITE[1] = $EXITNADDRWRITE[1];
	EXITNADDRWRITE[1] = (EXITNADDRWRITE[1] & 0x0F);
	EXITNADDRWRITE[1] = (EXITNADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (EXITNADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;	
		
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	IF (MutexOn == 0x01)
	{
		! Restore Mutex;
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Set MTX core;
		SDR 21 TDI (0x000016);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Enable ER2;
		SIR 8 TDI (0x38);
		! Write Mutex0 with ID=0x5, VALUE=0x0;
		SDR 18 TDI (0x020050);
		RUN_TEST IDLE TCK 2 DELAY 1;
		MutexOn = 0;
	}
	EXITNADDRWRITE[1] = (EXITNADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,EXITNADDRWRITE);			
}
function ASC_EXIT_USERMODE_WITH_NEW_ADDR_SVF {
	datastream JTAGI2CNWRITE[1][8];
	datastream EXITNADDRWRITE[1][8];
	JTAGI2CNWRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CNWRITE[1] = $JTAGI2CNWRITE[1];
	
	EXITNADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	EXITNADDRWRITE[1] = $EXITNADDRWRITE[1];
	EXITNADDRWRITE[1] = (EXITNADDRWRITE[1] & 0x0F);
	EXITNADDRWRITE[1] = (EXITNADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (EXITNADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;	
		
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	! Restore Mutex;
	! Enable ER1;
	SIR 8 TDI (0x32);
	! Set MTX core;
	SDR 21 TDI (0x000016);
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Enable ER2;
	SIR 8 TDI (0x38);
	! Write Mutex0 with ID=0x5, VALUE=0x0;
	SDR 18 TDI (0x020050);
	RUN_TEST IDLE TCK 2 DELAY 1;	
}
function ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	IF (MutexOn == 0x01)
	{
		! Restore Mutex;
		! Enable ER1;
		SIR 8 TDI (0x32);
		! Set MTX core;
		SDR 21 TDI (0x000016);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Enable ER2;
		SIR 8 TDI (0x38);
		! Write Mutex0 with ID=0x5, VALUE=0x0;
		SDR 18 TDI (0x020050);
		RUN_TEST IDLE TCK 2 DELAY 1;
		MutexOn = 0;
	}
	JTAGI2CSLAVEADDRWRITE[1] = (JTAGI2CSLAVEADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address:");
	print (0,JTAGI2CSLAVEADDRWRITE);
}
function ASC_EXIT_USERMODE_WITH_DEFAULT_ADDR_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	16	TDI (0x1005); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1;
	! Restore Mutex;
	! Enable ER1;
	SIR 8 TDI (0x32);
	! Set MTX core;
	SDR 21 TDI (0x000016);
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Enable ER2;
	SIR 8 TDI (0x38);
	! Write Mutex0 with ID=0x5, VALUE=0x0;
	SDR 18 TDI (0x020050);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function ASC_REFRESH {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	16	TDI (0x1028); 	
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 DELAY PWP;
}
function ASCPROGRAM_USERCODE	{
	datastream DataByte[1][8];
	IF (Usercode_TDO.row = 1)
	{
		TRY 1{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
			SDR	16	TDI (0x1022); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = Usercode_TDO[1];
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 8);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 16);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 24);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 32);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 40);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 48);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 56);
			DataByte[1] = $DataByte[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
			SDR	16	TDI (0x1024); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Row Address;
			SDR	16	TDI ( 0x1070);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 100;	
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
			SDR	16	TDI (0x1005); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 20;	
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			IF (MutexOn == 0x01)
			{
				! Restore Mutex;
				! Enable ER1;
				SIR 8 TDI (0x32);
				! Set MTX core;
				SDR 21 TDI (0x000016);
				RUN_TEST IDLE TCK 2 DELAY 1;
				! Enable ER2;
				SIR 8 TDI (0x38);
				! Write Mutex0 with ID=0x5, VALUE=0x0;
				SDR 18 TDI (0x020050);
				RUN_TEST IDLE TCK 2 DELAY 1;
				MutexOn = 0;
			}	
			ELSE
			{
				MutexOn = 0;
			}	
			print (1, "Failed in Function PROGRAM USERCODE /see log file for more details/ ");
		}
	}	
}
function ASCPROGRAM_USERCODE_SVF	{
	datastream DataByte[1][8];
	IF (Usercode_TDO.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	16	TDI (0x1022); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = Usercode_TDO[1];
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 8);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 16);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 24);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 32);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 40);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 48);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 56);
		DataByte[1] = $DataByte[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	16	TDI (0x1024); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI ( 0x1070);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 100;
	}	
}
function ASCVERIFY_USERCODE {
	datastream DataByte[1][8];
	IF (Usercode_TDO.row = 1)
	{
		TRY 1{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ; 
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
			SDR	16	TDI (0x1025); 
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in Row Address;
			SDR	16	TDI (0x1070); 
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR 8 TDI(0x9E);
			DataByte[1] = (Usercode_TDO[1]);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 8);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 16);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (Usercode_TDO[1] << 24);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;			 
			DataByte[1] = (Usercode_TDO[1] << 32);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;			 
			DataByte[1] = (Usercode_TDO[1] << 40);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;			 
			DataByte[1] = (Usercode_TDO[1] << 48);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);	
			RUN_TEST IDLE TCK 1000 ;			 
			DataByte[1] = (Usercode_TDO[1] << 56);
			DataByte[1] = $DataByte[1];
			SDR_VERIFY 8 TDI(0x00)
						 TDO(DataByte[1]);
						 			 			 			 
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x2800);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
			SDR	16	TDI (0x1005); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 20;	
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			IF (MutexOn == 0x01)
			{
				! Restore Mutex;
				! Enable ER1;
				SIR 8 TDI (0x32);
				! Set MTX core;
				SDR 21 TDI (0x000016);
				RUN_TEST IDLE TCK 2 DELAY 1;
				! Enable ER2;
				SIR 8 TDI (0x38);
				! Write Mutex0 with ID=0x5, VALUE=0x0;
				SDR 18 TDI (0x020050);
				RUN_TEST IDLE TCK 2 DELAY 1;
				MutexOn = 0;
			}
			ELSE
			{
				MutexOn = 0;
			}		
			print (1, "Failed in Function VERIFY USERCODE /see log file for more details/ ");
		}
	}
	
}
function ASCVERIFY_USERCODE_SVF {
	datastream DataByte[1][8];
	IF (Usercode_TDO.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	16	TDI (0x1025); 
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Row Address;
		SDR	16	TDI (0x1070); 
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR 8 TDI(0x9E);
		DataByte[1] = (Usercode_TDO[1]);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 8);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 16);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (Usercode_TDO[1] << 24);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;			 
		DataByte[1] = (Usercode_TDO[1] << 32);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;			 
		DataByte[1] = (Usercode_TDO[1] << 40);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;			 
		DataByte[1] = (Usercode_TDO[1] << 48);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);	
		RUN_TEST IDLE TCK 1000 ;			 
		DataByte[1] = (Usercode_TDO[1] << 56);
		DataByte[1] = $DataByte[1];
		SDR_VERIFY 8 TDI(0x00)
					 TDO(DataByte[1]);
					 			 			 			 
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;  
	}
}
function ASCSAVE_USERCODE {
	datastream ASCSavedUsercode[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
	SDR	16	TDI (0x1025); 
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Row Address;
	SDR	16	TDI (0x1070); 
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ASCSavedUsercode[1] = ((ASCSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ASCSavedUsercode[1] = ((ASCSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	ASCSavedUsercode[1] = ((ASCSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	ASCSavedUsercode[1] = ((ASCSavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;  
	ASCSavedUsercode[1] = $ASCSavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDO, ASCSavedUsercode);
	fclose 	NewFile;
}
function ASC_SAVE	
{
	datastream ASCSavedArray[1][896];
	datastream DataByte[1][8];
	int32	RowAddr = 1;
	file NewFile = "FILE_SAVE";
	Address_CFG.row = 1;
	repeat 14 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	16	TDI (0x1025); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI (Address_CFG[RowAddr]); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR 8 TDI(0x9E);
		! Shift out first byte of data;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ASCSavedArray[1] = ((ASCSavedArray[1]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		RowAddr = RowAddr + 1;		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	ASCSavedArray[1] = $ASCSavedArray[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (SysIOArray_TDI, ASCSavedArray);
	fclose 	NewFile;
}

function ASC_READ_SHADOW_REGISTERS
{
	datastream ShadowSavedArray[1][896];
	datastream ShadowSavedRowArray[1][64];
	datastream DataByte[1][8];
	int32	RowAddr = 1;
	Address_CFG.row = 1;
	repeat 14 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ASC_I2C_INSTR_RDSHDW(0x33) instruction;
		SDR	16	TDI (0x1033); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI (Address_CFG[RowAddr]); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR 8 TDI(0x9E);
		! Shift out first byte of data;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = DataByte[1];
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		ShadowSavedRowArray[1] = ((ShadowSavedRowArray[1]) @ (DataByte[1])) << 8;
		ShadowSavedArray[1] = ((ShadowSavedArray[1]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		RowAddr = RowAddr + 1;	
		print (0,ShadowSavedRowArray);	
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function ASC_READ_SHADOW_REGISTERS_SVF
{
	int32	RowAddr = 1;
	Address_CFG.row = 1;
	repeat 14 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ASC_I2C_INSTR_RDSHDW(0x33) instruction;
		SDR	16	TDI (0x1033); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Row Address;
		SDR	16	TDI (Address_CFG[RowAddr]); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR 8 TDI(0x9E);
		! Shift out first byte of data;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(0x00)
			  MASK(0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		RowAddr = RowAddr + 1;	
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_SAVE_FAULTLOG_REGISTERS
{
	datastream SavedFaultLogReg[1][56];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSOFTFAULT(0x73) instruction;
	SDR	16	TDI (0x1073); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDVERFAULT(0x75) instruction;
	SDR	16	TDI (0x1075); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in row address;
	SDR	16	TDI (0x1000); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	SavedFaultLogReg[1] = ((SavedFaultLogReg[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	print (0,SavedFaultLogReg);
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedFaultLogReg);
	fclose 	NewFile;
}
function ASC_SAVE_FAULTLOG_REGISTERS_SVF
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDSOFTFAULT(0x73) instruction;
	SDR	16	TDI (0x1073); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDVERFAULT(0x75) instruction;
	SDR	16	TDI (0x1075); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in row address;
	SDR	16	TDI (0x1000); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
				  TDO(0x00)
				  MASK(0x00);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_ERASE_FAULTLOG_MEMORY
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_ERASEFAULT(0x71) instruction;
	SDR	16	TDI (0x1071); 
	RUN_TEST IDLE TCK 2 DELAY 10;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_ERASE_FAULTLOG_FULL_MEMORY
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	16	TDI (0x1076); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
			 	 TDO(0x00)
			 	 MASK(0x01);					 
	TRY 1 {
		RUN_TEST IDLE TCK 1000 ;
		SDR_TRY_VERIFY 8 TDI(0x00)
				 	 TDO(0x08)
				 	 MASK(0x08);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		print (0,"FaultLog is full. Erasing Faultlog memory...");
		! Shift in ASC_I2C_INSTR_ERASEFAULT(0x71) instruction;
		SDR	16	TDI (0x1071); 
		RUN_TEST IDLE TCK 2 DELAY 10;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x2800);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
	}
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_SAVE_FAULTLOG_MEMORY
{
	datastream SavedFaultLogRow[1][56];
	datastream DataByte[1][8];

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	16	TDI (0x1076); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	repeat 16 {
		SDR 8 TDI(0x00)
		  	  TDO(DataByte[1]);
		SavedFaultLogRow[1] = DataByte[1];
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		SavedFaultLogRow[1] = ((SavedFaultLogRow[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		print (0,SavedFaultLogRow);
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_SAVE_FAULTLOG_MEMORY_SVF
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Read Fault keycode (0xAC);
	SDR	16	TDI (0x10AC); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	16	TDI (0x1076); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	repeat 16 {
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY 8 TDI(0x00)
		  	  		 TDO(0x00)
		  	  		 MASK(0x00);
		RUN_TEST IDLE TCK 1000 ;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	! Disable FaultLog Read;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	16	TDI (0x1074); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI (0x10FF); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function ASC_SAVE_STATUS
{
	datastream ASCSavedSTATUS[1][16];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	ASCSavedSTATUS[1] = ((ASCSavedSTATUS[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR 8 TDI(0x00)
		  TDO(DataByte[1]);
	ASCSavedSTATUS[1] = ((ASCSavedSTATUS[1]) @ (DataByte[1])) << 8;	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 			
	ASCSavedSTATUS[1] = $ASCSavedSTATUS[1];
	//print (0,ASCSavedSTATUS);	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, ASCSavedSTATUS);
	fclose 	NewFile;	
}
function ASC_SAVE_STATUS_SVF
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	16	TDI (0x1003); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR 8 TDI(0x9E);
	SDR_VERIFY 8 TDI(0x00)
		  		 TDO(0x00)
		  		 MASK(0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY 8 TDI(0x00)
		  		 TDO(0x00)
		  		 MASK(0x00);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x2800);
	RUN_TEST IDLE TCK 1000 ;
	SIR	8	TDI  (0x9E);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 			
}


function JTAGI2CINIT {
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
    
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;		
}
function JTAGI2CINIT_SVF {
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 186)
    {
    	Temp_Row_Count = 575;
    	Temp_UFM_Count = 0;
    }
    ELSEIF (Address_Length == 215)
    {
    	Temp_Row_Count = 1151;
    	Temp_UFM_Count = 192;
    }
    ELSEIF (Address_Length == 333)
    {
    	Temp_Row_Count = 2175;
    	Temp_UFM_Count = 512;
    }
    ELSEIF (Address_Length == 420)
    {
    	Temp_Row_Count = 3198;
    	Temp_UFM_Count = 640;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5758;
    	Temp_UFM_Count = 768;
    }
    ELSEIF (Address_Length == 770)
    {
    	Temp_Row_Count = 9212;
    	Temp_UFM_Count = 2048;
    }
    ELSEIF (Address_Length == 888)
    {
    	Temp_Row_Count = 12540;
    	Temp_UFM_Count = 3584;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
    ! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
}
function JTAGI2CREAD_ID {

	datastream DataByte[1][8];
	datastream MaskByte[1][8];
	datastream DataIDMask[1][32];
	DataIDMask[1] = DEVICE_ID_MASK;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	16	TDI (0x10E0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (IDTDI[1]);
		MaskByte[1] = (DataIDMask[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 8);
		MaskByte[1] = (DataIDMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 16);
		MaskByte[1] = (DataIDMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 24);
		MaskByte[1] = (DataIDMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);								
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function JTAGI2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	16	TDI (0x10E0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;			
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function JTAGI2CSRAM_ENABLE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CSRAM_TRANSPARENT_READ_ENABLE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}

function JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CSRAM_ERASE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 10;
}
function JTAGI2CBURST_PROGRAM
{
	datastream DataByte[1][8];
	int32	ByteCount = 1;
	int32	i = 0;
	FuseArray_TDI.row = 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
	SDR	16	TDI (0x107A);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	ByteCount = TotalFuse/8;
	FuseArray_TDI[1] = $FuseArray_TDI[1];
	repeat ByteCount {
		DataByte[1] = (FuseArray_TDI[1] << i);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;	
		i = i + 8;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function JTAGI2CFLASH_ENABLE	{
	// SRAM Erase
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;				
}
function JTAGI2CFLASH_ENABLE_READ_ID
{
	datastream DataByte[1][8];
	datastream MaskByte[1][8];
	datastream DataIDMask[1][32];
	DataIDMask[1] = DEVICE_ID_MASK;
	// SRAM Erase
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	16	TDI (0x10E0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (IDTDI[1]);
		MaskByte[1] = (DataIDMask[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 8);
		MaskByte[1] = (DataIDMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 16);
		MaskByte[1] = (DataIDMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 24);
		MaskByte[1] = (DataIDMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);								
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}
}
function JTAGI2CFEATURE_ENABLE	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CFLASH_TRANSPARENT_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CDISABLE	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	    	
}
function JTAGI2CFEATUREDISABLE {
	datastream JTAGI2CNEW_ADDR_WRITE[1][8];
	JTAGI2CNEW_ADDR_WRITE[1] = NEW_I2C_ADDR_WRITE ;
	JTAGI2CNEW_ADDR_WRITE[1] = $JTAGI2CNEW_ADDR_WRITE[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CNEW_ADDR_WRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;   
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	    	
}
function JTAGI2CBACKGROUND_DISABLE	{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;  
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100;
}
function JTAGI2CCHECK_STATUS {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;											
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (1,"Status Error. Cannot continue.");	
	}								
			
}
function JTAGI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK
{
	datastream DataByte[1][8];
	IF (ISPROTECTED == 1)
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x30);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;																		  				  			  
		}
		ELSE
		{										  		  		    	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;			
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");		
		
				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
	    
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		
		TRY 1 {
			DataByte[1] = ProtectKey[1];
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
		    DataByte[1] = (ProtectKey[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;													  	   				  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data; 
    	SDR	16	TDI (0x1000); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x100C); 
		RUN_TEST IDLE TCK 2 DELAY PWP;	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		print (0,"Verify the Password Key Enable...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x30);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;																						  					  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		
	}	
}
function SVFJTAGI2CPROGRAM_PROTECT_KEY_NO_FEATURE_LOCK
{
	datastream DataByte[1][8];
	IF (ISPROTECTED == 1)
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;																		  				  			  
			
		print (0,"Programming the Password Key...");		
						
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
	    
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		DataByte[1] = ProtectKey[1];
		SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1])
					MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
	    DataByte[1] = (ProtectKey[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 32);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (ProtectKey[1] << 40);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (ProtectKey[1] << 48);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 56);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;													  	   				  		  		    
								  		  		
		print (0, "Programming the Password Key Enable...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data; 
    	SDR	16	TDI (0x1000); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x100C); 
		RUN_TEST IDLE TCK 2 DELAY PWP;	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		print (0,"Verify the Password Key Enable...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;																						  					  		  		    							  								  		
	}		
}
function JTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK
{
	datastream DataByte[1][8];
	IF (ISPROTECTED == 1)
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x30);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;																		  				  			  
		}
		ELSE
		{										  		  		    	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;			
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		print (0,"Programming the Password Key...");		
		
				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
	    
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		
		TRY 1 {
			DataByte[1] = ProtectKey[1];
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
		    DataByte[1] = (ProtectKey[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;													  	   				  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			print (1,"Failed to Program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable and Keylock...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data; 
    	SDR	16	TDI (0x1000); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x100D); 
		RUN_TEST IDLE TCK 2 DELAY PWP;	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		print (0,"Verify the Password Key Enable and Keylock...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x30);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x20)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;																						  					  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
			print (1,"Failed to Program the Password Key Enable and Keylock.");
		}							  								  		  								  		
	}	
}
function SVFJTAGI2CPROGRAM_PROTECT_KEY_WITH_FEATURE_LOCK
{
	datastream DataByte[1][8];
	IF (ISPROTECTED == 1)
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;																		  				  			  
			
		print (0,"Programming the Password Key...");		
		
				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
	    
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		
		DataByte[1] = ProtectKey[1];
		SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1])
					MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
	    DataByte[1] = (ProtectKey[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 32);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (ProtectKey[1] << 40);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (ProtectKey[1] << 48);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (ProtectKey[1] << 56);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;													  	   				  		  		    
								  		  		
		print (0, "Programming the Password Key Enable and Keylock...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE)); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data; 
    	SDR	16	TDI (0x1000); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI (0x100D); 
		RUN_TEST IDLE TCK 2 DELAY PWP;	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		print (0,"Verify the Password Key Enable and Keylock...");
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;																						  					  		  		    
									  								  		  								  		
	}		
}
function JTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];
	datastream DataByte[1][8];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
		
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);																			  				  			  
	}
	ELSE
	{		
		IF (ProtectKey.row = 1)
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC ENABLE(0xC6) instruction;
			SDR	16	TDI (0x10C6);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;		
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR	16	TDI (0x10BC);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Password Key; 	
	    	DataByte[1] = ProtectKey[1];
	    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (ProtectKey[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);				
			TRY 1 {

				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x20);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;											  				  			  
			}
			ELSE
			{	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;		
				set_return_code (-93);			
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			set_return_code (-93);		
			print (1,"A Password Key is required. Please select a different operation.");
		}
	}			
}
function SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY_ENABLE
{
	datastream SaveProtectKey[1][64];
	datastream DataByte[1][8];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x02);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x40);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x40);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;					
	IF (ProtectKey.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC ENABLE(0xC6) instruction;
		SDR	16	TDI (0x10C6);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x20);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;																	  				  			  	
	}		
}
function JTAGI2CCHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];
	datastream DataByte[1][8];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
		
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);																			  				  			  
	}
	ELSE
	{		
		IF (ProtectKey.row = 1)
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
			SDR	16	TDI (0x10BC);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Password Key; 	
	    	DataByte[1] = ProtectKey[1];
	    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (ProtectKey[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (ProtectKey[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				
			! Shift in LSC_READ_STATUS(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);				
			TRY 1 {

				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x20);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;											  				  			  
			}
			ELSE
			{	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;		
				set_return_code (-93);			
				print (0,"The Password Key does not match the Password Key in the device.");
				print (1,"Please re-enter the Password Key.");
			}
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			set_return_code (-93);		
			print (1,"A Password Key is required. Please select a different operation.");
		}
	}			
}
function SVFJTAGI2CCHECK_SECURITY_PROTECT_KEY
{
	datastream SaveProtectKey[1][64];
	datastream DataByte[1][8];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x02);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x40);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x40);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;					
	IF (ProtectKey.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x01);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x20);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;																	  				  			  	
	}		
}
function JTAGI2CCHECK_SRAM_OTP 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x02);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The SRAM OTP is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_FLASH_OTP 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The NVMEM OTP is set. Cannot continue.");
	}	
}
function JTAGI2CCHECK_CFG_OTP
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The CFG OTP is set. Cannot continue.");
	}	
}
function JTAGI2CCHECK_UFM_OTP
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x02);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The UFM OTP is set. Cannot continue.");
	}	
}
function JTAGI2CCHECK_CFG_UFM_OTP
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x02);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The FLASH OTP is set. Cannot continue.");
	}	
}
function JTAGI2CCHECK_FR_OTP
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (1,"The Feature Row OTP is set. Cannot continue.");
	}	
}
function JTAGI2CCHECK_KEYLOCK 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x20);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;											  				  			  
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;   		
		print (1,"A Password Key is required. Please select a different operation.");
	}		
}
function JTAGI2CFLASH_ERASE {	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x100C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 10;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CFLASH_SVF_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x100C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 5000;  
}
function JTAGI2CUFM_ERASE  {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
	SDR	16	TDI (0x10CB);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY 10;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function JTAGI2CUFM_SVF_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ERASE_UFM(0xCB) instruction;
	SDR	16	TDI (0x10CB);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 5000;   
}
function JTAGI2CFEATURE_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 2000; 
}
function JTAGI2CFEATURE_SVF_ERASE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 2000;   
}
function JTAGI2CFLASH_PROGRAM_STATUS {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
    repeat Temp_Row_Count{
    	TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SDR	16	TDI (0x1070);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data Row = RowCount; 	
    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}
	
		RowCount = RowCount +1;			
	} 	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function JTAGI2CFLASH_SVF_PROGRAM_STATUS {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
    repeat Temp_Row_Count{
    	TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI[RowCount]; 
    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_INCR_NV(0x70) instruction;
    	SDR	16	TDI (0x1070);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	! Shift in Data Row = RowCount; 	
    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		RowCount = RowCount +1;			
	} 	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function JTAGI2CUFM_PROGRAM_STATUS {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CUFMDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR	16	TDI (0x1047);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    repeat Temp_UFM_Count{
	    	TmpJTAGI2CUFMDataArray[1] = EFuseArray_TDI[RowCount]; 
    		TmpJTAGI2CUFMDataArray[1] = $TmpJTAGI2CUFMDataArray[1];
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;			
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
	    	! Shift in Data Row = RowCount; 	
	    	DataByte[1] = TmpJTAGI2CUFMDataArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 64);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 72);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 80);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 88);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 96);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 104);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 112);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 120);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 2 DELAY 1;
			RowCount = RowCount +1;			
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;    	   
	}
}
function JTAGI2CUFM_SVF_PROGRAM_STATUS {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CUFMDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR	16	TDI (0x1047);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    repeat Temp_UFM_Count{
	    	TmpJTAGI2CUFMDataArray[1] = EFuseArray_TDI[RowCount]; 
    		TmpJTAGI2CUFMDataArray[1] = $TmpJTAGI2CUFMDataArray[1];
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;			
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR	16	TDI (0x1070);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
	    	! Shift in Data Row = RowCount; 	
	    	DataByte[1] = TmpJTAGI2CUFMDataArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 64);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 72);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 80);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 88);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 96);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 104);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 112);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CUFMDataArray[1] << 120);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 2 DELAY 1;
			RowCount = RowCount +1;			
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;    			   
	}
}
function JTAGI2CFEATURE_PROGRAM_STATUS
{
	datastream DataByte[1][8];
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	
	
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	JTAGI2CSLAVEADDRREAD[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CSLAVEADDRREAD[1] = $JTAGI2CSLAVEADDRREAD[1];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	
	IF (ArchArray_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1002);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = FeatureBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureBitsArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;	
		
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
		SDR	16	TDI (0x10FB);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		! Shift in Slave Address + RD;
		SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRREAD[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = FeatureBitsArray[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (FeatureBitsArray[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
					
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	    FeatureArray[1] = ArchArray_TDI[1] << 16;
	    
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CSLAVEADDRWRITE[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
		SDR	16	TDI (0x10E4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    DataByte[1] = FeatureArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST	IDLE TCK 2 DELAY 1;
		DataByte[1] = (FeatureArray[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
	    ! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR	16	TDI (0x10E7);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_READ[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = FeatureArray[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (FeatureArray[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (FeatureArray[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
	    DataByte[1] = (FeatureArray[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (FeatureArray[1] << 32);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (FeatureArray[1] << 40);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);				
		DataByte[1] = (FeatureArray[1] << 48);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (FeatureArray[1] << 56);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;															
	}
}
function JTAGI2CPROGRAM_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
	}
}
function JTAGI2CFLASH_PROGRAM_DONE_BIT {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x31);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (1,"Failed to program DONE bit. Cannot continue.");	
	}									
}
function JTAGI2CPROGRAM_SECURITY {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
	SDR	16	TDI (0x10CE);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;	
}
function JTAGI2CUFM_SECURITY {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_PROGRAM_SECPLUS(0xCF) instruction;
    SDR	16	TDI (0x10CF);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;	
}
function JTAGI2CREFRESH {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;	
}
function JTAGI2CFLASH_VERIFY {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	TRY 1 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR	16	TDI (0x1046);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;													
		repeat Temp_Row_Count{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR	16	TDI (0x1073);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x10FC);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x10FF);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI[RowCount];
			TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
			! Shift out Data Row = RowCount; 	
	    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;		
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;			
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CUFM_VERIFY {
	datastream DataByte[1][8];
	datastream TmpJTAGI2CUFMVerifyDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR	16	TDI (0x1047);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
	    	repeat Temp_UFM_Count{
	    		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
	    		! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FC);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FF);
				RUN_TEST IDLE TCK 1000 ;				
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;		
				TmpJTAGI2CUFMVerifyDataArray[1] = EFuseArray_TDI[RowCount];
				TmpJTAGI2CUFMVerifyDataArray[1] = $TmpJTAGI2CUFMVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CUFMVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			
				RowCount = RowCount +1;			
			}
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;					
			print (1, "Failed in Function UFM_VERIFY /see log file for more details/ ");
		}
	}
					
}
function JTAGI2CFEATURE_VERIFY_STATUS
{
	datastream DataByte[1][8];
	datastream FeatureArray[1][64];
	datastream FeatureBitsArray[1][16];
	TRY 1 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		RUN_TEST IDLE TCK 1000 ; 
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ; 
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);								
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				  				  			  
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1,"The FEATURE ROW is protected. Cannot verify. Please select a different operation.");
	}
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1{			
			FeatureBitsArray[1] = ArchArray_TDI[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ; 
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);				    	  
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
			SDR	16	TDI (0x10FB);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
		    ! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ; 
			DataByte[1] = FeatureBitsArray[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureBitsArray[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0x0F);							
		    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 	    				
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 	
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ; 
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ; 
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	
			print (1,"The FEATURE Row setting does not match the setting in the Device. Please program the FEATURE Row first.");			
		}
	    
	}	
}
function JTAGI2CVERIFY_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 									
	}
}
function JTAGI2CVERIFY_DONE_BIT {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ; 
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x0F)
					MASK (0x31);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);								
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;   	      	
}
function JTAGI2C_SAVE_STATUS	{
	datastream DataByte[1][8];
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS[1] = ((SavedSTATUS[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function JTAGI2CSAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CFLASH_SAVE_ARRAY {
	datastream DataByte[1][8];
	datastream SavedFuseMap[Temp_Row_Count][128];
	int32	RowCount = 1;
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWP;													
	repeat Temp_Row_Count{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10FC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10FF);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;			
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function JTAGI2CUFM_SAVE_ARRAY {
	datastream UFMSavedFuseMap[Temp_UFM_Count][128];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	SDR	16	TDI (0x1047);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	repeat Temp_UFM_Count{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10FC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x10FF);
		RUN_TEST IDLE TCK 1000 ;				
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;		
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		UFMSavedFuseMap[RowCount] = ((UFMSavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	
		RowCount = RowCount +1;			
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI, UFMSavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CFEATURE_SAVE_ARRAY
{
	datastream SaveFeatureArray[1][64];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][80];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;		
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureArray[1] = ((SaveFeatureArray[1]) @ (DataByte[1])) << 8;																						
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 

	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				    	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR	16	TDI (0x10FB);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
    ! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SaveFeatureBitsArray[1] = ((SaveFeatureBitsArray[1]) @ (DataByte[1])) << 8;			
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SaveFeatureBitsArray[1] = ((SaveFeatureBitsArray[1]) @ (DataByte[1])) << 8;										
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	FeatureSavedFuseMap[1] = (SaveFeatureBitsArray[1] @ SaveFeatureArray[1]); 
	// Write To file 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureSavedFuseMap);
	fclose 	NewFile;
}
function I2CASC_INIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
} 
function I2CASC_SVF_INIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
} 
function I2CASCREAD_ID	{
	datastream	IDArray[1][8];
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	8	TDI (0x40);
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR	8	TDI  (0x00)
			TDO  (IDArray[1]);
	I2C_STOP;
	IDArray[1] = $IDArray[1];
	IF (IDArray[1] == ASCID)
	{
	}
	ELSEIF (IDArray[1] == 0x8A)
	{
	}
	ELSEIF (IDArray[1] == 0x89)
	{
	}
	ELSE
	{
		print (0,IDArray);
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}
	
}		
function I2CASCREAD_ID_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	8	TDI (0x40);
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x11)
					MASK (0x00);
	I2C_STOP;
}
function I2CASCSAVE_ID	{
	datastream SavedID[1][8];
	file	NewFile = "FILE_SAVE"; 
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	8	TDI (0x40);
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR	8	TDI  (0x00)
			TDO  (SavedID[1]);
	I2C_STOP;	
	SavedID[1] = $SavedID[1];		
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function I2CASCSAVE_ID_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDID(0x02) instruction;
	SDR	8	TDI (0x40);
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	I2C_STOP;	
}	
function I2CASC_ENABLE	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_ENPROG(0x04) instruction;
	SDR	8	TDI (0x20); 
	! Shift in PROG MODE KEY;
	SDR	16	TDI (0xA7BC); 
	I2C_STOP;
	RUN_TEST DELAY 1;
} 
function I2CASC_ENABLE_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_ENPROG(0x04) instruction;
	SDR	8	TDI (0x20); 
	! Shift in PROG MODE KEY;
	SDR	16	TDI (0xA7BC); 
	I2C_STOP;
	RUN_TEST DELAY 1;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	SDR_VERIFY 16  TDI(0x0000)
				  TDO(0x0008)
				  MASK(0x0009);
	I2C_STOP;		
} 
function I2CASC_ERASE_I2CSA	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;		
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_ERASEI2CSA(0x11) instruction;
	SDR	8	TDI (0x88); 
	I2C_STOP;
	RUN_TEST	DELAY 100;	
}
function I2CASC_ERASE_I2CSA_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEDADDRWRITE[1][8];
	datastream JTAGI2CSLAVEDADDRREAD[1][8];
	
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;	
	JTAGI2CSLAVEDADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEDADDRREAD[1] = (DEFAULT_ADDR_READ) ;	
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_ERASEI2CSA(0x11) instruction;
	SDR	8	TDI (0x88); 
	I2C_STOP;
	RUN_TEST	DELAY 100;	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEDADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEDADDRREAD[1]);
	SDR_VERIFY 16 TDI(0x0000)
				 TDO(0x0000)
				 MASK(0x0085);
	I2C_STOP;		
}
function I2CASC_PROGRAM_I2CSA	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CSLAVE_NADDR_WRITE[1][8];
	datastream JTAGI2CSLAVE_NADDR_READ[1][8];
	
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRREAD[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] & 0x0F);
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] | (JTAGI2CN_WRITE[1] << 1));
	JTAGI2CSLAVE_NADDR_READ[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] | 0x01);

	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_WRITEI2CSA(0x12) instruction;
	SDR	8	TDI (0x48); 
	SDR	8	TDI (JTAGI2CN_WRITE[1]); 
	I2C_STOP;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_PROGI2CSA(0x14) instruction;
	SDR	8	TDI (0x28); 
	I2C_STOP;
	RUN_TEST DELAY 10;				
}
function I2CASC_PROGRAM_I2CSA_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream JTAGI2CNWRITE[1][8];
	datastream JTAGI2CSLAVENADDRWRITE[1][8];
	datastream JTAGI2CSLAVENADDRREAD[1][8];
	
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRREAD[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	JTAGI2CSLAVENADDRWRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	JTAGI2CSLAVENADDRWRITE[1] = (JTAGI2CSLAVENADDRWRITE[1] & 0x0F);
	JTAGI2CSLAVENADDRWRITE[1] = (JTAGI2CSLAVENADDRWRITE[1] | (JTAGI2CNWRITE[1] << 1));
	JTAGI2CSLAVENADDRREAD[1] = (JTAGI2CSLAVENADDRWRITE[1] | 0x01);

	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_WRITEI2CSA(0x12) instruction;
	SDR	8	TDI (0x48); 
	SDR	8	TDI (JTAGI2CNWRITE[1]); 
	I2C_STOP;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_PROGI2CSA(0x14) instruction;
	SDR	8	TDI (0x28); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVENADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVENADDRREAD[1]);
	SDR_VERIFY 16 TDI(0x0000)
				 TDO(0x0004)
				 MASK(0x0004);
	I2C_STOP;
}
function I2CASC_ERASE_BECFG
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	! Erase ASC;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_BECFG(0x21) instruction;
	SDR	8	TDI (0x84); 
	I2C_STOP;
	RUN_TEST DELAY PWE;
}
function I2CASC_ERASE_BECFG_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	! Erase ASC;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_BECFG(0x21) instruction;
	SDR	8	TDI (0x84);
	I2C_STOP;   
	RUN_TEST	DELAY PWE;
}
function I2CASCCHECK_STATUS {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	TRY 1{
		SDR_VERIFY 16 TDI(0x0000)
					 TDO(0x0000)
					 MASK(0x0081);
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	8	TDI (0xA0); 
		I2C_STOP;
		RUN_TEST DELAY 10;
		print (1,"CRC Error. Cannot continue.");
	}
	I2C_STOP;	
}

function I2CASCCHECK_STATUS_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY 16 TDI(0x0000)
				 TDO(0x0000)
				 MASK(0x0081);
	I2C_STOP;		
}
function I2CASC_PROGRAM_STATUS	
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream TmpASCProgramDataArray[1][64];
	datastream TmpASCProgramDataArray2[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	
	CFGArray_TDI.row = 1;
	I2C_Address_CFG.row = 1;
	repeat 14 {
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		TmpASCProgramDataArray[1] = CFGArray_TDI[RowCount];
		TmpASCProgramDataArray[1] = $TmpASCProgramDataArray[1]; 
		DataByte[1] = TmpASCProgramDataArray[1];
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 8);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 16);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 24);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 32);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 40);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 48);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 56);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		
		! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	8	TDI (0x44); 
		SDR	64	TDI (TmpASCProgramDataArray2[1]); 
		I2C_STOP;
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	8	TDI (0x24); 
		! Shift in Row Address;
		SDR	8	TDI ( I2C_Address_CFG[RowAddr]); 
		I2C_STOP;
		RUN_TEST DELAY 100;
		RowAddr = RowAddr + 1;
		RowCount = RowCount +1;	
	}	
}		
function I2CASC_PROGRAM_STATUS_SVF	
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream TmpASCProgramDataArray[1][64];
	datastream TmpASCProgramDataArray2[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	
	CFGArray_TDI.row = 1;
	I2C_Address_CFG.row = 1;
	repeat 14 {
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		TmpASCProgramDataArray[1] = CFGArray_TDI[RowCount]; 
		TmpASCProgramDataArray[1] = $TmpASCProgramDataArray[1];
		DataByte[1] = TmpASCProgramDataArray[1];
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 8);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 16);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 24);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 32);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 40);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 48);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCProgramDataArray[1] << 56);
		DataByte[1] = $DataByte[1];
		TmpASCProgramDataArray2[1] = (TmpASCProgramDataArray2[1] @ DataByte[1]) << 8;
    	! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	8	TDI (0x44); 
		SDR	64	TDI (TmpASCProgramDataArray2[1]); 
		I2C_STOP;
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	8	TDI (0x24); 
		! Shift in Row Address;
		SDR	8	TDI ( I2C_Address_CFG[RowAddr]); 
		I2C_STOP;
		RUN_TEST DELAY 100;
		RowAddr = RowAddr + 1;
		RowCount = RowCount +1;	
	}			
}																																				
function I2CASC_VERIFY	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream TmpASCVerifyDataArray[1][64];
	datastream TmpASCVerifyDataArray2[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	CFGArray_TDI.row = 1;
	I2C_Address_CFG.row = 1;
	TRY 1 {			
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	8	TDI (0xA4); 
		! Shift in Row Address;
		SDR	8	TDI (I2C_Address_CFG[RowAddr]); 
		I2C_RESTART;
		! Shift in Slave Address + RD;
		SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
		repeat 14 {
			TmpASCVerifyDataArray[1] = CFGArray_TDI[RowCount];
			TmpASCVerifyDataArray[1] = $TmpASCVerifyDataArray[1]; 
			DataByte[1] = TmpASCVerifyDataArray[1];
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 8);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 16);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 24);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 32);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 40);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 48);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			DataByte[1] = (TmpASCVerifyDataArray[1] << 56);
			DataByte[1] = $DataByte[1];
			TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
			! Shift out Data Row = RowCount; 	
	    	SDR_VERIFY	64	TDI  (#1^64)
							TDO  (TmpASCVerifyDataArray2[1])
							MASK(#1^64);				
			RowCount = RowCount +1;								
		}
		I2C_STOP;				
	}
	ELSE
	{
		I2C_STOP;	
		I2C_START;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
		SDR	8	TDI (0xA0); 
		I2C_STOP;
		RUN_TEST DELAY 10;			
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}		
}	
function I2CASC_VERIFY_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream TmpASCVerifyDataArray[1][64];
	datastream TmpASCVerifyDataArray2[1][64];
	datastream DataByte[1][8];
	int32	RowCount = 1;
	int32	RowAddr = 1;
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	CFGArray_TDI.row = 1;
	I2C_Address_CFG.row = 1;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
	SDR	8	TDI (0xA4); 
	! Shift in Row Address;
	SDR	8	TDI (I2C_Address_CFG[RowAddr]); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);	
	repeat 14 {
		TmpASCVerifyDataArray[1] = CFGArray_TDI[RowCount];
		TmpASCVerifyDataArray[1] = $TmpASCVerifyDataArray[1]; 
		DataByte[1] = TmpASCVerifyDataArray[1];
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 8);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 16);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 24);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 32);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 40);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 48);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		DataByte[1] = (TmpASCVerifyDataArray[1] << 56);
		DataByte[1] = $DataByte[1];
		TmpASCVerifyDataArray2[1] = (TmpASCVerifyDataArray2[1] @ DataByte[1]) << 8;
		! Shift out Data Row = RowCount; 	
    	SDR_VERIFY	64	TDI  (0x0000000000000000)
						TDO  (TmpASCVerifyDataArray2[1])
						MASK (#1^64);
		RowCount = RowCount +1;	
	}
	I2C_STOP;	
}	
function I2CASC_PROGRAM_DONE_BIT {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_PROGDONE(0x27) instruction;
	SDR	8	TDI (0xE4); 
	I2C_STOP;
	RUN_TEST DELAY 100;
}	
function I2CASC_PROGRAM_DONE_BIT_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_PROGDONE(0x27) instruction;
	SDR	8	TDI (0xE4); 
	I2C_STOP;
	RUN_TEST DELAY 100;
	I2C_START;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY 16 TDI(0x0000)
				 TDO(0x0002)
				 MASK(0x0003);
	I2C_STOP;	
}	
function I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CSLAVE_NADDR_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] & 0x0F);
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] | (JTAGI2CN_WRITE[1] << 1));
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVE_NADDR_WRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVE_NADDR_WRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,JTAGI2CSLAVE_NADDR_WRITE);	
}
function I2CASC_DIRECT_DISABLE_WITH_NEW_ADDR_SVF {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CSLAVE_NADDR_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] & 0x0F);
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] | (JTAGI2CN_WRITE[1] << 1));
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVE_NADDR_WRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVE_NADDR_WRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;					
}
function I2CASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;

	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
	JTAGI2CSLAVEADDRWRITE[1] = (JTAGI2CSLAVEADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,JTAGI2CSLAVEADDRWRITE);
}
function I2CASC_DIRECT_DISABLE_WITH_DEFAULT_ADDR_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
}
function I2CASC_DIRECT_DISABLE {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
}
function I2CASC_DIRECT_DISABLE_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
}
function I2CASC_EXIT_USERMODE {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
}
function I2CASC_EXIT_USERMODE_WITH_NEW_ADDR {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CSLAVE_NADDR_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (SLAVE_ADDRESS_WRITE) ;
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] & 0x0F);
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] | (JTAGI2CN_WRITE[1] << 1));
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVE_NADDR_WRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;	
	JTAGI2CSLAVE_NADDR_WRITE[1] = (JTAGI2CSLAVE_NADDR_WRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,JTAGI2CSLAVE_NADDR_WRITE);	
}
function I2CASC_EXIT_USERMODE_WITH_DEFAULT_ADDR {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;

	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_USERMODE(0x05) instruction;
	SDR	8	TDI (0xA0); 
	I2C_STOP;
	RUN_TEST DELAY 10;
	
	JTAGI2CSLAVEADDRWRITE[1] = (JTAGI2CSLAVEADDRWRITE[1] >> 1);
	print (0,"Current I2C Slave Address: ");
	print (0,JTAGI2CSLAVEADDRWRITE);
}
function I2CASC_REFRESH {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_LDSHDW(0x28) instruction;
	SDR	8	TDI (0x14); 	
	I2C_STOP;
	RUN_TEST DELAY 10;
}
function I2CASCPROGRAM_USERCODE	
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream UserCode[1][64];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	IF (Usercode_TDO.row = 1)
	{
		UserCode[1] = Usercode_TDO[1];
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	8	TDI (0x44);
		SDR	64	TDI (UserCode[1]); 
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	8	TDI (0x24); 
		! Shift in Row Address;
		SDR	8	TDI (0x0E); 
		I2C_STOP;
		RUN_TEST DELAY 100;		
	}	
}
function I2CASCPROGRAM_USERCODE_SVF	{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream UserCode[1][64];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	IF (Usercode_TDO.row = 1)
	{
		UserCode[1] = Usercode_TDO[1];
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_WRITECFG(0x22) instruction;
		SDR	8	TDI (0x44);
		SDR	64	TDI (UserCode[1]); 
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_PROGCFG(0x24) instruction;
		SDR	8	TDI (0x24); 
		! Shift in Row Address;
		SDR	8	TDI (0x0E); 
		I2C_STOP;
		RUN_TEST DELAY 100;		
	}
}
function I2CASCVERIFY_USERCODE {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	IF (Usercode_TDO.row = 1)
	{
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	8	TDI (0xA4); 
		! Shift in Row Address;
		SDR	8	TDI (0x0E); 
		I2C_RESTART;
		! Shift in Slave Address + RD;
		SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
		SDR_VERIFY 32 TDI(0x00000000)
					  TDO(Usercode_TDO[1]);
		I2C_STOP;		 
	}
}
function I2CASCVERIFY_USERCODE_SVF {
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	IF (Usercode_TDO.row = 1)
	{
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
		SDR	8	TDI (0xA4); 
		! Shift in Row Address;
		SDR	8	TDI (0x0E); 
		I2C_RESTART;
		! Shift in Slave Address + RD;
		SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
		SDR_VERIFY 32 TDI(0x00000000)
					  TDO(Usercode_TDO[1]);
		I2C_STOP; 
	}
}
function I2CASCSAVE_USERCODE {
	datastream SavedUsercode[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
	SDR	8	TDI (0xA4); 
	! Shift in Row Address;
	SDR	8	TDI (0x0E); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR 32 TDI(0x00000000)
		   TDO(SavedUsercode[1]);				
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDO, SavedUsercode);
	fclose 	NewFile;
}
function I2CASC_SAVE	
{
	datastream SavedArray[1][896];
	datastream DataByte[1][8];
	int32	RowAddr = 1;
	file NewFile = "FILE_SAVE";
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_Address_CFG.row = 1;
	I2C_START;
    ! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_VERCFG(0x25) instruction;
	SDR	8	TDI (0xA4); 
	! Shift in Row Address;
	SDR	8	TDI (I2C_Address_CFG[RowAddr]); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	repeat 14 {
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;
		SDR 8 TDI(0x00)
			  TDO(DataByte[1]);
		DataByte[1] = $DataByte[1];
		SavedArray[1] = ((SavedArray[1]) @ (DataByte[1])) << 8;				
	}
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
	SavedArray[1] = $SavedArray[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (SysIOArray_TDI, SavedArray);
	fclose 	NewFile;
}
function I2CASC_SAVE_FAULTLOG_REGISTERS
{
	datastream SavedFaultLogArray[1][56];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSOFTFAULT(0x73) instruction;
	SDR	8	TDI (0xCE); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDVERFAULT(0x75) instruction;
	SDR	8	TDI (0xAE); 
	SDR	8	TDI (0x00); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR 56 TDI(0x00000000000000)
		   TDO(SavedFaultLogArray[1]);
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
	//print (0,SavedFaultLogArray);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedFaultLogArray);
	fclose 	NewFile;
}
function I2CASC_SAVE_FAULTLOG_REGISTERS_SVF
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSOFTFAULT(0x73) instruction;
	SDR	8	TDI (0xCE); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDVERFAULT(0x75) instruction;
	SDR	8	TDI (0xAE); 
	SDR	8	TDI (0x00);
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY 56 TDI(0x00000000000000)
		  		  TDO(0x00000000000000)
		          MASK(0x00000000000000);
	I2C_STOP;
}
function I2CASC_ERASE_FAULTLOG_MEMORY
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_ERASEFAULT(0x71) instruction;
	SDR	8	TDI (0x8E); 
	RUN_TEST DELAY 10;
	I2C_STOP; 
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	SDR	8	TDI (0xFF); 
	I2C_STOP;
}
function I2CASC_ERASE_FAULTLOG_FULL_MEMORY
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	8	TDI (0x6E); 
	I2C_STOP;
	
	TRY 1 {
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);	
		! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
		SDR	8	TDI (0xC0); 
		I2C_RESTART;
		! Shift in Slave Address + RD;
		SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
		SDR_TRY_VERIFY 16 TDI(0x0000)
			          TDO(0x0800)
			          MASK(0x0801);
		I2C_STOP;		
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_ERASEFAULT(0x71) instruction;
		SDR	8	TDI (0x8E); 
		RUN_TEST DELAY 10;
		I2C_STOP; 
	}
	ELSE
	{
		I2C_STOP;
	}
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	SDR	8	TDI (0xFF); 
	I2C_STOP;
}
function I2CASC_SAVE_FAULTLOG_MEMORY
{
	datastream SavedFaultLogRow[1][56];
	datastream DataByte[1][8];
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	8	TDI (0x6E); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	8	TDI (0x6E); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	repeat 16 {
		SDR 56 TDI(0x00000000000000)
		  	   TDO(SavedFaultLogRow[1]);
		print (0,SavedFaultLogRow);
	}
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
}
function I2CASC_SAVE_FAULTLOG_MEMORY_SVF
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDFAULTEN(0x74) instruction;
	SDR	8	TDI (0x2E); 
	! Shift in Read Fault keycode (0xAC);
	SDR	8	TDI (0x35); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	8	TDI (0x6E); 
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDALLFAULT(0x76) instruction;
	SDR	8	TDI (0x6E); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	repeat 16 {
		SDR_VERIFY 56 TDI(0x00000000000000)
		  	  		 TDO(0x00000000000000)
		  	  		 MASK(0x00000000000000);		
	}
	I2C_STOP;
}
function I2CASC_READ_SHADOW_REGISTERS
{
	datastream SavedRowArray[1][64];
	datastream SavedArray[1][896];
	int32	RowAddr = 1;
	file NewFile = "FILE_SAVE";
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_Address_CFG.row = 1;
	repeat 14 {
		I2C_START;
		! Shift in Slave Address + WR;
		SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
		! Shift in ASC_I2C_INSTR_RDSHDW(0x33) instruction;
		SDR	8	TDI (0xCC); 
		SDR	8	TDI (I2C_Address_CFG[RowAddr]); 
		I2C_RESTART;
		! Shift in Slave Address + RD;
		SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
		! Shift out first byte of data;
		SDR 64 TDI(0x0000000000000000)
			   TDO(SavedRowArray[1]);
		SavedArray[1] = ((SavedArray[1]) @ (SavedRowArray[1])) << 64;
		I2C_STOP;
		RowAddr = RowAddr + 1;	
		print (0,SavedRowArray);	
	}
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
	//SavedArray[1] = $SavedArray[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (SysIOArray_TDI, SavedArray);
	fclose 	NewFile;
}
function I2CASC_SAVE_STATUS
{
	datastream SavedSTATUS[1][16];
	file NewFile = "FILE_SAVE";
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);	
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR 16 TDI(0x0000)
		  TDO(SavedSTATUS[1]);
	I2C_STOP;
	I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
    I2C_START;
    I2C_STOP;
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;	
}
function I2CASC_SAVE_STATUS_SVF
{
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	JTAGI2CSLAVEADDRWRITE[1] = SLAVE_ADDRESS_WRITE;
	JTAGI2CSLAVEADDRREAD[1] = SLAVE_ADDRESS_READ;
	I2C_START;
	! Shift in Slave Address + WR;
	SDR	8	TDI (JTAGI2CSLAVEADDRWRITE[1]);
	! Shift in ASC_I2C_INSTR_RDSTATUS(0x03) instruction;
	SDR	8	TDI (0xC0); 
	I2C_RESTART;
	! Shift in Slave Address + RD;
	SDR	8	TDI  (JTAGI2CSLAVEADDRREAD[1]);
	SDR_VERIFY 16 TDI(0x0000)
		  		 TDO(0x0000)
		  		 MASK(0x0000);
	I2C_STOP;			
}
]]>
</Script>
</SVF_Plus>
