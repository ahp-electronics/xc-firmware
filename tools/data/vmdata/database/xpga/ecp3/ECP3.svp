<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		SVF_Plus	SYSTEM	"SVF_Plus.dtd" >
<!--    12/18/07 Nguyen Created from a copy of ECP2.svp
		02/11/08 Spinti: Added Refresh Erase Only operation.
		02/12/08 Spinti: Removed Program and Verify usercode from function ERASE and REFRESH_ERASE.
		02/14/08 Spinti: Changed the Fast Program operation to call ENABLE instead of REFRESH_ENABLE.
		                 Added Refresh, Fast Program operation.
		                 Cleaned up REFRESH_ERASE calls to REFRESH_ENABLE.
		                 Corrected the program usercode to all 1's before erase in function erase.
		02/20/08 Spinti: Changed Key fuse name to KEY_1.
		                 Changed Test fuse name to KEY_2.
		                 Changed Redundant fuse name to KEY_3.
		03/05/08 Nguyen: added blank check operation
		03/12/08 Nguyen modified the security flow
		03/17/08 Nguyen Added the Slave SPI flow
		03/17/08 Spinti: Commented out the LSCC READ STATUS(0x53) instruction from function REFRESH_FUNCTION
						 since it stops the MCLK in first silicon. 
		03/18/08 Spinti: Updated function REFRESH_FUNCTION for ECP3-95 first silicon.
		03/17/08 Nguyen Added the WriteManufacturing flag to determine if it need to write the manufacturing register
		03/17/08 Nguyen Added the "Enable_PROGRAM_SPI0" and "Enable_PROGRAM_SPI1" operations
	    04/29/08 Spinti: Added Program Only operation.
	    05/23/08 Spinti: Removed the ENABLE before reading the Status Register.
	    06/04/08 Nguyen: Updated "FLASH TransFR" operation
	    12/10/08 Nguyen: Changed the Fast Program operation to call REFRESH_ENABLE instead of ENABLE
	    		 to clear device state before enabling device and the JTAG burst per San-Ta requested.
	    		 In function REFRESH_ENABLE after issue the Refresh instruction, this device required
	    		 minimum 2 TCK and the delay of 1ms in order to work.
	    
		09/01/09 Nguyen modified the encryption programming flow to solve the bit 129 and 130 problem
		09/24/09 Nguyen replaced the ENABLE with the REFRESH_ENABLE for all encryption operations
		03/06/12 Nguyen updated the "Security Fast Program with Encryption Option" flow.
		
		
-->
<SVF_Plus version="1.0">
<Header>
	<Device name="DEVICE_NAME"/>
</Header>
<Setup> <!-- use default Header, Trailer and Frequency value -->
	<Interface protocol="JTAG_1149.1"/>
</Setup>
<Parameter>
	<!-- Length fields are in number if bits -->
	<Instruction_Length value="INSTRUCTION_REGISTER_LENGTH"/> 
	<Row_Width			value="DEVICE_ROW_WIDTH"/> 
	<Address_Length		value="ADDRESS_REGISTER_LENGTH"/> 
	<Address length="ADDRESS_LENGTH">
		INI_ADDRESS			
	</Address>
	<ID_Length 			value="DEVICE_ID_LENGTH"/>
	<Usercode_Length 	value="DEVICE_USERCODE_LENGTH"/>
	<BSCAN_Length value="BSCAN_REGISTER_LENGTH"/> 
	<Bscan length="BSCAN_LENGTH">
		BSCAN_DATA
	</Bscan>
	<BscanMask length="BSCAN_LENGTH">
		BSCAN_MASK
	</BscanMask>
	<TotalFuse value="TOTAL_FUSE_MAP"/>
	<PWP	value="PROGRAMING_PULSE_WIDTH"/>
	<PWV	value="VERIFY_PULSE_WIDTH"/>
	<PWE	value="ERASE_PULSE_WIDTH"/>
	<SkipRow value="1"/>
	<KeyLock value="SECURITY_KEYLOCK"/>
	<MDRDelay value="MDR_DELAY"/>
	<Instruction>
		EXTEST	 			= 0xD5;
		INTEST	 			= 0x2C;
		CLAMP	 			= 0x20;
		HIGH_Z	 			= 0x18;
		BPRELOAD 			= 0x1C;
		ISC_ENABLE 			= 0x15;
		ISC_DISABLE			= 0x1E;
		ISC_ADDRESS_SHIFT 	= 0x01;
		ISC_ERASE 			= 0x03;
		ISC_PROGRAM			= 0x07;
		ISC_READ			= 0x0A;
		ISC_PROGRAM_ASIC	= 0xA6;
		ISC_READ_ASIC		= 0xAB;
		ISC_PROGRAM_USERCODE		= 0x1A;
		USERCODE 			= 0x17;
		ISC_PROGRAM_SECURITY	= 0x09;
		ISC_PROGRAM_DONE 		= 0x2F;
		ISC_ERASE_DONE			= 0x24;
		IDCODE 				= 0x16;
		BYPASS				= 0xFF;
		ISC_NOOP			= 0x30;
		<!-- Alternate Instructions -->
		LSCC_PROGRAM_INCR_RTI	= 0x67;
		LSCC_READ_INCR_RTI 		= 0x6A;
		<!-- Proprietary Mode Instructions -->
      	LSCC_TRANSPARENT_ENABLE	= 0x75;
		LSCC_BITSTREAM_BURST	= 0x02;
		LSCC_RESET_ADDRESS		= 0x21;
		LSCC_REFRESH			= 0x23;
		LSCC_ERASE_ROW			= 0x05;
		LSCC_PROGRAM_CTRL0		= 0x47;
		LSCC_READ_CTRL0			= 0x4A;
		LSCC_PROGRAM_ERR_MASK	= 0x68;
		LSCC_READ_ERR_MASK		= 0x6B;
		LSCC_RESET_CRC			= 0x12;
		LSCC_READ_CRC			= 0x73;
		LSCC_READ_STATUS		= 0x53;
		<!-- IP instructions -->
		LSCC_IPA			= 0x32;
		LSCC_IPTESTA		= 0x33;
		LSCC_IPB			= 0x38;
		LSCC_IPTESTB		= 0x39;	
		<!-- Manufacturing instructions -->
		LSCC_MANUFACTURING_SHIFT = 0x80;
		LSCC_ERASE_ALL			 = 0x10;
		LSCC_PROGRAM_PES		 = 0x0F;
		LSCC_USER_LOGIC_RESET	 = 0x22;
		<!-- Security instruction -->
		KEY_1_PROGRAM			= 0xC0;
		LOCK_PROGRAM			= 0xC1;
		KEY_2_PROGRAM			= 0xC2;
		KEY_3_PROGRAM			= 0xC3;
		KEY_1_READ				= 0xC4;
		LOCK_READ				= 0xC5;
		KEY_2_READ				= 0xC6;
		KEY_3_READ			= 0xC7;
		X_PROGRAM_ENABLE		= 0x35;
		EBR_READ				= 0x04;
		
	</Instruction>
</Parameter>
<Data>
	<DataField	name="IDTDI">
		<FieldBlock	row_width="DEVICE_ID_LENGTH">
			ID_DATA
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANTDO">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			0x00000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000002880000000000000000000000000000
		000000
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANMASK">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			0x00000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000000000000000000000000000000000000
		000000000000000000000000000002880000000000000000000000000000
		000000
		</FieldBlock>
	</DataField>
</Data>
<Operation_List>
	"Security Read Encryption Key" = "INIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   ENABLE	! Enable the programming mode,
						   DISABLE_HASHING,							  						   						   
						   CHECK_KEYLOCK ! Check the Key Lock,
						   READ_SECURITY_KEY ! Check the Security Key,
						   DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key" = "INIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  							  
							  PROGRAM_SECURITY_KEY !Program the Security Key,
							  DISABLE ! Exit the programming mode" ;
							  
	"Security Verify Encryption Key" = "INIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  						   
						   	  VERIFY_SECURITY_KEY_FUSES ! Check the Security Key,
							  DISABLE ! Exit the programming mode" ;
							  
	
	"Security Program Key Lock" = "INIT 	! Initialize, 
						  READ_ID	! Check the IDCODE,
						  REFRESH_ENABLE	! Enable the programming mode,
						  CHECK_KEYLOCK ! Check the Key Lock,
						  DISABLE_HASHING,						  						  
						  PROGRAM_LOCK_FUSES ! Program the Lock Fuses,
						  DISABLE ! Exit the programming mode" ;
						  
	"Security Fast Program with Encryption Option" = "INIT 	! Initialize, 
													  READ_ID	! Check the IDCODE,
													  IO_STATE ! Program Bscan register,
													  REFRESH_ENABLE	! Enable the programming mode,
													  ERASE	! Erase the device, 
													  CHECK_KEYLOCK ! Check the Key Lock,
													  DISABLE_HASHING,						  						  													  
													  PROGRAM_SECURITY_KEY_ONLY !Program the Security Key,
													  PROGRAM_LOCK_FUSES_ONLY ! Program the Lock Fuses,													  
													  BURST_PROGRAM	! Program Fuse Map,
													  VERIFY_USERCODE		! Verify USERCODE,
													  DISABLE ! Exit the programming mode,
					 								  VERIFY_STATUS ! Verify Status Register,
													  DISABLE ! Exit the programming mode" ;
													  
	"Security Verify with Encryption Option" = "INIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  IO_STATE ! Program Bscan register,
												  REFRESH_ENABLE	! Enable the programming mode,
												  CHECK_ENCRYPTION_KEY ! Check the Encryption Key,
												  ERASE	! Erase the device, 
												  BURST_PROGRAM	! Program Fuse Map,
												  VERIFY_USERCODE		! Verify USERCODE,
												  DISABLE ! Exit the programming mode,
				 								  VERIFY_STATUS ! Verify Status Register,
												  DISABLE ! Exit the programming mode" ;													  
							  						  						  							  
	"Bypass"	=	"	INIT 	! Initialize"	;
	"Verify ID" = 	"	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE"	; 
	"Display ID" = 	"	INIT, READ_ID, SAVE_ID";
	
	"Verify USERCODE"	=	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								VERIFY_USERCODE		! Verify USERCODE"	; 
	"Program USERCODE"	=	"	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_USERCODE	! Program USERCODE,
						DISABLE ! Exit the programming mode"	; 
	"Secure Device" = "	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_SECURITY ! Secure device,
						DISABLE ! Exit the programming mode"	; 
	"Display USERCODE"	=	"	INIT, READ_ID, SAVE_USERCODE";
	
	"Disable Only" = "	INIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	 			 		
	"Enable Only" = "	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						IO_STATE ! Program Bscan register,
						ENABLE	! Enable the programming mode"	;
						
	"Program,Verify" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							IO_STATE ! Program Bscan register,
							ENABLE	! Enable the programming mode, 
							ERASE	! Erase the device, 
							PROGRAM_CONTROL	! Program Control Register,
							PROGRAM	! Program Fuse Map,
							VERIFY	! Verify Fuse Map,
							PROGRAM_USERCODE	! Program USERCODE,
							VERIFY_USERCODE		! Verify USERCODE, 
							PROGRAM_DONE_BIT	! Program DONE bit,
				 			DISABLE ! Exit the programming mode,
				 			VERIFY_STATUS ! Verify Status Register"	;
	"Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;		
	"Refresh,Erase,Program,Verify" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								REFRESH_ENABLE	! Refresh and Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;	
	"Erase,Program,Read and Save" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY_STATUS ! Verify Status Register,
								SAVE_ID, 
								SAVE_CONTROL0,
						 		SAVE_ARRAY, 
						 		SAVE_USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode"	;					
	"Erase,Program,Verify,Secure"	=	"	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									ENABLE	! Enable the programming mode, 
									ERASE	! Erase the device, 
									PROGRAM_CONTROL	! Program Control Register, 
									PROGRAM	! Program Fuse Map, 
									PROGRAM_USERCODE	! Program USERCODE,
									VERIFY	! Verify Fuse Map, 
				 			 		VERIFY_USERCODE		! Verify USERCODE, 
				 			 		PROGRAM_SECURITY ! Secure device,
				 			 		PROGRAM_DONE_BIT	! Program DONE bit, 
				 			 		DISABLE ! Exit the programming mode,
				 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Program Only" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;		
	"Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							REFRESH_ENABLE	! Refresh and Enable the programming mode, 
							ERASE	! Erase the device, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Refresh Erase Only"	=	"	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							REFRESH_ENABLE	! Enable the programming mode, 
							ERASE	! Erase the device, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Program" = "	INIT 	! Initialize, 
					READ_ID	! Check the IDCODE,  
					IO_STATE ! Program Bscan register,
					ENABLE	! Enable the programming mode, 
					ERASE	! Erase the device, 
					PROGRAM_CONTROL	! Program Control Register,
					PROGRAM	! Program Fuse Map,
					PROGRAM_USERCODE	! Program USERCODE,
					PROGRAM_DONE_BIT	! Program DONE bit,
		 			DISABLE ! Exit the programming mode,
		 			VERIFY_STATUS ! Verify Status Register"	;
	"Verify Only"	=	"	INIT 	! Initialize, 
					READ_ID	! Check the IDCODE,  
					ENABLE	! Enable the programming mode, 
					VERIFY_CONTROL	! Verify Control Register,
					VERIFY	! Verify Fuse Map, 
					VERIFY_USERCODE		! Verify USERCODE, 
		 			DISABLE ! Exit the programming mode,
		 			VERIFY_STATUS ! Verify Status Register"	;
	"Blank Check"	=	"	INIT 	! Initialize, 
					READ_ID	! Check the IDCODE,  
					ENABLE	! Enable the programming mode, 
					VERIFY_BLANK_CONTROL	! Verify Control Register,
					VERIFY_BLANK	! Verify Fuse Map, 
					VERIFY_BLANK_USERCODE		! Verify USERCODE, 
		 			DISABLE ! Exit the programming mode"	;
	"Verify,Refresh" =	"	INIT 	! Initialize, 
					READ_ID	! Check the IDCODE,  
					ENABLE	! Enable the programming mode, 
					VERIFY_CONTROL	! Verify Control Register,
					VERIFY	! Verify Fuse Map, 
					VERIFY_USERCODE		! Verify USERCODE, 
		 			DISABLE ! Exit the programming mode,
		 			VERIFY_STATUS ! Verify Status Register, 
					REFRESH_FUNCTION ! Refresh";
	"Re-Initialize" = " INIT 	! Initialize,
						ENABLE	! Enable the programming mode, 
						ERASE	! Erase the device, 
	 			 		DISABLE ! Exit the programming mode"	;
	
	"Erase DONE bit"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Program DONE bit"	=	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"Read DONE bit"	=	"INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 READ_DONE_BIT	! Read the done bit,
					 DISABLE ! Exit the programming mode"	;
	"Display DONE bit"	=	"INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 READ_DONE_BIT	! Read the done bit,
					 DISABLE ! Exit the programming mode"	;
	"Calculate Data CRC"	=	"INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             SAVE_CONTROL0,
					             SAVE_ARRAY,
					             SAVE_USERCODE,
		 						 DISABLE";
	"Read and Save ISC"	=	"INIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SAVE_CONTROL0,
						 SAVE_ARRAY, 
						 SAVE_USERCODE, 
						 DISABLE";
	"Read and Save"	=	"INIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SAVE_CONTROL0,
						 SAVE_ARRAY, 
						 SAVE_USERCODE, 
						 DISABLE";
	"Read and Save,Refresh"	=	"INIT, 
					 READ_ID, 
					 SAVE_ID, 
					 ENABLE, 
					 SAVE_CONTROL0,
					 SAVE_ARRAY, 
					 SAVE_USERCODE, 
			 		 DISABLE ! Exit the programming mode, 
			 		 VERIFY_STATUS ! Verify Status Register,
					 REFRESH_FUNCTION ! Refresh";
	"Refresh" = " 	INIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					REFRESH_FUNCTION ! Refresh";
	
	"Refresh from FLASH" = " 	INIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					REFRESH_FUNCTION ! Refresh";
					
	"Read Programming Status" = "INIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	"Display Programming Pins Status" = "INIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	
	"Read Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SAVE_STATUS !Read Status Register,
					             DISABLE";
	"Security Read Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SAVE_STATUS !Read Status Register,
					             DISABLE";
	"Display Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"Verify Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 ENABLE,
								 VERIFY_STATUS !verify Status Register,
					             DISABLE";				             
	"Read Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
					 			 ENABLE	! Enable programming mode, 
					             SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"Display Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
					 			 ENABLE	! Enable programming mode, 
					             SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"Program Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
	"Fast Program" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								REFRESH_ENABLE	! Enable the programming mode, 
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;
	"Refresh,Fast Program" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
						 		REFRESH_ENABLE	! Refresh and Enable the programming mode,  
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;					 			
	
	"JTAG Burst Disable Only" = "INIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"JTAG Burst Enable Only" = "INIT 	! Initialize,
								READ_ID	! Check the IDCODE,
					 			ENABLE	! Enable the programming mode"	;
	"JTAG Burst Read DONE bit" = "	INIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;

	"Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
						
	"Serial Program" = "	INIT 	! Initialize,   
							SERIAL_PROGRAM	! Program Fuse Map"	;
	"Serial Disable Only" = "INIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"Serial Enable Only" = "INIT 	! Initialize, 
							ENABLE	! Enable the programming mode"	;
	"Serial Read DONE bit" = "	INIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
													
	"XSRAM Bypass"	=	"	INIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Disable Only" = "	INIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
					!		TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"INIT, 
								 READ_ID, 
								 SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SAVE_CONTROL0,
								 SAVE_ARRAY, 
								 SAVE_USERCODE, 
								 DISABLE";
	"XSRAM Read and Save ISC"	=	"INIT, 
								 READ_ID, 
								 SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SAVE_CONTROL0,
								 SAVE_ARRAY, 
								 SAVE_USERCODE, 
								 DISABLE";
						 
	"XSRAM Calculate Data CRC"	=	"INIT ! Initialize,
									 READ_ID	! Check the IDCODE,
						 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
						             SAVE_CONTROL0,
						             SAVE_ARRAY,
						             SAVE_USERCODE,
			 						 DISABLE";
		 			 		
	"XSRAM Verify Only"	=	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
								VERIFY_CONTROL	! Verify Control Register,
								VERIFY	! Verify Fuse Map, 
		 			 			VERIFY_USERCODE		! Verify USERCODE, 
		 			 			DISABLE ! Exit the programming mode,
		 			 			VERIFY_STATUS ! Verify Status Register"	;
	"XSRAM Verify USERCODE"	=	"	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
									VERIFY_USERCODE		! Verify USERCODE,
			 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			READ_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;
	"XSRAM Display DONE bit"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			READ_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;					 			
	"XSRAM Read Programming Status" = "INIT ! Initialize,
					 		READ_ID	! Check the IDCODE,
					 		CAPTURE";
	"XSRAM Display Programming Pins Status" = "INIT ! Initialize,
					 		READ_ID	! Check the IDCODE,
					 		CAPTURE";					 		
	"XSRAM Read Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 SAVE_STATUS !Read Status Register,
					             DISABLE";
	"XSRAM Display Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
					 			 SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"XSRAM Verify Status Register" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
					 			 VERIFY_STATUS !verify Status Register,
					             DISABLE";				             
	"XSRAM Read Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"XSRAM Display Control Register0" = "INIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 SAVE_ID,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"XSRAM Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"FLASH TransFR" = "	INIT 	! Initialize, 
					READ_ID	! Check the IDCODE, 
					IO_STATE ! Program Bscan register,
					X_ENABLE	! Enable the X_Programming mode,
					TRANSFR_FUNCTION !FLASH Transparent Field Reconfiguration"	;
					
	"Slave SPI Disable Only" = "SPI_INIT 	! Initialize, 
	 			 				SPI_DISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SPI_INIT 	! Initialize, 
						   	   SPI_READ_ID	! Check the IDCODE,
						  	   SPI_ENABLE	! Enable XPROGRAM mode"	;
						   
	"Slave SPI Re-Initialize" = "SPI_INIT 	! Initialize,  
							 SPI_READ_ID	! Check the IDCODE,
						  	 SPI_ENABLE	! Enable programming mode, 
							 SPI_ERASE	! Erase the device, 
							 SPI_DISABLE ! Exit the programming mode"	;
	 
	"Slave SPI Display USERCODE" =	"SPI_INIT, 
								 SPI_READ_ID, 
								 SPI_SAVE_ID, 
								 SPI_SAVE_USERCODE";								
											 		  	 								
	"Slave SPI Fast Program" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE, 
								SPI_ENABLE	! Enable programming mode, 
								SPI_ERASE	! Erase the device, 
								SPI_PROGRAM	! Program Fuse Map,
								SPI_VERIFY_STATUS ! Read the status bit,
								SPI_DISABLE ! Exit the programming mode"	;			
				 			 			
	"Slave SPI Fast Program,Refresh" = "	SPI_INIT 	! Initialize, 
													SPI_READ_ID	! Check the IDCODE, 
													SPI_ENABLE	! Enable programming mode, 
													SPI_ERASE	! Erase the device, 
													SPI_PROGRAM	! Program Fuse Map,
													SPI_VERIFY_STATUS ! Read the status bit,
													SPI_DISABLE ! Exit the programming mode,
													SPI_REFRESH ! Refresh"	;
										
	"Slave SPI Erase Only"	=	"SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_ENABLE	! Enable programming mode,
								SPI_ERASE	! Erase the device, 
								SPI_DISABLE ! Exit the programming mode"	;	
	"Slave SPI Read and Save"	=	"SPI_INIT, 
									 SPI_READ_ID, 
									 SPI_SAVE_ID, 
									 SPI_SAVE_CONTROL, 
									 SPI_SAVE_ARRAY, 
									 SPI_SAVE_USERCODE";												 
									 																															
	"Slave SPI Verify ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_SAVE_ID";								
					 			 									
	"Slave SPI Read Status Register" = " SPI_INIT ! Initialize,
										 SPI_READ_ID, 
										 SPI_SAVE_ID, 
							             SPI_SAVE_STATUS !Read Status Register";		 
	"Slave SPI Upload to Static RAM" = "SPI_INIT !Initialize,
										SPI_READ_ID !Check the IDCODE,
										SPI_REFRESH ! Refresh";	
	"Slave SPI Display Control Register0" = "SPI_INIT ! Initialize,
							     SPI_READ_ID	! Check the IDCODE,
							     SPI_SAVE_ID,
					 		     SPI_SAVE_CONTROL";	
	"Enable_PROGRAM_SPI0" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI0 ! Enable PROGRAM_SPI0";	
	"Enable_PROGRAM_SPI1" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI1 ! Enable PROGRAM_SPI1";							 		 		     			
	
</Operation_List>
<Operation_List label="SingleSVFOperation">						  
	"Security Read Encryption Key" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   ENABLE	! Enable the programming mode,
						   DISABLE_HASHING,							  						   
						   SVF_CHECK_KEYLOCK ! Check the Key Lock,
						   SVF_READ_SECURITY_KEY ! Check the Security Key,
						   DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key" = "SVFINIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  SVF_CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  							  
							  SVF_PROGRAM_SECURITY_KEY !Program the Security Key,
							  DISABLE ! Exit the programming mode" ;
							  
	"Security Verify Encryption Key" = "SVFINIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  SVF_CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  						   
						   	  SVF_VERIFY_SECURITY_KEY_FUSES ! Check the Security Key,
							  DISABLE ! Exit the programming mode" ;
							  
	
	"Security Program Key Lock" = "SVFINIT 	! Initialize, 
						  READ_ID	! Check the IDCODE,
						  REFRESH_ENABLE	! Enable the programming mode,
						  SVF_CHECK_KEYLOCK ! Check the Key Lock,
						  DISABLE_HASHING,						  						  
						  SVF_PROGRAM_LOCK_FUSES ! Program the Lock Fuses,
						  DISABLE ! Exit the programming mode" ;

	"Security Fast Program with Encryption Option" = "SVFINIT 	! Initialize, 
													  READ_ID	! Check the IDCODE,
													  IO_STATE ! Program Bscan register,
													  REFRESH_ENABLE	! Enable the programming mode,
													  ERASE	! Erase the device, 
													  SVF_CHECK_KEYLOCK ! Check the Key Lock,
													  DISABLE_HASHING,						  													  
													  SVF_PROGRAM_SECURITY_KEY_ONLY !Program the Security Key,
													  SVF_PROGRAM_LOCK_FUSES_ONLY ! Program the Lock Fuses,													  
													  BURST_PROGRAM	! Program Fuse Map,
													  VERIFY_USERCODE		! Verify USERCODE,
													  DISABLE ! Exit the programming mode,
													  VERIFY_STATUS ! Verify Status Register,
													  DISABLE ! Exit the programming mode" ;
													  
	"Security Verify with Encryption Option" = "SVFINIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  IO_STATE ! Program Bscan register,
												  REFRESH_ENABLE	! Enable the programming mode,
												  CHECK_ENCRYPTION_KEY ! Check the Encryption Key,
												  ERASE	! Erase the device, 
												  BURST_PROGRAM	! Program Fuse Map,
												  VERIFY_USERCODE		! Verify USERCODE,
												  DISABLE ! Exit the programming mode,
				 								  VERIFY_STATUS ! Verify Status Register,
												  DISABLE ! Exit the programming mode" ;
												  													  						  
						
	"Bypass"	=	"	SVFINIT 	! Initialize"	;
	"Verify ID" = 	"	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE"	; 
	"Display ID" = 	"SVFINIT, READ_ID, SVF_SAVE_ID";
	"Disable Only" = "	SVFINIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	"Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								VERIFY_USERCODE		! Verify USERCODE"	; 
	"Display USERCODE"	=	"SVFINIT, READ_ID, SVF_SAVE_USERCODE";
	"Program USERCODE"	=	"	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_USERCODE	! Program USERCODE,
						DISABLE ! Exit the programming mode"	; 
	 			 		
	"Enable Only" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode"	;
	"Secure Device" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_SECURITY ! Secure device,
						DISABLE ! Exit the programming mode"	; 
						
	"Program,Verify" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							IO_STATE ! Program Bscan register,
							ENABLE	! Enable the programming mode, 
							ERASE	! Erase the device, 
							PROGRAM_CONTROL	! Program Control Register,
							PROGRAM	! Program Fuse Map,
							VERIFY	! Verify Fuse Map,
							PROGRAM_USERCODE	! Program USERCODE,
							VERIFY_USERCODE		! Verify USERCODE, 
							PROGRAM_DONE_BIT	! Program DONE bit,
				 			DISABLE ! Exit the programming mode,
				 			VERIFY_STATUS ! Verify Status Register"	;
				 			
	"Erase,Program,Verify,Secure"	=	"	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									IO_STATE ! Program Bscan register, 
									ENABLE	! Enable the programming mode,  
									ERASE	! Erase the device, 
									PROGRAM_CONTROL	! Program Control Register, 
									PROGRAM	! Program Fuse Map, 
									PROGRAM_USERCODE	! Program USERCODE,
									VERIFY	! Verify Fuse Map, 
				 			 		VERIFY_USERCODE		! Verify USERCODE, 
				 			 		PROGRAM_SECURITY ! Secure device,
				 			 		PROGRAM_DONE_BIT	! Program DONE bit, 
				 			 		DISABLE ! Exit the programming mode,
				 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode,  
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Refresh,Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								REFRESH_ENABLE	! Refresh and Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;						
								 							 
	"Program" = "	SVFINIT 	! Initialize, 
					READ_ID	! Check the IDCODE,
					IO_STATE ! Program Bscan register,
					ENABLE	! Enable the programming mode,  
					ERASE	! Erase the device, 
					PROGRAM_CONTROL	! Program Control Register,
					PROGRAM	! Program Fuse Map,
					PROGRAM_USERCODE	! Program USERCODE,
					PROGRAM_DONE_BIT	! Program DONE bit,
 			 		DISABLE ! Exit the programming mode,
 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Program Only" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode,  
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;
 	"Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							REFRESH_ENABLE	! Refresh and Enable the programming mode, 
							ERASE	! Erase the device, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Verify Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							ENABLE	! Enable the programming mode, 
							VERIFY_CONTROL	! Verify Control Register,
							VERIFY	! Verify Fuse Map,  
							VERIFY_USERCODE		! Verify USERCODE,
		 			 		DISABLE ! Exit the programming mode,
		 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Blank Check"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							ENABLE	! Enable the programming mode, 
							VERIFY_BLANK_CONTROL	! Verify Control Register,
							VERIFY_BLANK	! Verify Fuse Map,  
							VERIFY_BLANK_USERCODE		! Verify USERCODE,
		 			 		DISABLE ! Exit the programming mode"	;		 			 		
	"Re-Initialize" = " SVFINIT 	! Initialize,
						ENABLE	! Enable the programming mode, 
						ERASE	! Erase the device, 
	 			 		DISABLE ! Exit the programming mode"	;
	
	"Erase DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Program DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"Read DONE bit"	=	"SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 SVF_SAVE_DONE_BIT	! Erase the done bit,
					 DISABLE ! Exit the programming mode"	;
	
	"Display DONE bit"	=	"SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 SVF_SAVE_DONE_BIT	! Erase the done bit,
					 DISABLE ! Exit the programming mode"	;
					 
	"Calculate Data CRC"	=	"SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0,
					             SVF_SAVE_ARRAY,
					             SVF_SAVE_USERCODE,
		 						 DISABLE";
	"Erase,Program,Read and Save" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY_STATUS ! Verify Status Register,
								SAVE_ID, 
								SVF_SAVE_CONTROL0 !Read Control Register 0,
						 		SVF_SAVE_ARRAY ! Read Fuse Map, 
						 		SVF_SAVE_USERCODE ! Read USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode"	;
	"Read and Save ISC"	=	"SVFINIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE, 
						 DISABLE,
						 VERIFY_STATUS ! Verify Status Register";
	"Read and Save"	=	"SVFINIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE, 
						 DISABLE";
	"Refresh" = " 	SVFINIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					REFRESH_FUNCTION ! Refresh";
	"Refresh from FLASH" = " 	SVFINIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					REFRESH_FUNCTION ! Refresh";					
	"Read Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
	
	"Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	
	"Read Programming Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	"Display Programming Pins Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";				 					
	"Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 ENABLE,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";
	"Security Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 ENABLE,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"Display Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 ENABLE,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"Verify Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 ENABLE,
								 VERIFY_STATUS !verify Status Register,
					             DISABLE";								             
	"Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								REFRESH_ENABLE	! Enable the programming mode,  
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;
	"Refresh,Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
						 		REFRESH_ENABLE	! Refresh and Enable the programming mode,  
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;					 			
	
	"JTAG Burst Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"JTAG Burst Enable Only" = "SVFINIT 	! Initialize,
								READ_ID	! Check the IDCODE,
					 			ENABLE	! Enable the programming mode"	;
	"JTAG Burst Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
	"Serial Program" = "	SVFINIT 	! Initialize,   
							SERIAL_PROGRAM	! Program Fuse Map"	;
	"Serial Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	 			 		
	"Serial Enable Only" = "	SVFINIT 	! Initialize, 
								ENABLE	! Enable the programming mode"	;
	"Serial Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
	
	"XSRAM Bypass"	=	"	SVFINIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
					!		TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	"XSRAM Read and Save ISC"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
						 
	"XSRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
									 READ_ID	! Check the IDCODE,
						 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
						             SVF_SAVE_CONTROL0,
						             SVF_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
			 						 DISABLE";
		 			 		
	"XSRAM Verify Only"	=	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
								VERIFY_CONTROL	! Verify Control Register,
								VERIFY	! Verify Fuse Map, 
		 			 			VERIFY_USERCODE		! Verify USERCODE, 
		 			 			DISABLE ! Exit the programming mode,
		 			 			VERIFY_STATUS ! Verify Status Register"	;
	"XSRAM Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
									VERIFY_USERCODE		! Verify USERCODE,
			 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;
	"XSRAM Display DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read Programming Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	"XSRAM Display Programming Pins Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";					 
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";
	"XSRAM Display Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"XSRAM Verify Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 VERIFY_STATUS !verify Status Register,
					             DISABLE";						             
	"XSRAM Read Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"XSRAM Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"XSRAM Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"FLASH TransFR" = "	SVFINIT 	! Initialize, 
					READ_ID	! Check the IDCODE, 
					IO_STATE ! Program Bscan register,
					X_ENABLE	! Enable the X_Programming mode,
					TRANSFR_FUNCTION ! FLASH Transparent Field Reconfiguration"	;			
	
					
	"Slave SPI Disable Only" = "SPI_INIT 	! Initialize, 
	 			 				SPI_DISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SPI_INIT 	! Initialize, 
						   	   SPI_READ_ID	! Check the IDCODE,
						  	   SPI_ENABLE	! Enable XPROGRAM mode"	;
						   
	"Slave SPI Re-Initialize" = "SPI_INIT 	! Initialize,  
							 SPI_READ_ID	! Check the IDCODE,
						  	 SPI_ENABLE	! Enable programming mode, 
							 SPI_ERASE	! Erase the device, 
							 SPI_DISABLE ! Exit the programming mode"	;
	 
	"Slave SPI Display USERCODE" =	"SPI_INIT, 
								 SPI_READ_ID, 
								 SPI_SAVE_ID, 
								 SPI_SVFSAVE_USERCODE";								
											 		  	 								
	"Slave SPI Fast Program" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE, 
								SPI_ENABLE	! Enable programming mode, 
								SPI_ERASE	! Erase the device, 
								SPI_PROGRAM	! Program Fuse Map,
								SPI_VERIFY_STATUS ! Read the status bit,
								SPI_DISABLE ! Exit the programming mode"	;			
				 			 			
	"Slave SPI Fast Program,Refresh" = "	SPI_INIT 	! Initialize, 
													SPI_READ_ID	! Check the IDCODE, 
													SPI_ENABLE	! Enable programming mode, 
													SPI_ERASE	! Erase the device, 
													SPI_PROGRAM	! Program Fuse Map,
													SPI_VERIFY_STATUS ! Read the status bit,
													SPI_DISABLE ! Exit the programming mode,
													SPI_REFRESH ! Refresh"	;
										
	"Slave SPI Erase Only"	=	"SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_ENABLE	! Enable programming mode,
								SPI_ERASE	! Erase the device, 
								SPI_DISABLE ! Exit the programming mode"	;	
	"Slave SPI Read and Save"	=	"SPI_INIT, 
									 SPI_READ_ID,  
									 SPI_SVFSAVE_CONTROL, 
									 SPI_SVFSAVE_ARRAY, 
									 SPI_SVFSAVE_USERCODE";												 
									 																															
	"Slave SPI Verify ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPI_INIT 	! Initialize, 
								SPI_SAVE_ID";								
					 			 									
	"Slave SPI Read Status Register" = " SPI_INIT ! Initialize,
										 SPI_READ_ID,  
							             SPI_SVFSAVE_STATUS !Read Status Register";		 
	"Slave SPI Upload to Static RAM" = "SPI_INIT !Initialize,
										SPI_READ_ID !Check the IDCODE,
										SPI_REFRESH ! Refresh";	
	"Slave SPI Display Control Register0" = "SPI_INIT ! Initialize,
							     SPI_READ_ID	! Check the IDCODE,
							     SPI_SAVE_ID,
					 		     SPI_SVFSAVE_CONTROL";	
    "Enable_PROGRAM_SPI0" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI0 ! Enable PROGRAM_SPI0";	
	"Enable_PROGRAM_SPI1" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI1 ! Enable PROGRAM_SPI1";					 		     												
</Operation_List>
<Operation_List label="TurboOperation">						  
	"Security Read Encryption Key" = "INIT 	! Initialize, 
						   DISABLE_HASHING,							  						   
						   CHECK_KEYLOCK ! Check the Key Lock,
						   READ_SECURITY_KEY ! Check the Security Key" ;
	
	"Security Program Encryption Key" = "INIT 	! Initialize, 
							  CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  							  
							  PROGRAM_SECURITY_KEY !Program the Security Key" ;
							  
	"Security Verify Encryption Key" = "INIT 	! Initialize, 
							  CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  						   
						   	  VERIFY_SECURITY_KEY_FUSES ! Check the Security Key" ;
							  
	
	"Security Program Key Lock" = "INIT 	! Initialize, 
						  CHECK_KEYLOCK ! Check the Key Lock,
						  DISABLE_HASHING,						  						  
						  PROGRAM_LOCK_FUSES ! Program the Lock Fuses" ;
						  
	"Security Fast Program with Encryption Option" = "INIT 	! Initialize, 
													  ERASE	! Erase the device,
													  CHECK_KEYLOCK ! Check the Key Lock,
													  DISABLE_HASHING,						   													  													  
													  PROGRAM_SECURITY_KEY_ONLY !Program the Security Key,
													  PROGRAM_LOCK_FUSES_ONLY ! Program the Lock Fuses,
													  BURST_PROGRAM	! Program Fuse Map,
													  VERIFY_USERCODE		! Verify USERCODE,
													  DISABLE ! Exit the programming mode,
					 								  VERIFY_STATUS ! Verify Status Register" ;	
													  
	"Security Verify with Encryption Option" = "INIT 	! Initialize, 
												  CHECK_ENCRYPTION_KEY ! Check the Encryption Key,
												  ERASE	! Erase the device, 
												  BURST_PROGRAM	! Program Fuse Map,
												  VERIFY_USERCODE		! Verify USERCODE,
												  DISABLE ! Exit the programming mode,
				 								  VERIFY_STATUS ! Verify Status Register" ;													  						  
						  
	"Read and Save"	=	"INIT,SAVE_ARRAY,SAVE_USERCODE";
	"Bypass"	=	"	INIT 	! Initialize"	;
	"Verify ID" = 	"	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE"	; 
	"Display ID" = 	"INIT, READ_ID, SAVE_ID";
	"Disable Only" = "	INIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	"Verify USERCODE"	=	"	INIT 	! Initialize, 
								VERIFY_USERCODE		! Verify USERCODE"	; 
	"Display USERCODE"	=	"INIT, SAVE_USERCODE";	
	"Program USERCODE"	=	"	INIT 	! Initialize, 
						PROGRAM_USERCODE	! Program USERCODE"	; 		 		
	"Enable Only" = "	INIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode"	;
	"Secure Device" = "	INIT 	! Initialize, 
						PROGRAM_SECURITY ! Secure device"	; 
	"Program,Verify" = "	INIT 	! Initialize, 
							ERASE	! Erase the device, 
							PROGRAM_CONTROL	! Program Control Register,
							PROGRAM	! Program Fuse Map,
							VERIFY	! Verify Fuse Map,
							PROGRAM_USERCODE	! Program USERCODE,
							VERIFY_USERCODE		! Verify USERCODE, 
							PROGRAM_DONE_BIT	! Program DONE bit,
							VERIFY_STATUS ! Verify Status Register"	;
	"Erase,Program,Verify" = "	INIT 	! Initialize, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		VERIFY_STATUS ! Verify Status Register"	;					
	"Erase,Program,Verify,Secure"	=	"	INIT 	! Initialize,
									ERASE	! Erase the device,  
									PROGRAM_CONTROL	! Program Control Register, 
									PROGRAM	! Program Fuse Map, 
									PROGRAM_USERCODE	! Program USERCODE,
									VERIFY	! Verify Fuse Map, 
				 			 		VERIFY_USERCODE		! Verify USERCODE, 
				 			 		PROGRAM_SECURITY ! Secure device,
				 			 		PROGRAM_DONE_BIT	! Program DONE bit,
				 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Erase Only"	=	"	INIT 	! Initialize, 
							ERASE	! Erase the device"	;
	"Program" = "	INIT 	! Initialize, 
					ERASE	! Erase the device, 
					PROGRAM_CONTROL	! Program Control Register,
					PROGRAM	! Program Fuse Map,
					PROGRAM_USERCODE	! Program USERCODE,
					PROGRAM_DONE_BIT	! Program DONE bit,
					VERIFY_STATUS ! Verify Status Register"	;
	"Verify Only"	=	"	INIT 	! Initialize, 
							VERIFY_CONTROL	! Verify Control Register,
							VERIFY	! Verify Fuse Map,
							VERIFY_USERCODE		! Verify USERCODE,
							VERIFY_STATUS ! Verify Status Register"	;
	"Blank Check"	=	"	INIT 	! Initialize, 
							VERIFY_BLANK_CONTROL	! Verify Control Register,
							VERIFY_BLANK	! Verify Fuse Map,
							VERIFY_BLANK_USERCODE		! Verify USERCODE"	;							
	"Re-Initialize" = " INIT 	! Initialize,
						ERASE	! Erase the device"	;
	
	"Erase DONE bit"	=	"INIT 	! Initialize, 
							ERASE_DONE_BIT	! Erase the done bit"	;
	"Program DONE bit"	=	"SVFINIT 	! Initialize, 
							PROGRAM_DONE_BIT	! Program DONE bit"	;
	"Read DONE bit"	=	"INIT 	! Initialize, 
					 	READ_DONE_BIT	! Read the done bit"	;
	"Display DONE bit"	=	"INIT 	! Initialize, 
					 	READ_DONE_BIT	! Read the done bit"	;
	"Calculate Data CRC"	=	"INIT ! Initialize,
								 SAVE_CONTROL0,
								 SAVE_ARRAY,
					             SAVE_USERCODE";
	"Erase,Program,Read and Save" = "	INIT 	! Initialize, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY_STATUS ! Verify Status Register,
								SAVE_ID, 
								SAVE_CONTROL0 !Read Control Register 0,
						 		SAVE_ARRAY ! Read Fuse Map, 
						 		SAVE_USERCODE ! Read USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit"	;
	"Read and Save ISC"	=	"INIT, 
						 SAVE_CONTROL0,
						 SAVE_ARRAY, 
						 SAVE_USERCODE";
						 
	"Read and Save"	=	"INIT, 
						 SAVE_CONTROL0,
						 SAVE_ARRAY, 
						 SAVE_USERCODE";
						 
	"Refresh" = " 	INIT !Initialize,
					REFRESH_FUNCTION ! Refresh";
	
	"Refresh from FLASH" = " 	INIT !Initialize,
					REFRESH_FUNCTION ! Refresh";
	"Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
						
	"Read Control Register0" = "INIT ! Initialize,
								 SAVE_ID,
								 SAVE_CONTROL0 !Read Control Register 0";
	"Display Control Register0" = "INIT ! Initialize,
								 SAVE_ID,
								 SAVE_CONTROL0 !Read Control Register 0";								 
	"Program Control Register0" = "INIT ! Initialize,
								 PROGRAM_CONTROL0 ! Program Control Register 0";
	"Read Programming Status" = "INIT ! Initialize,
					 CAPTURE";
	"Display Programming Pins Status" = "INIT ! Initialize,
					 CAPTURE";					 
	"Read Status Register" = "INIT ! Initialize,
							  ENABLE,								
							  SAVE_STATUS !Read Status Register";
	"Security Read Status Register" = "INIT ! Initialize,
							  ENABLE,								
							  SAVE_STATUS !Read Status Register";
	"Display Status Register" = "INIT ! Initialize,
							  ENABLE,
							  SAVE_STATUS !Read Status Register";							  
	"Verify Status Register" = "INIT ! Initialize,
								 ENABLE,
								 VERIFY_STATUS !verify Status Register";								  
	"Fast Program" = "	INIT 	! Initialize,
						ERASE	! Erase the device, 
						BURST_PROGRAM	! Program Fuse Map, 
						VERIFY_USERCODE		! Verify USERCODE,
						VERIFY_STATUS ! Verify Status Register"	;
	
								
	"JTAG Burst Disable Only" = "INIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"JTAG Burst Enable Only" = "INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			ENABLE	! Enable the programming mode"	;
	"JTAG Burst Read DONE bit" = "	INIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
								
	"Serial Program" = "	INIT 	! Initialize,   
							SERIAL_PROGRAM	! Program Fuse Map"	;
	"Serial Disable Only" = "	INIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	 			 		
	"Serial Enable Only" = "	INIT 	! Initialize, 
								ENABLE	! Enable the programming mode"	;
	"Serial Read DONE bit" = "	INIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
									
	"XSRAM Bypass"	=	"	INIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Disable Only" = "	INIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
					!		TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"INIT, 
								 SAVE_CONTROL0,
								 SAVE_ARRAY, 
								 SAVE_USERCODE";
	"XSRAM Read and Save ISC"	=	"INIT, 
								 	 SAVE_CONTROL0,
								 	 SAVE_ARRAY, 
								 	 SAVE_USERCODE";
						 
	"XSRAM Calculate Data CRC"	=	"INIT ! Initialize,
									 SAVE_CONTROL0,
						             SAVE_ARRAY,
						             SAVE_USERCODE";
		 			 		
	"XSRAM Verify Only"	=	"	INIT 	! Initialize, 
								VERIFY_CONTROL	! Verify Control Register,
								VERIFY	! Verify Fuse Map, 
		 			 			VERIFY_USERCODE		! Verify USERCODE,
		 			 			VERIFY_STATUS ! Verify Status Register"	;
	"XSRAM Verify USERCODE"	=	"	INIT 	! Initialize, 
									VERIFY_USERCODE		! Verify USERCODE"	;
	"XSRAM Read DONE bit"	=	"INIT 	! Initialize, 
								READ_DONE_BIT	! Read the done bit"	;
	"XSRAM Display DONE bit"	=	"INIT 	! Initialize, 
								READ_DONE_BIT	! Read the done bit"	;
	"XSRAM Read Programming Status" = "INIT ! Initialize,
					 CAPTURE";
	"XSRAM Display Programming Pins Status" = "INIT ! Initialize,
					 CAPTURE";				 
	"XSRAM Read Status Register" = "INIT ! Initialize,
									SAVE_STATUS !Read Status Register";
	"XSRAM Display Status Register" = "INIT ! Initialize,
									SAVE_STATUS !Read Status Register";								 	
	"XSRAM Verify Status Register" = "INIT ! Initialize,
									VERIFY_STATUS !verify Status Register";					             
	"XSRAM Read Control Register0" = "INIT ! Initialize,
									  SAVE_ID,
								 	  SAVE_CONTROL0 !Read Control Register 0";
	"XSRAM Display Control Register0" = "INIT ! Initialize,
									  SAVE_ID,
								 	  SAVE_CONTROL0 !Read Control Register 0";								 	  
	"XSRAM Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"FLASH TransFR" = "	INIT 	! Initialize, 
					X_ENABLE	! Enable the X_Programming mode,
					TRANSFR_FUNCTION ! FLASH Transparent Field Reconfiguration"	;	

	"Slave SPI Disable Only" = "SPI_INIT 	! Initialize, 
	 			 				SPI_DISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SPI_INIT 	! Initialize, 
						   	   SPI_READ_ID	! Check the IDCODE,
						  	   SPI_ENABLE	! Enable XPROGRAM mode"	;
						   
	"Slave SPI Re-Initialize" = "SPI_INIT 	! Initialize,  
							 SPI_READ_ID	! Check the IDCODE,
						  	 SPI_ENABLE	! Enable programming mode, 
							 SPI_ERASE	! Erase the device, 
							 SPI_DISABLE ! Exit the programming mode"	;
	 
	"Slave SPI Display USERCODE" =	"SPI_INIT, 
								 SPI_READ_ID, 
								 SPI_SAVE_ID, 
								 SPI_SVFSAVE_USERCODE";								
											 		  	 								
	"Slave SPI Fast Program" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE, 
								SPI_ENABLE	! Enable programming mode, 
								SPI_ERASE	! Erase the device, 
								SPI_PROGRAM	! Program Fuse Map,
								SPI_VERIFY_STATUS ! Read the status bit,
								SPI_DISABLE ! Exit the programming mode"	;			
				 			 			
	"Slave SPI Fast Program,Refresh" = "	SPI_INIT 	! Initialize, 
													SPI_READ_ID	! Check the IDCODE, 
													SPI_ENABLE	! Enable programming mode, 
													SPI_ERASE	! Erase the device, 
													SPI_PROGRAM	! Program Fuse Map,
													SPI_VERIFY_STATUS ! Read the status bit,
													SPI_DISABLE ! Exit the programming mode,
													SPI_REFRESH ! Refresh"	;
										
	"Slave SPI Erase Only"	=	"SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_ENABLE	! Enable programming mode,
								SPI_ERASE	! Erase the device, 
								SPI_DISABLE ! Exit the programming mode"	;	
	"Slave SPI Read and Save"	=	"SPI_INIT, 
									 SPI_READ_ID, 
									 SPI_SVFSAVE_CONTROL, 
									 SPI_SVFSAVE_ARRAY, 
									 SPI_SVFSAVE_USERCODE";												 
									 																															
	"Slave SPI Verify ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPI_INIT 	! Initialize, 
								SPI_SAVE_ID";								
					 			 									
	"Slave SPI Read Status Register" = " SPI_INIT ! Initialize,
										 SPI_READ_ID, 
							             SPI_SVFSAVE_STATUS !Read Status Register";		 
	"Slave SPI Upload to Static RAM" = "SPI_INIT !Initialize,
										SPI_READ_ID !Check the IDCODE,
										SPI_REFRESH ! Refresh";	
	"Slave SPI Display Control Register0" = "SPI_INIT ! Initialize,
							     SPI_READ_ID	! Check the IDCODE,
							     SPI_SAVE_ID,
					 		     SPI_SAVE_CONTROL";			
	"Enable_PROGRAM_SPI0" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI0 ! Enable PROGRAM_SPI0";	
	"Enable_PROGRAM_SPI1" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI1 ! Enable PROGRAM_SPI1";					 		     																		
	
</Operation_List>
<Operation_List label="ChainSVFOperation">
	"Security Read Encryption Key" = "SVFINIT 	! Initialize, 
								DISABLE_HASHING,							  						   		
						   		SVF_CHECK_KEYLOCK ! Check the Key Lock,
								SVF_READ_SECURITY_KEY ! Check the Security Key" ;
	
	"Security Program Encryption Key" = "SVFINIT 	! Initialize,
								SVF_CHECK_KEYLOCK ! Check the Key Lock,
								DISABLE_HASHING,							   							  	
							  	SVF_PROGRAM_SECURITY_KEY !Program the Security Key" ;
	
	"Security Verify Encryption Key" = "SVFINIT 	! Initialize, 
							  SVF_CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  						   
						   	  SVF_VERIFY_SECURITY_KEY_FUSES ! Check the Security Key" ;
							  
	"Security Program Key Lock" = "SVFINIT 	! Initialize, 
								SVF_CHECK_KEYLOCK ! Check the Key Lock,
								DISABLE_HASHING,						  						  		
						  		SVF_PROGRAM_LOCK_FUSES ! Program the Lock Fuses" ;
	
	"Security Fast Program with Encryption Option" = "SVFINIT 	! Initialize, 
													  READ_ID	! Check the IDCODE,
													  IO_STATE ! Program Bscan register,
													  REFRESH_ENABLE	! Enable the programming mode,
													  ERASE	! Erase the device, 
													  SVF_CHECK_KEYLOCK ! Check the Key Lock,	
													  DISABLE_HASHING,						  													  												  
													  SVF_PROGRAM_SECURITY_KEY_ONLY !Program the Security Key,
													  SVF_PROGRAM_LOCK_FUSES_ONLY ! Program the Lock Fuses,													  
													  BURST_PROGRAM	! Program Fuse Map,
													  VERIFY_USERCODE		! Verify USERCODE,
													  DISABLE ! Exit the programming mode,
					 								  VERIFY_STATUS ! Verify Status Register,
													  DISABLE ! Exit the programming mode" ;					  
	
	"Security Verify with Encryption Option" = "SVFINIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  IO_STATE ! Program Bscan register,
												  REFRESH_ENABLE	! Enable the programming mode,
												  CHECK_ENCRYPTION_KEY ! Check the Encryption Key,
												  ERASE	! Erase the device, 
												  BURST_PROGRAM	! Program Fuse Map,
												  VERIFY_USERCODE		! Verify USERCODE,
												  DISABLE ! Exit the programming mode,
				 								  VERIFY_STATUS ! Verify Status Register,
												  DISABLE ! Exit the programming mode" ;
												  					  
	"Read and Save"	=	"INIT,SVF_SAVE_ARRAY,SVF_SAVE_USERCODE";
	"Bypass"	=	"	SVFINIT 	! Initialize"	;
	"Verify ID" = 	"	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE"	; 
	"Display ID" = 	"SVFINIT, READ_ID, SVF_SAVE_ID";
	"Disable Only" = "	SVFINIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	"Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
								VERIFY_USERCODE		! Verify USERCODE"	; 
	"Display USERCODE"	=	"SVFINIT, SVF_SAVE_USERCODE";
	"Program USERCODE"	=	"	SVFINIT 	! Initialize, 
						PROGRAM_USERCODE	! Program USERCODE"	; 				 		
	"Enable Only" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode"	;
	"Secure Device" = "	SVFINIT 	! Initialize, 
						PROGRAM_SECURITY ! Secure device"	; 
	"Program,Verify" = "	SVFINIT 	! Initialize, 
							ERASE	! Erase the device, 
							PROGRAM_CONTROL	! Program Control Register,
							PROGRAM	! Program Fuse Map,
							VERIFY	! Verify Fuse Map,
							PROGRAM_USERCODE	! Program USERCODE,
							VERIFY_USERCODE		! Verify USERCODE, 
							PROGRAM_DONE_BIT	! Program DONE bit,
							VERIFY_STATUS ! Verify Status Register"	;					 
	"Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		VERIFY_STATUS ! Verify Status Register"	;					
	
	"Erase,Program,Verify,Secure"	=	"	SVFINIT 	! Initialize,
									ERASE	! Erase the device,  
									PROGRAM_CONTROL	! Program Control Register, 
									PROGRAM	! Program Fuse Map, 
									PROGRAM_USERCODE	! Program USERCODE,
									VERIFY	! Verify Fuse Map, 
				 			 		VERIFY_USERCODE		! Verify USERCODE, 
				 			 		PROGRAM_SECURITY ! Secure device,
				 			 		PROGRAM_DONE_BIT	! Program DONE bit,
				 			 		VERIFY_STATUS ! Verify Status Register"	;

	"Program" = "	SVFINIT 	! Initialize,
					ERASE	! Erase the device, 
					PROGRAM_CONTROL	! Program Control Register,
					PROGRAM	! Program Fuse Map,
					PROGRAM_USERCODE	! Program USERCODE,
					PROGRAM_DONE_BIT	! Program DONE bit,
					VERIFY_STATUS ! Verify Status Register"	;
	"Verify Only"	=	"	SVFINIT 	! Initialize,
							VERIFY_CONTROL	! Program Control Register, 
							VERIFY	! Verify Fuse Map,
							VERIFY_USERCODE		! Verify USERCODE,
							VERIFY_STATUS ! Verify Status Register"	;
	"Blank Check"	=	"	SVFINIT 	! Initialize,
							VERIFY_BLANK_CONTROL	! Program Control Register, 
							VERIFY_BLANK	! Verify Fuse Map,
							VERIFY_BLANK_USERCODE		! Verify USERCODE"	;
	"Erase Only"	=	"	SVFINIT 	! Initialize, 
							ERASE	! Erase the device"	;
	"Re-Initialize" = " SVFINIT 	! Initialize,
						ERASE	! Erase the device"	;
	
	"Erase DONE bit"	=	"SVFINIT 	! Initialize, 
							ERASE_DONE_BIT	! Erase the done bit"	;
	"Program DONE bit"	=	"SVFINIT 	! Initialize, 
							PROGRAM_DONE_BIT	! Program DONE bit"	;
	"Read DONE bit"	=	"SVFINIT 	! Initialize, 
					 	SVF_SAVE_DONE_BIT	! Erase the done bit"	;
	"Display DONE bit"	=	"SVFINIT 	! Initialize, 
					 	SVF_SAVE_DONE_BIT	! Erase the done bit"	;
	"Calculate Data CRC"	=	"SVFINIT ! Initialize,
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY,
					             SVF_SAVE_USERCODE";
	"Erase,Program,Read and Save" = "	SVFINIT 	! Initialize, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY_STATUS ! Verify Status Register,
								SAVE_ID, 
								SVF_SAVE_CONTROL0 !Read Control Register 0,
						 		SVF_SAVE_ARRAY ! Read Fuse Map, 
						 		SVF_SAVE_USERCODE ! Read USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit"	;
	"Read and Save ISC"	=	"SVFINIT, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE";
	"Read and Save"	=	"SVFINIT, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE";						 
	"Refresh" = " 	SVFINIT !Initialize,
					REFRESH_FUNCTION ! Refresh";
	"Refresh from FLASH" = " 	SVFINIT !Initialize,
					REFRESH_FUNCTION ! Refresh";					
	"Capture Only" = "	INIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"Read Control Register0" = "SVFINIT ! Initialize,
								 SVF_SAVE_CONTROL0 !Read Control Register 0";
	"Display Control Register0" = "SVFINIT ! Initialize,
								 SVF_SAVE_CONTROL0 !Read Control Register 0";								 
	"Program Control Register0" = "SVFINIT ! Initialize,
								 PROGRAM_CONTROL0 ! Program Control Register 0";
	
	"Read Programming Status" = "SVFINIT ! Initialize,
					 CAPTURE";
	"Display Programming Pins Status" = "SVFINIT ! Initialize,
					 CAPTURE";				 
	"Read Status Register" = "SVFINIT ! Initialize,
							  ENABLE,
							  SAVE_STATUS !Read Status Register";
	"Security Read Status Register" = "SVFINIT ! Initialize,
							  ENABLE,
							  SAVE_STATUS !Read Status Register";							  
	"Display Status Register" = "SVFINIT ! Initialize,
	                          ENABLE,
							  SAVE_STATUS !Read Status Register";							  
	"Verify Status Register" = "SVFINIT ! Initialize,
	                            ENABLE,
								VERIFY_STATUS !verify Status Register";								  								 
	"Fast Program" = "	SVFINIT 	! Initialize,
						ERASE	! Erase the device, 
						BURST_PROGRAM	! Program Fuse Map,
						VERIFY_USERCODE		! Verify USERCODE,
						VERIFY_STATUS ! Verify Status Register"	;
	
	"JTAG Burst Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"JTAG Burst Enable Only" = "SVFINIT 	! Initialize,
								READ_ID	! Check the IDCODE,
					 			ENABLE	! Enable the programming mode"	;
	"JTAG Burst Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;								 
	"Serial Program" = "	SVFINIT 	! Initialize,    
							SERIAL_PROGRAM	! Program Fuse Map"	;
	"Serial Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	 			 		
	"Serial Enable Only" = "	SVFINIT 	! Initialize, 
								ENABLE	! Enable the programming mode"	;
	"Serial Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
													
	"XSRAM Bypass"	=	"	SVFINIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
					!		TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"SVFINIT, 
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE";
	"XSRAM Read and Save ISC"	=	"SVFINIT, 
								 	 SVF_SAVE_CONTROL0,
								 	 SVF_SAVE_ARRAY, 
								 	 SVF_SAVE_USERCODE";
						 
	"XSRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
									 SVF_SAVE_CONTROL0,
						             SVF_SAVE_ARRAY,
						             SVF_SAVE_USERCODE";
		 			 		
	"XSRAM Verify Only"	=	"	SVFINIT 	! Initialize, 
								VERIFY_CONTROL	! Verify Control Register,
								VERIFY	! Verify Fuse Map, 
		 			 			VERIFY_USERCODE		! Verify USERCODE,
		 			 			VERIFY_STATUS ! Verify Status Register"	;
	"XSRAM Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
									VERIFY_USERCODE		! Verify USERCODE"	;
	"XSRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								SVF_SAVE_DONE_BIT	! Read the done bit"	;
	"XSRAM Display DONE bit"	=	"SVFINIT 	! Initialize, 
								SVF_SAVE_DONE_BIT	! Read the done bit"	;
	"XSRAM Read Programming Status" = "SVFINIT ! Initialize,
					 	   CAPTURE";
	"XSRAM Display Programming Pins Status" = "SVFINIT ! Initialize,
					 	   CAPTURE";				 
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
									SVF_SAVE_STATUS !Read Status Register";
	"XSRAM Display Status Register" = "SVFINIT ! Initialize,
									SVF_SAVE_STATUS !Read Status Register";								 	
	"XSRAM Verify Status Register" = "SVFINIT ! Initialize,
									VERIFY_STATUS !verify Status Register";					             
	"XSRAM Read Control Register0" = "SVFINIT ! Initialize,
								 	  SVF_SAVE_CONTROL0 !Read Control Register 0";
	"XSRAM Display Control Register0" = "SVFINIT ! Initialize,
								 	  SVF_SAVE_CONTROL0 !Read Control Register 0";								 	  
	"XSRAM Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"FLASH TransFR" = "	SVFINIT 	! Initialize, 
					X_ENABLE	! Enable the X_Programming mode,
					TRANSFR_FUNCTION ! FLASH Transparent Field Reconfiguration"	;		
					
	"Slave SPI Disable Only" = "SPI_INIT 	! Initialize, 
	 			 				SPI_DISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SPI_INIT 	! Initialize, 
						   	   SPI_READ_ID	! Check the IDCODE,
						  	   SPI_ENABLE	! Enable XPROGRAM mode"	;
						   
	"Slave SPI Re-Initialize" = "SPI_INIT 	! Initialize,  
							 SPI_READ_ID	! Check the IDCODE,
						  	 SPI_ENABLE	! Enable programming mode, 
							 SPI_ERASE	! Erase the device, 
							 SPI_DISABLE ! Exit the programming mode"	;
	 
	"Slave SPI Display USERCODE" =	"SPI_INIT, 
								 SPI_READ_ID, 
								 SPI_SAVE_ID, 
								 SPI_SVFSAVE_USERCODE";								
											 		  	 								
	"Slave SPI Fast Program" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE, 
								SPI_ENABLE	! Enable programming mode, 
								SPI_ERASE	! Erase the device, 
								SPI_PROGRAM	! Program Fuse Map,
								SPI_VERIFY_STATUS ! Read the status bit,
								SPI_DISABLE ! Exit the programming mode"	;			
				 			 			
	"Slave SPI Fast Program,Refresh" = "	SPI_INIT 	! Initialize, 
													SPI_READ_ID	! Check the IDCODE, 
													SPI_ENABLE	! Enable programming mode, 
													SPI_ERASE	! Erase the device, 
													SPI_PROGRAM	! Program Fuse Map,
													SPI_VERIFY_STATUS ! Read the status bit,
													SPI_DISABLE ! Exit the programming mode,													
													SPI_REFRESH ! Refresh"	;
										
	"Slave SPI Erase Only"	=	"SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_ENABLE	! Enable programming mode,
								SPI_ERASE	! Erase the device, 
								SPI_DISABLE ! Exit the programming mode"	;	
	"Slave SPI Read and Save"	=	"SPI_INIT, 
									 SPI_READ_ID, 
									 SPI_SVFSAVE_CONTROL, 
									 SPI_SVFSAVE_ARRAY, 
									 SPI_SVFSAVE_USERCODE";												 
									 																															
	"Slave SPI Verify ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPI_INIT 	! Initialize, 
								SPI_SAVE_ID";								
					 			 									
	"Slave SPI Read Status Register" = " SPI_INIT ! Initialize,
										 SPI_READ_ID, 
							             SPI_SVFSAVE_STATUS !Read Status Register";		 
	"Slave SPI Upload to Static RAM" = "SPI_INIT !Initialize,
										SPI_READ_ID !Check the IDCODE,
										SPI_REFRESH ! Refresh";	
	"Slave SPI Display Control Register0" = "SPI_INIT ! Initialize,
							     SPI_READ_ID	! Check the IDCODE,
							     SPI_SAVE_ID,
					 		     SPI_SVFSAVE_CONTROL";				
	"Enable_PROGRAM_SPI0" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI0 ! Enable PROGRAM_SPI0";	
	"Enable_PROGRAM_SPI1" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI1 ! Enable PROGRAM_SPI1";					 		     									
</Operation_List>
<Operation_List label="SingleSVFOperationRevC">
	"Security Read Encryption Key" = "SVFINIT 	! Initialize, 
						   READ_ID	! Check the IDCODE,
						   ENABLE	! Enable the programming mode,
						   DISABLE_HASHING,							  						   
						   SVF_CHECK_KEYLOCK ! Check the Key Lock,
						   SVF_READ_SECURITY_KEY ! Check the Security Key,
						   DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key" = "SVFINIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  SVF_CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  							  
							  SVF_PROGRAM_SECURITY_KEY !Program the Security Key,
							  DISABLE ! Exit the programming mode" ;
	
	"Security Verify Encryption Key" = "SVFINIT 	! Initialize, 
							  READ_ID	! Check the IDCODE,
							  REFRESH_ENABLE	! Enable the programming mode,
							  SVF_CHECK_KEYLOCK ! Check the Key Lock,
							  DISABLE_HASHING,							  						   
						   	  SVF_VERIFY_SECURITY_KEY_FUSES ! Check the Security Key,
							  DISABLE ! Exit the programming mode" ;
							  
	"Security Program Key Lock" = "SVFINIT 	! Initialize, 
						  READ_ID	! Check the IDCODE,
						  REFRESH_ENABLE	! Enable the programming mode,
						  SVF_CHECK_KEYLOCK ! Check the Key Lock,
						  DISABLE_HASHING,							  						  
						  SVF_PROGRAM_LOCK_FUSES ! Program the Lock Fuses,
						  DISABLE ! Exit the programming mode" ;
	
	"Security Fast Program with Encryption Option" = "SVFINIT 	! Initialize, 
													  READ_ID	! Check the IDCODE,
													  IO_STATE ! Program Bscan register,
													  REFRESH_ENABLE	! Enable the programming mode,
													  ERASE	! Erase the device, 
													  SVF_CHECK_KEYLOCK ! Check the Key Lock,
													  DISABLE_HASHING,							  													  													  
													  SVF_PROGRAM_SECURITY_KEY_ONLY !Program the Security Key,
													  SVF_PROGRAM_LOCK_FUSES_ONLY ! Program the Lock Fuses,													  
													  BURST_PROGRAM	! Program Fuse Map,
													  VERIFY_USERCODE		! Verify USERCODE,
													  DISABLE ! Exit the programming mode,
					 								  VERIFY_STATUS ! Verify Status Register,
													  DISABLE ! Exit the programming mode" ;
													  
	"Security Verify with Encryption Option" = "SVFINIT 	! Initialize, 
												  READ_ID	! Check the IDCODE,
												  IO_STATE ! Program Bscan register,
												  REFRESH_ENABLE	! Enable the programming mode,
												  CHECK_ENCRYPTION_KEY ! Check the Encryption Key,
												  ERASE	! Erase the device, 
												  BURST_PROGRAM	! Program Fuse Map,
												  VERIFY_USERCODE		! Verify USERCODE,
												  DISABLE ! Exit the programming mode,
				 								  VERIFY_STATUS ! Verify Status Register,
												  DISABLE ! Exit the programming mode" ;													  
						
	"Bypass"	=	"	SVFINIT 	! Initialize"	;
	"Verify ID" = 	"	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE"	; 
	"Display ID" = 	"SVFINIT, READ_ID, SVF_SAVE_ID";
	"Disable Only" = "	SVFINIT 	! Initialize, 
	 			 		DISABLE ! Exit the programming mode"	;
	"Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								VERIFY_USERCODE		! Verify USERCODE"	; 
	"Display USERCODE"	=	"SVFINIT, READ_ID, SVF_SAVE_USERCODE";
	"Program USERCODE"	=	"	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_USERCODE	! Program USERCODE,
						DISABLE ! Exit the programming mode"	; 
	 			 		
	"Enable Only" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode"	;
	"Secure Device" = "	SVFINIT 	! Initialize, 
						READ_ID	! Check the IDCODE,
						ENABLE	! Enable the programming mode,
						PROGRAM_SECURITY ! Secure device,
						DISABLE ! Exit the programming mode"	; 
						
	"Program,Verify" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,  
							IO_STATE ! Program Bscan register,
							ENABLE	! Enable the programming mode, 
							ERASE	! Erase the device, 
							PROGRAM_CONTROL	! Program Control Register,
							PROGRAM	! Program Fuse Map,
							VERIFY	! Verify Fuse Map,
							PROGRAM_USERCODE	! Program USERCODE,
							VERIFY_USERCODE		! Verify USERCODE, 
							PROGRAM_DONE_BIT	! Program DONE bit,
				 			DISABLE ! Exit the programming mode,
				 			VERIFY_STATUS ! Verify Status Register"	;
				 			
	"Erase,Program,Verify,Secure"	=	"	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									IO_STATE ! Program Bscan register, 
									ENABLE	! Enable the programming mode,  
									ERASE	! Erase the device, 
									PROGRAM_CONTROL	! Program Control Register, 
									PROGRAM	! Program Fuse Map, 
									PROGRAM_USERCODE	! Program USERCODE,
									VERIFY	! Verify Fuse Map, 
				 			 		VERIFY_USERCODE		! Verify USERCODE, 
				 			 		PROGRAM_SECURITY ! Secure device,
				 			 		PROGRAM_DONE_BIT	! Program DONE bit, 
				 			 		DISABLE ! Exit the programming mode,
				 			 		VERIFY_STATUS ! Verify Status Register"	;
	
	
	"Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode,  
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Refresh,Erase,Program,Verify" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								REFRESH_ENABLE	! Refresh and Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY	! Verify Fuse Map, 
			 			 		VERIFY_USERCODE		! Verify USERCODE, 
			 			 		PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode,
			 			 		VERIFY_STATUS ! Verify Status Register"	;						
								 							 
	"Program" = "	SVFINIT 	! Initialize, 
					READ_ID	! Check the IDCODE,
					IO_STATE ! Program Bscan register,
					ENABLE	! Enable the programming mode,  
					ERASE	! Erase the device, 
					PROGRAM_CONTROL	! Program Control Register,
					PROGRAM	! Program Fuse Map,
					PROGRAM_USERCODE	! Program USERCODE,
					PROGRAM_DONE_BIT	! Program DONE bit,
 			 		DISABLE ! Exit the programming mode,
 			 		VERIFY_STATUS ! Verify Status Register"	;
 	"Erase Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							IO_STATE ! Program Bscan register,
							REFRESH_ENABLE	! Refresh and Enable the programming mode, 
							ERASE	! Erase the device, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Verify Only"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							ENABLE	! Enable the programming mode, 
							VERIFY_CONTROL	! Verify Control Register,
							VERIFY	! Verify Fuse Map,  
							VERIFY_USERCODE		! Verify USERCODE,
		 			 		DISABLE ! Exit the programming mode,
		 			 		VERIFY_STATUS ! Verify Status Register"	;
	"Blank Check"	=	"	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							ENABLE	! Enable the programming mode, 
							VERIFY_BLANK_CONTROL	! Verify Control Register,
							VERIFY_BLANK	! Verify Fuse Map,  
							VERIFY_BLANK_USERCODE		! Verify USERCODE,
		 			 		DISABLE ! Exit the programming mode"	;		 			 		
	"Re-Initialize" = " SVFINIT 	! Initialize,
						ENABLE	! Enable the programming mode, 
						ERASE	! Erase the device, 
	 			 		DISABLE ! Exit the programming mode"	;
	
	"Erase DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							ERASE_DONE_BIT	! Erase the done bit, 
		 			 		DISABLE ! Exit the programming mode"	;
	"Program DONE bit"	=	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							ENABLE	! Enable programming mode, 
							PROGRAM_DONE_BIT	! Program DONE bit,
		 			 		DISABLE ! Exit the programming mode"	;
	"Read DONE bit"	=	"SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 SVF_SAVE_DONE_BIT	! Erase the done bit,
					 DISABLE ! Exit the programming mode"	;
	
	"Display DONE bit"	=	"SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 ENABLE	! Enable programming mode, 
					 SVF_SAVE_DONE_BIT	! Erase the done bit,
					 DISABLE ! Exit the programming mode"	;
					 
	"Calculate Data CRC"	=	"SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0,
					             SVF_SAVE_ARRAY,
					             SVF_SAVE_USERCODE,
		 						 DISABLE";
	"Erase,Program,Read and Save" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								ENABLE	! Enable the programming mode, 
								ERASE	! Erase the device, 
								PROGRAM_CONTROL	! Program Control Register,
								PROGRAM	! Program Fuse Map,
								PROGRAM_USERCODE	! Program USERCODE,
								VERIFY_STATUS ! Verify Status Register,
								SAVE_ID, 
								SVF_SAVE_CONTROL0 !Read Control Register 0,
						 		SVF_SAVE_ARRAY ! Read Fuse Map, 
						 		SVF_SAVE_USERCODE ! Read USERCODE,
								PROGRAM_DONE_BIT	! Program DONE bit,
			 			 		DISABLE ! Exit the programming mode"	;
	"Read and Save ISC"	=	"SVFINIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE, 
						 DISABLE";
	"Read and Save"	=	"SVFINIT, 
						 READ_ID, 
						 SAVE_ID, 
						 ENABLE, 
						 SVF_SAVE_CONTROL0,
						 SVF_SAVE_ARRAY, 
						 SVF_SAVE_USERCODE, 
						 DISABLE";
	"Refresh" = " 	SVFINIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					SVF_REFRESH_FUNCTION ! Refresh";
	"Refresh from FLASH" = " 	SVFINIT !Initialize,
					READ_ID !Check the IDCODE,
					IO_STATE ! Program Bscan register,
					SVF_REFRESH_FUNCTION ! Refresh";					
	"Read Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"Program Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 ENABLE	! Enable programming mode, 
					             PROGRAM_CONTROL0 ! Program Control Register 0,
					             DISABLE";
	
	"Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	
	"Read Programming Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	"Display Programming Pins Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";				 					
	"Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";
	"Security Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"Display Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID,
					 			 ENABLE, 
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"Verify Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
								 ENABLE,
								 VERIFY_STATUS !verify Status Register,
					             DISABLE";								             
	"Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
						 		REFRESH_ENABLE	! Enable the programming mode,  
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;
	"Refresh,Fast Program" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
						 		REFRESH_ENABLE	! Refresh and Enable the programming mode,  
						 		ERASE	! Erase the device, 
								BURST_PROGRAM	! Program Fuse Map,
								VERIFY_USERCODE		! Verify USERCODE,
					 			DISABLE ! Exit the programming mode,
					 			VERIFY_STATUS ! Verify Status Register"	;					 			
	
	"JTAG Burst Disable Only" = "SVFINIT 	! Initialize, 
	 			 			DISABLE ! Exit the programming mode"	;
	 			 		
	"JTAG Burst Enable Only" = "SVFINIT 	! Initialize,
								READ_ID	! Check the IDCODE,
					 			ENABLE	! Enable the programming mode"	;
	"JTAG Burst Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
	"Serial Program" = "	SVFINIT 	! Initialize,   
							SERIAL_PROGRAM	! Program Fuse Map"	;
	"Serial Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	 			 		
	"Serial Enable Only" = "	SVFINIT 	! Initialize, 
								ENABLE	! Enable the programming mode"	;
	"Serial Read DONE bit" = "	SVFINIT 	! Initialize, 
								SERIAL_READ_DONE_BIT 	! Read DONE Bit"	;
	
	"XSRAM Bypass"	=	"	SVFINIT 	! Initialize"	;
	"XSRAM Verify ID" = 	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE"	; 
	"XSRAM Disable Only" = "	SVFINIT 	! Initialize, 
	 			 				DISABLE ! Exit the programming mode"	;
	"XSRAM Enable Only" = "	SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
					!		TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT mode"	;
	"XSRAM Read and Save"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
	"XSRAM Read and Save ISC"	=	"SVFINIT, 
								 READ_ID, 
								 SVF_SAVE_ID, 
								 TRANSPARENT_READ_ENABLE, 
								 SVF_SAVE_CONTROL0,
								 SVF_SAVE_ARRAY, 
								 SVF_SAVE_USERCODE, 
								 DISABLE";
						 
	"XSRAM Calculate Data CRC"	=	"SVFINIT ! Initialize,
									 READ_ID	! Check the IDCODE,
						 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
						             SVF_SAVE_CONTROL0,
						             SVF_SAVE_ARRAY,
						             SVF_SAVE_USERCODE,
			 						 DISABLE";
		 			 		
	"XSRAM Verify Only"	=	"	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
								VERIFY_CONTROL	! Verify Control Register,
								VERIFY	! Verify Fuse Map, 
		 			 			VERIFY_USERCODE		! Verify USERCODE, 
		 			 			DISABLE ! Exit the programming mode,
		 			 			VERIFY_STATUS ! Verify Status Register"	;
	"XSRAM Verify USERCODE"	=	"	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode, 
									VERIFY_USERCODE		! Verify USERCODE,
			 			 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;
	"XSRAM Display DONE bit"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
					 			TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					 			SVF_SAVE_DONE_BIT	! Read the done bit,
					 			DISABLE ! Exit the programming mode"	;
	"XSRAM Read Programming Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";
	"XSRAM Display Programming Pins Status" = "SVFINIT ! Initialize,
					 READ_ID	! Check the IDCODE,
					 CAPTURE";					 
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";
	"XSRAM Display Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 SAVE_ID, 
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 SVF_SAVE_STATUS !Read Status Register,
					             DISABLE";					             
	"XSRAM Verify Status Register" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,
					 			 VERIFY_STATUS !verify Status Register,
					             DISABLE";						             
	"XSRAM Read Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";
	"XSRAM Display Control Register0" = "SVFINIT ! Initialize,
								 READ_ID	! Check the IDCODE,
					 			 TRANSPARENT_READ_ENABLE	! Enable TRANSPARENT programming mode,  
					             SVF_SAVE_CONTROL0 !Read Control Register 0,
					             DISABLE";					             
	"XSRAM Capture Only" = "	SVFINIT 	! Initialize,
						READ_ID	! Check the IDCODE,
						IO_STATE ! Capture Bscan register"	;
	"FLASH TransFR" = "	SVFINIT 	! Initialize, 
					READ_ID	! Check the IDCODE, 
					IO_STATE ! Program Bscan register,
					X_ENABLE	! Enable the X_Programming mode,
					SVF_TRANSFR_FUNCTION ! FLASH Transparent Field Reconfiguration"	;
					
	"Slave SPI Disable Only" = "SPI_INIT 	! Initialize, 
	 			 				SPI_DISABLE ! Exit the programming mode"	;
	"Slave SPI Enable Only" = "SPI_INIT 	! Initialize, 
						   	   SPI_READ_ID	! Check the IDCODE,
						  	   SPI_ENABLE	! Enable XPROGRAM mode"	;
						   
	"Slave SPI Re-Initialize" = "SPI_INIT 	! Initialize,  
							 SPI_READ_ID	! Check the IDCODE,
						  	 SPI_ENABLE	! Enable programming mode, 
							 SPI_ERASE	! Erase the device, 
							 SPI_DISABLE ! Exit the programming mode"	;
	 
	"Slave SPI Display USERCODE" =	"SPI_INIT, 
								 SPI_READ_ID, 
								 SPI_SAVE_ID, 
								 SPI_SVFSAVE_USERCODE";								
											 		  	 								
	"Slave SPI Fast Program" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE, 
								SPI_ENABLE	! Enable programming mode, 
								SPI_ERASE	! Erase the device, 
								SPI_PROGRAM	! Program Fuse Map,
								SPI_VERIFY_STATUS ! Read the status bit,
								SPI_DISABLE ! Exit the programming mode"	;			
				 			 			
	"Slave SPI Fast Program,Refresh" = "	SPI_INIT 	! Initialize, 
													SPI_READ_ID	! Check the IDCODE, 
													SPI_ENABLE	! Enable programming mode, 
													SPI_ERASE	! Erase the device, 
													SPI_PROGRAM	! Program Fuse Map,
													SPI_VERIFY_STATUS ! Read the status bit,
													SPI_DISABLE ! Exit the programming mode,
													SPI_REFRESH ! Refresh"	;
										
	"Slave SPI Erase Only"	=	"SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE,
								SPI_ENABLE	! Enable programming mode,
								SPI_ERASE	! Erase the device, 
								SPI_DISABLE ! Exit the programming mode"	;	
	"Slave SPI Read and Save"	=	"SPI_INIT, 
									 SPI_READ_ID, 
									 SPI_SVFSAVE_CONTROL, 
									 SPI_SVFSAVE_ARRAY, 
									 SPI_SVFSAVE_USERCODE";												 
									 																															
	"Slave SPI Verify ID" = "	SPI_INIT 	! Initialize, 
								SPI_READ_ID	! Check the IDCODE";
	"Slave SPI Display ID" = "	SPI_INIT 	! Initialize, 
								SPI_SAVE_ID";								
					 			 									
	"Slave SPI Read Status Register" = " SPI_INIT ! Initialize,
										 SPI_READ_ID, 
							             SPI_SVFSAVE_STATUS !Read Status Register";		 
	"Slave SPI Upload to Static RAM" = "SPI_INIT !Initialize,
										SPI_READ_ID !Check the IDCODE,
										SPI_REFRESH ! Refresh";	
	"Slave SPI Display Control Register0" = "SPI_INIT ! Initialize,
							     SPI_READ_ID	! Check the IDCODE,
							     SPI_SAVE_ID,
					 		     SPI_SVFSAVE_CONTROL";	
	"Enable_PROGRAM_SPI0" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI0 ! Enable PROGRAM_SPI0";	
	"Enable_PROGRAM_SPI1" = "SPI_INIT 	! Initialize, 
							 SPI_READ_ID	! Check the IDCODE,	
							 SPI_PROGRAM_SPI1 ! Enable PROGRAM_SPI1";					 		     														
</Operation_List>
<Script>
<![CDATA[
int32	ReturnCode = 0;
int32	WriteManufacturing = 0;
function INIT {
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
}


function SVFINIT {
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
}

function PRELOAD {
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
}

function INI_PRELOAD {				
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length);
}
function SAMPLE {		
	! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   STATE DRPAUSE;
   STATE IDLE;		
}

function INI_SAMPLE {	
	! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   STATE DRPAUSE;
   STATE IDLE;			
}
function CAPTURE {	
	datastream SavedBScanTDO[1][BSCAN_Length];	
	file NewFile = "FILE_SAVE";		
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length)
   					TDO(SavedBScanTDO[1]);
   Bscan[1] = SavedBScanTDO[1];	
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
   // Write To file 
   fopen NewFile att "w"
					 format "SVF_Plus";	
   fwrite NewFile (BSCAN_TDO, Bscan);
   fclose 	NewFile;
   
}

function DYNAMIC {	
   ENDDR DRPAUSE;
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(BPRELOAD);
   SDR BSCAN_Length TDI(Bscan[1])
   					DMASK(BscanMask[1]);
   STATE IDLE;
}

function ENABLE {
	! Shift in ISC ENABLE(0x15) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
	RUN_TEST	IDLE	TCK 5 DELAY 20;
	
}
function X_ENABLE
{
	! Shift in X_PROGRAM_ENABLE(0x35) instruction;
    SIR Instruction_Length TDI (X_PROGRAM_ENABLE);
	RUN_TEST	IDLE	TCK 5 DELAY 20;
}
// 03/23/05 Spinti: Added function REFRESH_ENABLE to reset device error state before enabling device
function REFRESH_ENABLE {
	! Shift in LSCC REFRESH(0x23) instruction;
    SIR Instruction_Length	TDI (LSCC_REFRESH);
    //this device required minimum 2 TCK and the delay of 1ms in order to work.
	RUN_TEST IDLE TCK 5 DELAY 500;
	
	! Shift in ISC ENABLE(0x15) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
	RUN_TEST IDLE TCK 5 DELAY 20;
}
function CLEAR_ERROR {
	IF (ReturnCode == 0x01)
	{
		ReturnCode = 0;
		! Shift in LSCC REFRESH(0x23) instruction;
    	SIR Instruction_Length	TDI (LSCC_REFRESH);
		STATE IDLE; 
	}	
}
function TRANSPARENT_READ_ENABLE {
	! Shift in LSCC_TRANSPARENT_ENABLE(0x75) instruction;
    SIR Instruction_Length TDI (LSCC_TRANSPARENT_ENABLE);
	RUN_TEST	IDLE	TCK 5 DELAY 20;
}

function DISABLE {
	! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 100 DELAY 1;
}
function READ_ID {
	ReturnCode = 0;
	! Shift in IDCODE(0x16) instruction;
    SIR Instruction_Length 	TDI (IDCODE);
	SDR_VERIFY	ID_Length	TDI (#1^ID_Length)
					        TDO	(IDTDI[1])
					        MASK (DEVICE_ID_MASK);
}

function ERASE {	
	! Shift in ISC PROGRAM USERCODE(0x1A) instruction;
	SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
	SDR Usercode_Length	TDI	(#1^Usercode_Length);
	RUN_TEST	TCK 	5 DELAY 	PWP;
	
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#1^Usercode_Length);

	! Shift in ISC ERASE(0x03) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
	RUN_TEST 	TCK 5 DELAY 2000;
	
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	RUN_TEST	IDLE TCK 5 DELAY 	PWP;
	
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#0^Usercode_Length);
									
}
// 01/22/07 Spinti: Added function REFRESH_ERASE to clear device for SPIm mode programming
function REFRESH_ERASE {	
	! Shift in ISC PROGRAM USERCODE(0x1A) instruction;
	SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
	SDR Usercode_Length	TDI	(#1^Usercode_Length);
	RUN_TEST	TCK 	5 DELAY 	PWP;
	
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#1^Usercode_Length);

	! Shift in ISC ERASE(0x03) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
	RUN_TEST 	TCK 5 DELAY 100;
	
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#0^Usercode_Length);

	IF (ISSPIFLASH == 1)
	{
		! Shift in ISC PROGRAM DONE(0x2F) instruction;
	    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
		// Goto Run Test Idle 
		RUN_TEST	IDLE TCK 5 DELAY 50;
	}
}
function PROGRAM_CONTROL {
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSCC PROGRAM CONTROL 0(0x47) instruction;
	    SIR Instruction_Length TDI (LSCC_PROGRAM_CTRL0);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		RUN_TEST IDLE TCK 5 DELAY PWP; 
		! Shift in LSCC READ CONTROL 0(0x4A) instruction;
	    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
		RUN_TEST IDLE TCK 5 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1])
					   MASK(0xFFFFFFFF);
	}
	
}

function PROGRAM_CONTROL0 {
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSCC PROGRAM CONTROL 0(0x47) instruction;
	    SIR Instruction_Length TDI (LSCC_PROGRAM_CTRL0);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		RUN_TEST IDLE TCK 5 DELAY PWP; 
		! Shift in LSCC READ CONTROL 0(0x4A) instruction;
	    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
		RUN_TEST IDLE TCK 5 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1])
					   MASK(0xFFFFFFFF);
	}
}

function PROGRAM {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	! Shift in LSCC BITSTREAM BURST(0x02) instruction;
    SIR Instruction_Length	TDI (LSCC_BITSTREAM_BURST);
	SDR	129		TDI	(#1^129);
	RUN_TEST	IDLE TCK 5 DELAY PWP;
	
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	RUN_TEST	IDLE TCK 5 DELAY 	PWP;
	! Shift in LSCC PROGRAM INCR RTI(0x67) instruction;
    SIR Instruction_Length	TDI (LSCC_PROGRAM_INCR_RTI);
	// Program the rest of the device
	repeat Address_Length {
		! Shift in Data Row = RowCount; 
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		RUN_TEST	TCK 	5 DELAY 	PWP;
		RowCount = RowCount + 1 ;
		
	} // repeat
}
function SERIAL_PROGRAM {
	FuseArray_TDI.row = 1;
	SDR	TotalFuse	TDI	(FuseArray_TDI[1]);
	RUN_TEST	TCK 	1000 ;
}

function BURST_PROGRAM {
	FuseArray_TDI.row = 1;
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	RUN_TEST	IDLE TCK 5 DELAY 	PWP;
	! Shift in LSCC BITSTREAM BURST(0x02) instruction;
    SIR Instruction_Length	TDI (LSCC_BITSTREAM_BURST);
    ! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI[1]);
	RUN_TEST	IDLE TCK 256 DELAY PWP;
}

function PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in ISC PROGRAM USERCODE(0x1A) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		RUN_TEST	TCK 	5 DELAY 	PWP;
	}
}
function PROGRAM_DONE_BIT {
	! Shift in ISC PROGRAM DONE(0x2F) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	// Goto Run Test Idle 
	RUN_TEST	IDLE TCK 5 DELAY 50;
	! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 32 DELAY 10;
	! Shift in IDCODE(0x16) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (IDCODE)
						TDO(0xFF)
			   	      	MASK(0x04);	
}
function ERASE_DONE_BIT {
	! Shift in ISC ERASE DONE(0x24) instruction;
    SIR	Instruction_Length 	TDI (ISC_ERASE_DONE);
	// Goto Run Test Idle 
	RUN_TEST	TCK 5
				DELAY 50;
	STATE IDLE;
}
// Verify Functions _____________________________________________
function VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	RUN_TEST	IDLE TCK 5 DELAY 	PWV;
	! Shift in LSCC READ INCR RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSCC_READ_INCR_RTI);
	repeat Address_Length {
		RUN_TEST	IDLE TCK 5 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
								TDO	(FuseArray_TDI)
								MASK(FuseArray_MASK);
		RowCount = RowCount +1;
	}
}
function VERIFY_BLANK {
	int32	RowCount = 1;
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	RUN_TEST	IDLE TCK 5 DELAY 	PWV;
	! Shift in LSCC READ INCR RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSCC_READ_INCR_RTI);
	repeat Address_Length {
		RUN_TEST	IDLE TCK 5 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
								TDO	(#0^Row_Width);
		RowCount = RowCount +1;
	}
}
function VERIFY_CONTROL {
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSCC READ CONTROL 0(0x4A) instruction;
	    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
		RUN_TEST IDLE TCK 5 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(Control_Register_0_TDI[1])
				       MASK(0xFFEEFFFF);
	}
	
}
function VERIFY_BLANK_CONTROL {
	! Shift in LSCC READ CONTROL 0(0x4A) instruction;
    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
	RUN_TEST IDLE TCK 5 DELAY PWV; 
	SDR_VERIFY  32 TDI(0x00000000)
			   	   TDO(0x00000000);
}
function VERIFY_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0x17) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
									TDO	(Usercode_TDI);
	}
}
function VERIFY_BLANK_USERCODE {
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#0^Usercode_Length);
}
function VERIFY_STATUS {
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR_VERIFY	32	TDI(#1^32)
					TDO(0x00020000)
					MASK(0x00060007);
	
}
function PROGRAM_SECURITY {
	! Shift in ISC PROGRAM SECURITY(0x09) instruction;
    SIR Instruction_Length	TDI	(ISC_PROGRAM_SECURITY);
	RUN_TEST	IDLE TCK 	5 DELAY 	50;
}
function SAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE"; 
	! Shift in IDCODE(0x16) instruction;
    SIR Instruction_Length	TDI	(IDCODE);
	SDR	ID_Length	TDI (#1^ID_Length)
					TDO	(SavedID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SVF_SAVE_ID	{
	! Shift in IDCODE(0x16) instruction;
    SIR Instruction_Length 	TDI (IDCODE);
	SDR_VERIFY	ID_Length	TDI (#1^ID_Length)
							TDO	(IDTDI[1])
							MASK (#0^ID_Length);
}
function SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";

	Address.row = 1;	
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	STATE IDLE;
	! Shift in LSCC READ INCR RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSCC_READ_INCR_RTI);
	
	// Program the rest of the device 
	repeat Address_Length {
		// Goto Run Test Idle
		RUN_TEST	TCK 	5 DELAY 	PWV;						
		! Shift Out Data Row = RowCount;
	    SDR Row_Width 	TDI (#0^Row_Width)
						TDO (SavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SVF_SAVE_ARRAY {
	int32	RowCount = 1;
	Address.row = 1;	
	! Shift in LSCC RESET ADDRESS(0x21) instruction;
    SIR Instruction_Length	TDI (LSCC_RESET_ADDRESS);
	STATE IDLE;
	
	! Shift in LSCC READ INCR RTI(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSCC_READ_INCR_RTI);
	
	repeat Address_Length {
		RUN_TEST	TCK 	5 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
	    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
								TDO	(#1^Row_Width)
								MASK (#0^Row_Width);
		RowCount = RowCount +1;
	}
}
function SAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length	TDI (USERCODE);
	SDR	Usercode_Length	TDI(#1^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SVF_SAVE_USERCODE {
	! Shift in READ USERCODE(0x17) instruction;
    SIR Instruction_Length TDI (USERCODE);
	SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
								TDO	(#1^Usercode_Length)
								MASK(#0^Usercode_Length);
}

function SAVE_STATUS {
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR	32	TDI(#1^32)
			TDO(SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SVF_SAVE_STATUS {
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    ! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length TDI (LSCC_READ_STATUS);
	SDR_VERIFY 	32 TDI (#1^32)
				   TDO	(#1^32)
				   MASK(#0^32);
}
function SERIAL_READ_DONE_BIT {
	datastream SavedDONE_BIT[1][1];
	file	NewFile = "FILE_SAVE"; 
	
	SDR 1	TDI	(0x00)
			TDO (SavedDONE_BIT);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (DONE_BIT, SavedDONE_BIT);
	fclose 	NewFile;
}
function READ_DONE_BIT {
	datastream SavedDONE_BIT[1][Instruction_Length];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in IDCODE(0x16) instruction;
    SIR Instruction_Length	TDI	(IDCODE)
							TDO (SavedDONE_BIT);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (DONE_BIT, SavedDONE_BIT);
	fclose 	NewFile;
}
function SVF_SAVE_DONE_BIT {
	! Shift in IDCODE(0x16) instruction;
    SIR_VERIFY Instruction_Length	TDI	(0x16)
				TDO (#1^Instruction_Length)
				MASK(#0^Instruction_Length);
}

function SAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSCC READ CONTROL 0(0x4A) instruction;
    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
	RUN_TEST IDLE TCK 5 DELAY PWV; 
	SDR  32 TDI(0x00000000)
				   TDO(SavedControl0);
				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}

function SVF_SAVE_CONTROL0 
{
	! Shift in LSCC READ CONTROL 0(0x4A) instruction;
    SIR Instruction_Length TDI (LSCC_READ_CTRL0);
	RUN_TEST IDLE TCK 5 DELAY PWV; 
	SDR_VERIFY  32 TDI(0x00000000)
				   TDO(0x00000000)
				   MASK(0x00000000);
}

function TRANSFR_FUNCTION 
{
	! Shift in LSCC REFRESH(0x23) instruction;
    SIR Instruction_Length	TDI (LSCC_REFRESH);
	RUN_TEST IDLE TCK 5 DELAY 1000; 
	
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	LCOUNT 20;
	LDELAY IDLE  DELAY 1000;
	LSDR	32	TDI(#1^32)
			TDO(0x00020000)
			MASK(0x00060007);
	
	! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	
	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 5 DELAY MDRDelay;
}
function SVF_TRANSFR_FUNCTION 
{
	! Shift in LSCC REFRESH(0x23) instruction;
    SIR Instruction_Length	TDI (LSCC_REFRESH);
	RUN_TEST IDLE TCK 5 DELAY 20000; 
	
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR_VERIFY	32	TDI(#1^32)
					TDO(0x00020000)
					MASK(0x00060007);
					
	! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	
	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 5 DELAY MDRDelay;
}		
function REFRESH_FUNCTION 
{
	! Shift in LSCC REFRESH(0x23) instruction;
    SIR Instruction_Length	TDI (LSCC_REFRESH);
// 03/18/08 Spinti: Increased delay time since READ_STATUS cannot be used during configuration since it blocks MCLK.
//	RUN_TEST IDLE TCK 5 DELAY 1000; 
	RUN_TEST IDLE TCK 5 DELAY 20000; 

// 03/17/08 Spinti: Commented out since the READ_STATUS stops the MCLK in first silicon.
//	! Shift in LSCC READ STATUS(0x53) instruction;
//    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
//	LCOUNT 20;
//	LDELAY IDLE  DELAY 1000;
//	LSDR	32	TDI(#1^32)
//			TDO(0x00020000)
//			MASK(0x00060007);

// 03/18/08 Spinti: Decreased delay time after the BYPASS instruction.
	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 10000;
	
			
// 03/18/08 Spinti: Added LSCC_TRANSPARENT_ENABLE.
	! Shift in LSCC_TRANSPARENT_ENABLE(0x75) instruction;
    SIR Instruction_Length TDI (LSCC_TRANSPARENT_ENABLE);
	RUN_TEST	IDLE	TCK 5 DELAY 20;

// 03/18/08 Spinti: Removed the looping from READ_STATUS cannot be used during configuration since it blocks MCLK.
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
    SDR_VERIFY	32	TDI(#1^32)
					TDO(0x00020000)
					MASK(0x00060007);
			
// 03/18/08 Spinti: Added ISC DISABLE.
	! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	
}	
function SVF_REFRESH_FUNCTION 
{
	! Shift in LSCC REFRESH(0x23) instruction;
    SIR Instruction_Length	TDI (LSCC_REFRESH);
	RUN_TEST IDLE TCK 5 DELAY 20000; 
	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 10000;
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR_VERIFY	32	TDI(#1^32)
					TDO(0x00020000)
					MASK(0x00060007);
			
}	
function CHECK_ENCRYPTION_KEY
{
	datastream Manufacturing[1][32];
	datastream SavedKEY2Fuse[1][129];
	datastream SavedKEY1Fuse[1][129];
	datastream SavedKEY3Fuse[1][129];
	TRY 1{
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
				        TDO(0x00000010)
				        MASK(0x00000010);
	}
	ELSE
	{				  
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY1Fuse[1]);
		IF (SavedKEY1Fuse[1] == (#0^129))
		{
			print (1,"Encryption fuses are not programmed. Cannot continue.");
		}
			
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY2Fuse[1]);
		IF (SavedKEY2Fuse[1] == (#0^129))
		{
			print (1,"Encryption fuses are not programmed. Cannot continue.");
		}
		! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY3Fuse[1]);
		IF (SavedKEY3Fuse[1] == (#0^129))
		{
			print (1,"Encryption fuses are not programmed. Cannot continue.");						
		}	
	}
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY PWP;
}
function CHECK_KEYLOCK 
{
	TRY 1{
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129);
	    
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129);
	    
	    ! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129);
	    
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
				        TDO(0x00000000)
				        MASK(0x00000010);
	}
	ELSE
	{	
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;			  
		! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"The device Security Lock fuses are programmed. Cannot continue.");
	}
}
function SVF_CHECK_KEYLOCK 
{
	TRY 1{
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
				        TDO(0x00000000)
				        MASK(0x00000010);
	}
	ELSE
	{				  
		! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"The device Security Lock fuses are programmed. Cannot continue.");
	}
	
}
function ENABLE_HASHING
{
	//print (0,"The MFG<20:0> value 01000000000001001101");	
	//print (0,"Enable 1st level hashing");
	//print (0,"Disable Majority Decode");
	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004004D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
    WriteManufacturing = 0;
}
function DISABLE_HASHING
{	   
	//print (0,"The MFG<20:0> value 01000000011001001101");	
	//print (0,"Disables 1st level hashing");
	//print (0,"Disable Majority Decode");
	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
    WriteManufacturing = 0;
}
function PROGRAM_SECURITY_KEY 
{
	datastream Manufacturing[1][32];
	datastream KeysFuses[1][165];
	datastream KeysFuses1[1][128];
	datastream SavedLockFuses[1][165];
	
	datastream SavedKEY1Fuse[1][165];
	datastream SavedKEY1Fuse1[1][129];
	datastream SavedKEY1Fuse2[1][128];
	
	datastream SavedKEY2Fuse[1][165];
	datastream SavedKEY2Fuse1[1][129];
	datastream SavedKEY2Fuse2[1][128];
	
	datastream SavedKEY3Fuse[1][165];
	datastream SavedKEY3Fuse1[1][129];
	datastream SavedKEY3Fuse2[1][128];
	
	int32	   OverProgram = 0;
	int32	   LockProgram = 0;
	SecurityKey.row = 1;
	ReturnCode = 0;
	KeysFuses1[1] = SecurityKey[1];
	KeysFuses1[1] = $KeysFuses1[1];
	KeysFuses[1] = ((#0^4) @ SecurityKey[1]) @ (#0^36);
	
	//disable Hashing
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
	
    // verify that no KEY_1 fuses have been programmed
	TRY 1 { 
	   	! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 1 fuses already programmed.");
	}
    // verify that no KEY_2 fuses have been programmed 
    TRY 1 {
		! Shift in KEY_2_READ(0xC6) instruction;
		SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
    {
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 2 fuses already programmed.");
	}
	// verify that no KEY3 fuses have been programmed 
	TRY 1 {
		! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 3 fuses already programmed.");
	}
	
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_1_READ(0xC4) instruction;
	SIR Instruction_Length	TDI (KEY_1_READ);
	SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY1Fuse[1]);
	
	SavedKEY1Fuse[1] = SavedKEY1Fuse[1] << 36;			
	IF (SavedKEY1Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 1 register. Cannot Continue.");
		
	}	
	// Program the KEY_1 fuses		
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
		    			
	// Verify the KEY_1 fuses
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY1Fuse1[1]);
	SavedKEY1Fuse2[1] = (SavedKEY1Fuse1[1] << 8);
	SavedKEY1Fuse2[1] = $SavedKEY1Fuse2[1];
	IF (KeysFuses1[1] != SavedKEY1Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 1 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY1Fuse2);
			check_over_program (SecurityKey,SavedKEY1Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;			
		}	
	}
	ELSE
	{
		print (0,"Row 1 fuses programmed successful.");
	}
	
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
	SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY2Fuse[1]);

	SavedKEY2Fuse[1] = SavedKEY2Fuse[1] << 36;			
	IF (SavedKEY2Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 2 register. Cannot Continue.");
	}	
	
	//Program the KEY_2 fuses
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
				
	// Verify the KEY_2 fuses
	! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY2Fuse1[1]);	
	SavedKEY2Fuse2[1] = (SavedKEY2Fuse1[1] << 8);
	SavedKEY2Fuse2[1] = $SavedKEY2Fuse2[1];					
	IF (KeysFuses1[1] != SavedKEY2Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 2 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY2Fuse2);
			check_over_program (SecurityKey,SavedKEY2Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;
		    IF (OverProgram == 2)
		    {
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to program Row 2 fuses. Cannot Continue.");
			}
		}
	}
	ELSE
	{
		print (0,"Row 2 fuses programmed successful.");			
	}				
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_3_READ(0xC7) instruction;
	SIR Instruction_Length	TDI (KEY_3_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
	SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_3_READ(0xC7) instruction;
	SIR Instruction_Length	TDI (KEY_3_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY3Fuse[1]);
	
	SavedKEY3Fuse[1] = SavedKEY3Fuse[1] << 36;			
	IF (SavedKEY3Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 3 register. Cannot Continue.");
	}
	// Program the KEY_3 fuses
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
    
	// Verify the KEY_3 fuses
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY3Fuse1[1]);	
	SavedKEY3Fuse2[1] = (SavedKEY3Fuse1[1] << 8);
	SavedKEY3Fuse2[1] = $SavedKEY3Fuse2[1];
	IF (KeysFuses1[1] != SavedKEY3Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 3 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY3Fuse2);
			check_over_program (SecurityKey,SavedKEY3Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;
		    IF (OverProgram == 2)
		    {
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to program Row 3 fuses. Cannot Continue.");
			}
		}
	}
	ELSE
	{
		print (0,"Row 3 fuses programmed successful.");	
	}			
	// If All three fuses failed then reject the part
	IF ( ReturnCode == 0x01)
	{
		print (0,"Two out of three row fuses programmed successful. The Encryption Keys programing passed");	
	}
	ELSEIF ( ReturnCode == 0x02)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"Two out of three row fuses programmmed un-successful.");
		print (1,"Failed to program the Encryption fuses.");		
	}
	ELSEIF ( ReturnCode == 0x03)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"All three row fuses programmed un-successful.");
		print (1,"Failed to program the Encryption fuses.");	
	}
	ELSE
	{
		print (0,"The Encryption Keys programing passed");
	}
	
	// Program the Key Lock fuses
	IF (KeyLock == 0x01)
	{
		KeysFuses[1] = 0x1000000000000000000000000000000000000000000;
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x0004044D);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
		
		// Program the KEY_1 fuses		
		! Shift in KEY_1_PROGRAM(0xC0) instruction;
	    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
	    
	    //Program the KEY_2 fuses
		! Shift in KEY_2_PROGRAM(0xC2) instruction;
	    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
					
		// Program the KEY_3 fuses
		! Shift in KEY_3_PROGRAM(0xC3) instruction;
	    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
		
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY1Fuse1[1]);
		SavedKEY1Fuse2[1] = (SavedKEY1Fuse1[1] << 8); 		
		IF (SavedKEY1Fuse2[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 1 Lock fuses programmed successful.");	
		}
		
		! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY2Fuse1[1]);
		SavedKEY2Fuse2[1] = (SavedKEY2Fuse1[1] << 8);
		IF (SavedKEY2Fuse2[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 2 Lock fuses programmed successful.");	
		}
		! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedKEY3Fuse1[1]);
		SavedKEY3Fuse2[1] = (SavedKEY3Fuse1[1] << 8);
		IF (SavedKEY3Fuse2[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 3 Lock fuses programmed successful.");	
		}
	    TRY 1 {
		    ! Shift in LSCC READ STATUS(0x53) instruction;
		    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
			SDR_VERIFY	32	TDI(#1^32)
							TDO (0x00000010)
							MASK(0x00000017);
			print (0,"Key Lock fuses programmed successful.");
		}			
		ELSE
		{
			! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
		    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
		    SDR 32 TDI(0x00000000);
		    RUN_TEST IDLE TCK 5 DELAY PWP;
		    ! Shift in ISC DISABLE(0x1E) instruction;
	    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 5 DELAY 10;
			print (1,"Failed to program the Key Lock fuses.");
		}
	}	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;
    
}
function PROGRAM_SECURITY_KEY_ONLY  
{
	datastream Manufacturing[1][32];
	datastream KeysFuses[1][165];
	datastream KeysFuses1[1][128];
	datastream SavedLockFuses[1][165];
	
	datastream SavedKEY1Fuse[1][165];
	datastream SavedKEY1Fuse1[1][129];
	datastream SavedKEY1Fuse2[1][128];
	
	datastream SavedKEY2Fuse[1][165];
	datastream SavedKEY2Fuse1[1][129];
	datastream SavedKEY2Fuse2[1][128];
	
	datastream SavedKEY3Fuse[1][165];
	datastream SavedKEY3Fuse1[1][129];
	datastream SavedKEY3Fuse2[1][128];
	
	int32	   OverProgram = 0;
	int32	   LockProgram = 0;
	SecurityKey.row = 1;
	ReturnCode = 0;
	KeysFuses1[1] = SecurityKey[1];
	KeysFuses1[1] = $KeysFuses1[1];
	KeysFuses[1] = ((#0^4) @ SecurityKey[1]) @ (#0^36);
	
	//disable Hashing
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
	
    // verify that no KEY_1 fuses have been programmed
	TRY 1 { 
	   	! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 1 fuses already programmed.");
	}
    // verify that no KEY_2 fuses have been programmed 
    TRY 1 {
		! Shift in KEY_2_READ(0xC6) instruction;
		SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
    {
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 2 fuses already programmed.");
	}
	// verify that no KEY3 fuses have been programmed 
	TRY 1 {
		! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR_VERIFY	 129	TDI(#0^129)
					        TDO(#0^129);
	}
	ELSE
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 3 fuses already programmed.");
	}
	
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_1_READ(0xC4) instruction;
	SIR Instruction_Length	TDI (KEY_1_READ);
	SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY1Fuse[1]);
	
	SavedKEY1Fuse[1] = SavedKEY1Fuse[1] << 36;			
	IF (SavedKEY1Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 1 register. Cannot Continue.");
		
	}	
	// Program the KEY_1 fuses		
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
		    			
	// Verify the KEY_1 fuses
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY1Fuse1[1]);
	SavedKEY1Fuse2[1] = (SavedKEY1Fuse1[1] << 8);
	SavedKEY1Fuse2[1] = $SavedKEY1Fuse2[1];
	IF (KeysFuses1[1] != SavedKEY1Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 1 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY1Fuse2);
			check_over_program (SecurityKey,SavedKEY1Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;			
		}	
	}
	ELSE
	{
		print (0,"Row 1 fuses programmed successful.");
	}
	
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
	SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY2Fuse[1]);

	SavedKEY2Fuse[1] = SavedKEY2Fuse[1] << 36;			
	IF (SavedKEY2Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 2 register. Cannot Continue.");
	}	
	
	//Program the KEY_2 fuses
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
				
	// Verify the KEY_2 fuses
	! Shift in KEY_2_READ(0xC6) instruction;
	SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY2Fuse1[1]);	
	SavedKEY2Fuse2[1] = (SavedKEY2Fuse1[1] << 8);	
	SavedKEY2Fuse2[1] = $SavedKEY2Fuse2[1];				
	IF (KeysFuses1[1] != SavedKEY2Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 2 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY2Fuse2);
			check_over_program (SecurityKey,SavedKEY2Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;
		    IF (OverProgram == 2)
		    {
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to program Row 2 fuses. Cannot Continue.");
			}
		}
	}
	ELSE
	{
		print (0,"Row 2 fuses programmed successful.");			
	}				
	//Make sure the data shift in and out the register is corrected.
	! Shift in KEY_3_READ(0xC7) instruction;
	SIR Instruction_Length	TDI (KEY_3_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
	SDR	 165	TDI(KeysFuses[1]);
    
    ! Shift in KEY_3_READ(0xC7) instruction;
	SIR Instruction_Length	TDI (KEY_3_READ);
	RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 165	TDI(KeysFuses[1])
				TDO(SavedKEY3Fuse[1]);
	
	SavedKEY3Fuse[1] = SavedKEY3Fuse[1] << 36;			
	IF (SavedKEY3Fuse[1] != KeysFuses[1])
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to shift data in Row 3 register. Cannot Continue.");
	}
	// Program the KEY_3 fuses
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
    
	// Verify the KEY_3 fuses
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY3Fuse1[1]);	
	SavedKEY3Fuse2[1] = (SavedKEY3Fuse1[1] << 8);
	SavedKEY3Fuse2[1] = $SavedKEY3Fuse2[1];
	IF (KeysFuses1[1] != SavedKEY3Fuse2[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 3 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses1);
			print (0,"Actual:");
			print (0,SavedKEY3Fuse2);
			check_over_program (SecurityKey,SavedKEY3Fuse2);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;
		    IF (OverProgram == 2)
		    {
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to program Row 3 fuses. Cannot Continue.");
			}
		}
	}
	ELSE
	{
		print (0,"Row 3 fuses programmed successful.");	
	}			
	// If All three fuses failed then reject the part
	IF ( ReturnCode == 0x01)
	{
		print (0,"Two out of three row fuses programmed successful. The Encryption Keys programing passed");	
	}
	ELSEIF ( ReturnCode == 0x02)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"Two out of three row fuses programmmed un-successful.");
		print (1,"Failed to program the Encryption fuses.");		
	}
	ELSEIF ( ReturnCode == 0x03)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"All three row fuses programmed un-successful.");
		print (1,"Failed to program the Encryption fuses.");	
	}
	ELSE
	{
		print (0,"The Encryption Keys programing passed");
	}
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;    
}
function SVF_PROGRAM_SECURITY_KEY 
{
	datastream KeysFuses1[1][129];
	datastream KeysFuses[1][165];
	SecurityKey.row = 1;
	KeysFuses[1] = ((#0^4) @ SecurityKey[1]) @ (#0^36);
	KeysFuses1[1] = #0 @ SecurityKey[1];
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);
						
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);
		
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);
	
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);
						
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);	
																	
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);	
						
	IF (KeyLock == 0x01)
	{
		KeysFuses[1] = 0x100000000000000000000000000000000000000000;
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
		SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
		SDR 32 TDI(0x0004044D);
		RUN_TEST IDLE TCK 5 DELAY 1000;
		
		! Shift in KEY_1_PROGRAM(0xC0) instruction;
	    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
		RUN_TEST IDLE TCK 5 DELAY 3000;
		
	    ! Shift in KEY_2_PROGRAM(0xC2) instruction;
	    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
	  
		! Shift in KEY_3_PROGRAM(0xC3) instruction;
	    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
		RUN_TEST IDLE TCK 5 DELAY 3000;
	
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
						TDO (0x00000010)
						MASK(0x00000017);
    			
	}								
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;
}
function SVF_PROGRAM_SECURITY_KEY_ONLY 
{
	datastream KeysFuses1[1][129];
	datastream KeysFuses[1][165];
	SecurityKey.row = 1;
	KeysFuses[1] = ((#0^4) @ SecurityKey[1]) @ (#0^36);
	KeysFuses1[1] = #0 @ SecurityKey[1];

	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);			
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);	
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129);
			
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);
						
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);	
											
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
	RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses1[1]);							
	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;   
}
function VERIFY_SECURITY_KEY_FUSES
{
	int32	   OverProgram;
	datastream KeysFuses[1][128];
	datastream SavedKEY1Fuse[1][129];
	datastream SavedKEY2Fuse[1][129];
	datastream SavedKEY3Fuse[1][129];
	
	datastream SavedKEY1Fuse1[1][128];
	datastream SavedKEY2Fuse1[1][128];
	datastream SavedKEY3Fuse1[1][128];
	
	OverProgram = 0;
	ReturnCode = 0;
	SecurityKey.row = 1;
	KeysFuses[1] = SecurityKey[1];	
	KeysFuses[1] = $KeysFuses[1];
		
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY1Fuse[1]);
	SavedKEY1Fuse1[1] = SavedKEY1Fuse[1] << 8;
	SavedKEY1Fuse1[1] = $SavedKEY1Fuse1[1];
	IF (SavedKEY1Fuse1[1] != KeysFuses[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 1 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses);
			print (0,"Actual:");
			print (0,SavedKEY1Fuse1);
			check_over_program (KeysFuses,SavedKEY1Fuse1);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;			
		}	
	}
	ELSE
	{
		print (0,"Row 1 fuses verified successful.");			
	}
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY2Fuse[1]);	
	SavedKEY2Fuse1[1] = SavedKEY2Fuse[1] << 8;
	SavedKEY2Fuse1[1] = $SavedKEY2Fuse1[1];
	IF (SavedKEY2Fuse1[1] != KeysFuses[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 2 fuses verified un-successful.");			
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses);
			print (0,"Actual:");
			print (0,SavedKEY2Fuse1);
			check_over_program (KeysFuses,SavedKEY2Fuse1);			
		}
		ELSE
		{
			OverProgram = OverProgram + 1;	
			IF (OverProgram == 2)
			{	
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to verify the Encryption fuses.");
			}
		}	
	}
	ELSE
	{
		print (0,"Row 2 fuses verified successful.");	
	}
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY3Fuse[1]);
	SavedKEY3Fuse1[1] = SavedKEY3Fuse[1] << 8;	
	SavedKEY3Fuse1[1] = $SavedKEY3Fuse1[1];
	IF (SavedKEY3Fuse1[1] != KeysFuses[1])
	{
		ReturnCode = ReturnCode + 1;
		print (0,"Row 3 fuses verified un-successful.");
		TRY 1 {
			print (0,"Expected:");
			print (0,KeysFuses);
			print (0,"Actual:");
			print (0,SavedKEY3Fuse1);
			check_over_program (KeysFuses,SavedKEY3Fuse1);		
		}
		ELSE
		{
			OverProgram = OverProgram + 1;
			IF (OverProgram == 2)
			{	
				! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
			    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
			    SDR 32 TDI(0x00000000);
			    RUN_TEST IDLE TCK 5 DELAY PWP;
			    ! Shift in ISC DISABLE(0x1E) instruction;
		    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 5 DELAY 10;
				print (1,"Failed to verify the Encryption fuses.");
			}				
		}	
	}
	ELSE
	{
		print (0,"Row 3 fuses verified successful.");			
	}
	// If All three fuses failed then reject the part
	IF ( ReturnCode == 0x01)
	{
		print (0,"Two out of three row fuses verified successful. Verification passed");	
	}
	ELSEIF ( ReturnCode == 0x02)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"Two out of three row fuses verified un-successful.");
		print (1,"Failed to verify the Encryption fuses.");		
	}
	ELSEIF ( ReturnCode == 0x03)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
	    print (0,"All three row fuses verified un-successful.");
		print (1,"Failed to verify the Encryption fuses.");	
	}
	ELSE
	{
		print (0,"Verification passed");
	}
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;
}
function SVF_VERIFY_SECURITY_KEY_FUSES
{
	datastream KeysFuses[1][129];
	SecurityKey.row = 1;
	KeysFuses[1] = #0 @ SecurityKey[1];
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses[1]);
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses[1]);
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(KeysFuses[1]);
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;
}
function PROGRAM_LOCK_FUSES
{
	datastream Manufacturing[1][32];
	datastream KeysFuses[1][165];
	datastream SavedLockFuses[1][165];
	datastream SavedKeysFuses[1][129];
	datastream SavedKeysFuses1[1][128];
	int32 LockProgram = 0;
	
	KeysFuses[1] = 0x1000000000000000000000000000000000000000000;
	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);
	IF (SavedKeysFuses1[1] == 0x00000000000000000000000000000000)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 1 Fuses are not programmed. Cannot Continue.");
	}
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);
	IF (SavedKeysFuses1[1] == 0x00000000000000000000000000000000)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 2 Fuses are not programmed. Cannot Continue.");
	}
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);
	IF (SavedKeysFuses1[1] == 0x00000000000000000000000000000000)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Row 3 Fuses are not programmed. Cannot Continue.");
	}			        	
    // Program the KEY_1 fuses		
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
    
    //Program the KEY_2 fuses
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
				
	// Program the KEY_3 fuses
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);	
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);			
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 1 Lock fuses programmed successful.");	
	}
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);	
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);			
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 2 Lock fuses programmed successful.");	
	}
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);			
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 3 Lock fuses programmed successful.");	
	}
    TRY 1 {
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
						TDO (0x00000010)
						MASK(0x00000017);
		print (0,"Key Lock fuses programmed successful.");
	}			
	ELSE
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY PWP;
	    ! Shift in ISC DISABLE(0x1E) instruction;
    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 5 DELAY 10;
		print (1,"Failed to program the Key Lock fuses.");
	}
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;									
}
function PROGRAM_LOCK_FUSES_ONLY
{
	datastream Manufacturing[1][32];
	datastream KeysFuses[1][165];
	datastream SavedLockFuses[1][129];
	datastream SavedLockFuses1[1][128];
	int32 LockProgram = 0;
	KeysFuses[1] = 0x1000000000000000000000000000000000000000000;
	IF (KeyLock == 0x01)
	{
		print (0,"Program the Key Lock fuses.");
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x0004044D);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
    					
	    // Program the KEY_1 fuses		
		! Shift in KEY_1_PROGRAM(0xC0) instruction;
	    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;	
		
	    //Program the KEY_2 fuses
		! Shift in KEY_2_PROGRAM(0xC2) instruction;
	    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
					
		// Program the KEY_3 fuses
		! Shift in KEY_3_PROGRAM(0xC3) instruction;
	    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
	
		! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedLockFuses[1]);
		SavedLockFuses1[1] = (SavedLockFuses[1] << 8);
		IF (SavedLockFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 1 Lock fuses programmed successful.");	
		}
		! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedLockFuses[1]);
		SavedLockFuses1[1] = (SavedLockFuses[1] << 8);
		IF (SavedLockFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 2 Lock fuses programmed successful.");	
		}
		! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    SDR	 129	TDI(#0^129)
					TDO(SavedLockFuses[1]);
		SavedLockFuses1[1] = (SavedLockFuses[1] << 8);
		IF (SavedLockFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
		{
			print (0,"Row 3 Lock fuses programmed successful.");	
		}
	    TRY 1 {
		    ! Shift in LSCC READ STATUS(0x53) instruction;
		    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
			SDR_VERIFY	32	TDI(#1^32)
							TDO (0x00000010)
							MASK(0x00000017);
			print (0,"Key Lock fuses programmed successful.");
		}			
		ELSE
		{
			! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
		    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
		    SDR 32 TDI(0x00000000);
		    RUN_TEST IDLE TCK 5 DELAY PWP;
		    ! Shift in ISC DISABLE(0x1E) instruction;
	    	SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 5 DELAY 10;
			print (1,"Failed to program the Key Lock fuses.");
		}	
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
	}		
}
function SVF_PROGRAM_LOCK_FUSES
{
	datastream KeysFuses[1][165];
	KeysFuses[1] = 0x1000000000000000000000000000000000000000000;

	// Program the KEY_1 fuses		
	! Shift in KEY_1_PROGRAM(0xC0) instruction;
    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
    
    //Program the KEY_2 fuses
	! Shift in KEY_2_PROGRAM(0xC2) instruction;
    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
	
	// Program the KEY_3 fuses
	! Shift in KEY_3_PROGRAM(0xC3) instruction;
    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
    SDR	 165	TDI(KeysFuses[1]);
    RUN_TEST IDLE TCK 5 DELAY 3000;
    
    ! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    ! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    ! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    ! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR_VERIFY	32	TDI(#1^32)
					TDO (0x00000010)
					MASK(0x00000017);								
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY 1000;
}
function SVF_PROGRAM_LOCK_FUSES_ONLY
{
	datastream KeysFuses[1][165];
	KeysFuses[1] = 0x1000000000000000000000000000000000000000000;
	IF (KeyLock == 0x01)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x0004044D);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
	
		// Program the KEY_1 fuses		
		! Shift in KEY_1_PROGRAM(0xC0) instruction;
	    SIR Instruction_Length	TDI (KEY_1_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
	    
	    //Program the KEY_2 fuses
		! Shift in KEY_2_PROGRAM(0xC2) instruction;
	    SIR Instruction_Length	TDI (KEY_2_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
		
		// Program the KEY_3 fuses
		! Shift in KEY_3_PROGRAM(0xC3) instruction;
	    SIR Instruction_Length	TDI (KEY_3_PROGRAM);
	    SDR	 165	TDI(KeysFuses[1]);
	    RUN_TEST IDLE TCK 5 DELAY 3000;
	    
	    ! Shift in KEY_1_READ(0xC4) instruction;
	    SIR Instruction_Length	TDI (KEY_1_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_2_READ(0xC6) instruction;
	    SIR Instruction_Length	TDI (KEY_2_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in KEY_3_READ(0xC7) instruction;
	    SIR Instruction_Length	TDI (KEY_3_READ);
	    SDR	 1	TDI(0x00);
	    RUN_TEST IDLE TCK 5 DELAY 5;
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
						TDO (0x00000010)
						MASK(0x00000017);								
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(0x00000000);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
	}
}
function READ_KEYLOCK 
{
	datastream SavedKeysFuses[1][129];
	datastream SavedKeysFuses1[1][128];
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);	
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);				
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 1 Lock fuses are programmed.");
	}
	ELSE
	{
		print (0,"Row 1 Lock fuses are not programmed.");
	}
	
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);				
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 2 Lock fuses are programmed.");
	}
	ELSE
	{
		print (0,"Row 2 Lock fuses are not programmed.");
	}	
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKeysFuses[1]);
	SavedKeysFuses1[1] = (SavedKeysFuses[1] << 8);				
	IF (SavedKeysFuses1[1] == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
	{
		print (0,"Row 3 Lock fuses are programmed.");
	}
	ELSE
	{
		print (0,"Row 3 Lock fuses are not programmed.");
	}
	
	TRY 1 {
	    ! Shift in LSCC READ STATUS(0x53) instruction;
	    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
		SDR_VERIFY	32	TDI(#1^32)
						TDO (0x00000010)
						MASK(0x00000010);
		print (0,"Key Lock fuses are programmed.");
	}			
	ELSE
	{
		print (0,"Key Lock fuses are not programmed.");
			
	}
}
function SVF_READ_KEYLOCK 
{
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    ! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5V;
    ! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;    
	! Shift in LSCC READ STATUS(0x53) instruction;
    SIR Instruction_Length	TDI (LSCC_READ_STATUS);
	SDR_VERIFY	32	TDI(#1^32)
					TDO (0x00000010)
					MASK(0x00000000);
}
function READ_SECURITY_KEY 
{
	datastream Manufacturing[1][32];
	datastream SavedKEY2Fuse[1][129];
	datastream SavedKEY1Fuse[1][129];
	datastream SavedKEY3Fuse[1][129];
	
	datastream SavedKEY1Fuse1[1][128];
	datastream SavedKEY2Fuse1[1][128];
	datastream SavedKEY3Fuse1[1][128];
	
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
	
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY1Fuse[1]);	
	SavedKEY1Fuse1[1] = (SavedKEY1Fuse[1] << 8);
	SavedKEY1Fuse1[1] = $SavedKEY1Fuse1[1];
	IF (SavedKEY1Fuse1[1] == (#0^128))
	{
		print (0,"Row 1 fuses are not programmed.");
		print (0,SavedKEY1Fuse1);
	}
	ELSE
	{
		print (0,"Row 1 fuses are programmed.");
		print (0,SavedKEY1Fuse1);
	}	
    ! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY2Fuse[1]);
	SavedKEY2Fuse1[1] = (SavedKEY2Fuse[1] << 8);
	SavedKEY2Fuse1[1] = $SavedKEY2Fuse1[1];
	IF (SavedKEY2Fuse1[1] == (#0^128))
	{
		print (0,"Row 2 fuses are not programmed.");
		print (0,SavedKEY2Fuse1);
	}
	ELSE
	{
		print (0,"Row 2 fuses are programmed.");
		print (0,SavedKEY2Fuse1);
	}
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR	 129	TDI(#0^129)
				TDO(SavedKEY3Fuse[1]);
	SavedKEY3Fuse1[1] = (SavedKEY3Fuse[1] << 8);	
	SavedKEY3Fuse1[1] = $SavedKEY3Fuse1[1];			
	IF (SavedKEY3Fuse1[1] == (#0^128))
	{
		print (0,"Row 3 fuses are not programmed.");		
		print (0,SavedKEY3Fuse1);						
	}
	ELSE
	{
		print (0,"Row 3 fuses are programmed.");
		print (0,SavedKEY3Fuse1);
	}
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY PWP;
}
function SVF_READ_SECURITY_KEY 
{
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0004044D);
    RUN_TEST IDLE TCK 5 DELAY 1000;
    
	! Shift in KEY_2_READ(0xC6) instruction;
    SIR Instruction_Length	TDI (KEY_2_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129)
						MASK(#0^129);
	! Shift in KEY_1_READ(0xC4) instruction;
    SIR Instruction_Length	TDI (KEY_1_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129)
						MASK(#0^129);
	! Shift in KEY_3_READ(0xC7) instruction;
    SIR Instruction_Length	TDI (KEY_3_READ);
    SDR	 1	TDI(0x00);
    RUN_TEST IDLE TCK 5 DELAY 5;
    SDR_VERIFY	 129	TDI(#0^129)
						TDO(#0^129)
						MASK(#0^129);
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x00000000);
    RUN_TEST IDLE TCK 5 DELAY PWP;
}			

function SPI_INIT {
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	setpin ISPEN HIGH;
}
function SPI_READ_ID {
	setpin ISPEN LOW;
	! Shift in IDCODE(0x07) opcode;
    	SDR 	32	TDI (0xFFFFFFE0);
	SDR_VERIFY	32	TDI (0xFFFFFFFF)
				TDO	(IDTDI[1])
				MASK (0xFFFFFFFF);			
	setpin ISPEN HIGH;				        
}
function SPI_ENABLE {
	setpin ISPEN LOW;
	! Shift in REFRESH(0x71) opcode;
    SDR 32	TDI (0xFFFFFF8E);
    setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in WRITE ENABLE(0x4A) opcode;
    SDR 32 TDI (0xFFFFFF52);
    setpin ISPEN HIGH;
	
}
function SPI_DISABLE {
	setpin ISPEN LOW;
	! Shift in WRITE DISABLE(0x4F) opcode;
    SDR	32 	TDI (0xFFFFFFF2);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
}
function SPI_VERIFY_STATUS {
	setpin ISPEN LOW;
	! Shift in READ STATUS(0x09) opcode;
	SDR 32 TDI (0xFFFFFF90);
	SDR_VERIFY	32	TDI (#1^32)
					TDO (0x00020000)
					MASK(0x00020007);
	setpin ISPEN HIGH;				  	
}
function SPI_ERASE {
	setpin ISPEN LOW;	
	! Shift in CLEAR(0x70) opcode;
	SDR 32 TDI (0xFFFFFF0E);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 2000;		   
}
function SPI_PROGRAM {
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in WRITE_INC(0x41) opcode;
    SDR 32	TDI (0xFFFFFF82);
    ! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI[1]);
    setpin ISPEN HIGH;
	RUN_TEST TCK 256 DELAY 10;
}
function SPI_REFRESH {
	setpin ISPEN LOW;
	! Shift in REFRESH(0x71) opcode;
    SDR 32	TDI (0xFFFFFF8E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY 2000 ; 
}
function SPI_VERIFY_USERCODE {	
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in READ USERCODE(0x03) opcode;
	    SDR 32 TDI (0xFFFFFFC0);
	    SDR_VERIFY 	Usercode_Length TDI (#1^Usercode_Length)
									TDO	(Usercode_TDI);
		setpin ISPEN HIGH;									
	}
}
function SPI_VERIFY_DONE_BIT {
	setpin ISPEN LOW;
	! Shift in READ STATUS(0x09) opcode;
	SDR 32 TDI (0xFFFFFF90);
	SDR_VERIFY  8 TDI(0xFF)
			  TDO(0x02)
			  MASK(0x03);
	setpin ISPEN HIGH;
}
function SPI_VERIFY_CONTROL {
	IF (Control_Register_0_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in READ CONTROL (0x04) opcode;
	    SDR 32 TDI (0xFFFFFF20);
		SDR_VERIFY  32 TDI(0xFFFFFFFF)
				   	   TDO(Control_Register_0_TDI[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;
	}
}
function SPI_VERIFY {
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	setpin ISPEN LOW; 	
	! Shift in READ_INC (0x01) opcode;
	SDR 32 	TDI (0xFFFFFF80);
	repeat Address_Length {
		SDR 	12	TDI	(#1^12);
		SDR_VERIFY 	Row_Width	TDI	(#1^Row_Width)
								TDO	(FuseArray_TDI[RowCount])
								MASK(FuseArray_MASK[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;
	
}

function SPI_SAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	setpin ISPEN LOW; 
	! Shift in IDCODE(0x07) opcode;
    SDR 32 	TDI (0xFFFFFFE0);
	SDR	ID_Length	TDI (#1^ID_Length)
					TDO	(SavedID);
	setpin ISPEN HIGH;					
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SPI_SVFSAVE_ID	{
	setpin ISPEN LOW; 
	! Shift in IDCODE(0x07) opcode;
    SDR 32 	TDI (0xFFFFFFE0);
	SDR	ID_Length	TDI (#1^ID_Length)
					TDO	(#0^ID_Length)
					MASK(#0^ID_Length);
	setpin ISPEN HIGH;					
}

function SPI_SAVE_ARRAY {
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ_INC (0x01) opcode;
	SDR 32 	TDI (0xFFFFFF80);
	repeat Address_Length {
		SDR 	12	TDI	(#1^12);
		SDR 	Row_Width	TDI	(#1^Row_Width)
							TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SPI_SVFSAVE_ARRAY {
	setpin ISPEN LOW; 	
	! Shift in READ_INC (0x01) opcode;
	SDR 32 	TDI (0xFFFFFF80);
	repeat Address_Length {
		SDR 	12	TDI	(#1^12);
		SDR 	Row_Width	TDI	(#1^Row_Width)
							TDO	(#0^Row_Width)
							MASK(#0^Row_Width);
	}
	setpin ISPEN HIGH;
}

function SPI_SAVE_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0x03) opcode;
	SDR 32 TDI (0xFFFFFFC0);
	SDR	Usercode_Length	TDI(0xFFFFFFFF)
						TDO(SavedUsercode);
	setpin ISPEN HIGH;						
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPI_SVFSAVE_USERCODE {
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0x03) opcode;
	SDR 32 TDI (0xFFFFFFC0);
	SDR_VERIFY	Usercode_Length	TDI(#1^Usercode_Length)
								TDO(#1^Usercode_Length)
								MASK(#0^Usercode_Length);
	setpin ISPEN HIGH;						
}
function SPI_SAVE_CONTROL {
	datastream SavedControl[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in READ CONTROL (0x04) opcode;
    SDR 32 TDI (0xFFFFFF20);
	SDR  32 TDI(0xFFFFFFFF)
			TDO(SavedControl);
	setpin ISPEN HIGH;	  
	print (0,SavedControl);
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl);
	fclose 	NewFile;
}
function SPI_SVFSAVE_CONTROL 
{
	setpin ISPEN LOW;
	! Shift in READ CONTROL (0x04) opcode;
    SDR 32 TDI (0xFFFFFF20);
	SDR_VERIFY  32 TDI(0xFFFFFFFF)
				   TDO(0x00000000)
				   MASK(0x00000000);
	setpin ISPEN HIGH;	
}
function SPI_SAVE_STATUS {
	datastream SavedSTATUS[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ STATUS(0x09) opcode;
	SDR 32 TDI (0xFFFFFF90);
	SDR	32	TDI(#1^32)
			TDO(SavedSTATUS[1]);
	setpin ISPEN HIGH;	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;			  	
}
function SPI_SVFSAVE_STATUS {
	setpin ISPEN LOW;
	! Shift in READ STATUS(0x09) opcode;
	SDR 32 TDI (0xFFFFFF90);
	SDR_VERIFY  32 TDI(0xFFFFFFFF)
				  TDO(0x00000000)
				  MASK(0x00000000);
	setpin ISPEN HIGH;				  	
}
function SPI_PROGRAM_SPI0 {
	setpin ISPEN LOW;
	! Shift in PROGRAM_SPI0(0x74) opcode;
	SDR 32 TDI (0xFFFFFF2E);
	setpin ISPEN HIGH;
	
}
function SPI_PROGRAM_SPI1 {
	setpin ISPEN LOW;
	! Shift in PROGRAM_SPI1(0x75) opcode;
	SDR 32 TDI (0xFFFFFFAE);
	setpin ISPEN HIGH;
	
}
function REDUNDANT_SHIFT_TEST {
	! Shift in LSCC PROGRAM CONTROL 0(0x47) instruction;
    SIR Instruction_Length TDI (LSCC_PROGRAM_CTRL0);
	SDR 32 TDI(0x00800000);
	RUN_TEST IDLE TCK 5 DELAY PWP; 
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    SDR 32 TDI(0x0000024D);
    RUN_TEST IDLE TCK 5 DELAY PWP;
    ! Shift in READ_RED_REG(0xD9) instruction;
    SIR Instruction_Length	TDI (0xD9);
    SDR 160 TDI(0x0000000000000000000000000000000000000000);
    ! Shift in ISC DISABLE(0x1E) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 5 DELAY 200;
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 100 DELAY 1;
}
function PROGRAM_MANUFACTURING_REGISTER
{
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
	    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
	    SDR 32 TDI(Control_Register_0_TDI[1]);
	    RUN_TEST IDLE TCK 5 DELAY 1000;
	}
}
function READ_MANUFACTURING_REGISTER
{
	datastream Manufacturing[1][32];
	file	NewFile = "FILE_SAVE"; 
	! Shift in LSCC_MANUFACTURING_SHIFT(0x80) instruction;
    SIR Instruction_Length	TDI (LSCC_MANUFACTURING_SHIFT);
    RUN_TEST IDLE TCK 5 DELAY PWV;
    SDR 32 TDI(0x00000000)
    	   TDO(Manufacturing[1]);
    
    print (0,Manufacturing);
    
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, Manufacturing);
	fclose 	NewFile;
}
]]>
</Script>
</SVF_Plus>