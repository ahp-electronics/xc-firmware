<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		SVF_Plus	SYSTEM	"SVF_Plus.dtd" >

<SVF_Plus version="1.0">
<Header>
	<Device name="DEVICE_NAME"/>
</Header>
<Setup> <!-- use default Header, Trailer and Frequency value -->
	<Interface protocol="JTAG_1149.1"/>
</Setup>
<Parameter>
	<!-- Length fields are in number if bits -->
	<Instruction_Length value="INSTRUCTION_REGISTER_LENGTH"/> 
	<Row_Width			value="DEVICE_ROW_WIDTH"/> 
	<Address_Length		value="ADDRESS_REGISTER_LENGTH"/> 
	<Address length="ADDRESS_LENGTH">
		INI_ADDRESS			
	</Address>
	<ID_Length 			value="DEVICE_ID_LENGTH"/>
	<Usercode_Length 	value="DEVICE_USERCODE_LENGTH"/>
	<BSCAN_Length value="BSCAN_REGISTER_LENGTH"/> 
	<Bscan length="BSCAN_LENGTH">
		BSCAN_DATA
	</Bscan>
	<BscanMask length="BSCAN_LENGTH">
		BSCAN_MASK
	</BscanMask>
	<TotalFuse value="TOTAL_FUSE_MAP"/>
	<PWP	value="PROGRAMING_PULSE_WIDTH"/>
	<PWV	value="VERIFY_PULSE_WIDTH"/>
	<PWE	value="ERASE_PULSE_WIDTH"/>
	<MDRDelay value="MDR_DELAY"/>
	<Instruction>
		EXTEST	 			= 0x15;
		EXTEST_PULSE        = 0x2D;
		EXTEST_TRAIN        = 0x2E;
		INTEST              = 0x2C;
		CLAMP               = 0x78;
		HIGHZ               = 0x18;
		LSC_PRELOAD         = 0x1C;             
		LSC_SAMPLE          = 0x1C;									
		BYPASS              = 0xFF;
		IDCODE_PUB          = 0xE0;
		LSC_UIDCODE_PUB     = 0x19;
		USERCODE            = 0xC0;
		LSC_READ_TEMP       = 0xE8;
		LSC_DEVICE_CTRL     = 0x7D;
		LSC_READ_STATUS0    = 0x3C;
		LSC_READ_STATUS1    = 0x3D;
		LSC_CHECK_BUSY      = 0xF0;
		LSC_REFRESH         = 0x79;
		LSC_I2CI_CRBR_WT    = 0x9C;
		LSC_I2CI_TXDR_WT    = 0x9D;
		LSC_I2CI_RXDR_RD    = 0x9E;
		LSC_I2CI_SR_RD      = 0x9F;
		LSC_IP_A            = 0x32;
		LSC_IP_B            = 0x38;
		LSC_IPTEST_A        = 0x33;
		LSC_IPTEST_B        = 0x39;
		LSC_PROG_SPI        = 0x3A;
		LSC_PROG_SPI1       = 0x3E;
		LSC_IDCODE_PRV      = 0x16;
		LSC_READ_PES        = 0x11;
		LSC_MANUFACTURE_SHIFT = 0x90;
		ISC_ENABLE          = 0xC6;
		LSC_ENABLE_X        = 0x74;
		ISC_DISABLE         = 0x26;
		ISC_PROGRAM         = 0x67;
		ISC_NOOP            = 0x30;
		ISC_PROGRAM_USERCODE = 0xC2;
		ISC_READ            = 0x80;
		ISC_ERASE           = 0x0E;
		ISC_DISCHARGE       = 0x14;
		ISC_PROGRAM_DONE    = 0x5E;
		ISC_ERASE_DONE      = 0x24;
		ISC_PROGRAM_SECURITY = 0xCE;
		LSC_PROGRAM_SECPLUS = 0xCF;
		ISC_DATA_SHIFT      = 0x05;
		ISC_ADDRESS_SHIFT   = 0x42;
		LSC_INIT_ADDRESS    = 0x46;
		LSC_WRITE_ADDRESS   = 0xB4;
		LSC_PROG_INCR       = 0x82;
		LSC_PROG_INCR_ENC   = 0xB6;
		LSC_PROG_INCR_CMP   = 0xB8;
		LSC_PROG_INCR_CNE   = 0xBA;
		LSC_READ_INCR       = 0x6A;
		LSC_PROG_CTRL0      = 0x22;
		LSC_READ_CTRL0      = 0x20;
		LSC_RESET_CRC       = 0x3B;
		LSC_READ_CRC        = 0x60;
		LSC_PROG_SED_CRC    = 0xA2;
		LSC_READ_SED_CRC    = 0xA4;
		LSC_SHIFT_PASSWORD  = 0xBC;
		LSC_PROG_PASSWORD   = 0xF1;
		LSC_READ_PASSWORD   = 0xF2;
		LSC_PROG_FEATURE    = 0xE4;          
		LSC_READ_FEATURE    = 0xE7;      
		LSC_PROG_FEABITS    = 0xF8;
		LSC_READ_FEABITS    = 0xFB;
		LSC_WRITE_COMP_DIC  = 0x02;
		LSC_WRITE_BUS_ADDR  = 0xF6;
		LSC_PCS_WRITE       = 0x72;
		LSC_PCS_READ        = 0xF7;
		LSC_EBR_WRITE       = 0xB2;
		LSC_EBR_READ        = 0xB0;
		LSC_PROG_INCR_NV    = 0x70;
		LSC_READ_INCR_NV    = 0x73;
		LSC_INIT_ADDR_UFM   = 0x47;
		LSC_READ_TAG        = 0xCA;
		LSC_ERASE_UFM       = 0xCB;
		LSC_PROG_UFM        = 0xC9;
		LSC_READ_UFM        = 0xCA;
		LSC_STORE           = 0xD0;
		LSC_BITSTREAM_BURST = 0x7A;
		LSC_PROG_PES        = 0xD0;
		LSC_PROG_MES        = 0xD1;
		LSC_PROG_MAIN_RED   = 0xD3;
		LSC_PROG_MAIN_RCR   = 0xD4;
		LSC_PROG_MAIN_RMR   = 0xD5;
		LSC_PROG_NV_RED     = 0xD6;
		LSC_PROG_NV_RMR     = 0xD7;
		LSC_READ_TRIM       = 0xD1;
		LSC_READ_MAIN_RED   = 0xDA;
		LSC_READ_MAIN_RCR   = 0xDC;
		LSC_READ_MAIN_RMR   = 0xDC;
		LSC_READ_NV_RED     = 0xDD;
		LSC_READ_NV_RMR     = 0xDE;
		LSC_MFG_MTEST       = 0x96;
		LSC_MFG_MTRIM       = 0x69;
		LSC_MFG_MDATA       = 0x8F;
		LSC_ISCAN           = 0xDF;	
		LSC_PROG_CTRL1      = 0x23;
		LSC_READ_CTRL1		= 0x21;
		LSC_AUTH_CTRL		= 0x58;		
		LSC_PROGR_USEC		= 0x57;
		LSC_PROG_AES_FEA    = 0xF9;
		LSC_READ_AES_FEA    = 0xFA;
		LSC_PROG_CSEC       = 0x54;
		LSC_READ_CSEC       = 0X55;
		LSC_PROG_USEC       = 0x56;
		LSC_READ_USEC       = 0x57;
		LSC_PROG_AUTH_MODE  = 0xC4;
		LSC_PROG_ECDSA_PUBKEY0 = 0x59;
		LSC_PROG_ECDSA_PUBKEY1 = 0x5B;
		LSC_PROG_ECDSA_PUBKEY2 = 0x61;
		LSC_PROG_ECDSA_PUBKEY3 = 0x63;		
		LSC_READ_ECDSA_PUBKEY0 = 0x5A;
		LSC_READ_ECDSA_PUBKEY1 = 0x5C;
		LSC_READ_ECDSA_PUBKEY2 = 0x62;
		LSC_READ_ECDSA_PUBKEY3 = 0x64;		
		LSC_PROG_CIPHER_KEY0 = 0xF3;
		LSC_PROG_CIPHER_KEY1 = 0xFD;		
		LSC_READ_CIPHER_KEY0 = 0xF4;
		LSC_READ_CIPHER_KEY1 = 0xFE;
		USERCODE_DRYRUN      = 0xC1;
		LSC_PROGRAM_AUTH_DONE = 0xCC;	
		LSC_PROG_UDS		= 0xD8;	
	</Instruction>
</Parameter>
<Data>
	<DataField	name="IDTDI">
		<FieldBlock	row_width="DEVICE_ID_LENGTH">
			ID_DATA
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAM">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			MDR_BSCANPROGRAM
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAMMASK">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			MDR_BSCANPROGRAMMASK
		</FieldBlock>
	</DataField>
</Data>
<Operation_List>	
	"Disable Only" = "INIT 	! Initialize, 
					  DISABLE ! Exit the programming mode"	;
					  
	"Enable Only" = "INIT 	! Initialize, 
					READ_ID	! Check the IDCODE,
					SRAM_ENABLE	! Enable programming mode"	;
	
	"Re-Initialize" = "INIT 	! Initialize,  
					READ_ID	! Check the IDCODE,
					SRAM_ENABLE	! Enable programming mode, 
					SRAM_ERASE	! Erase the device, 
					DISABLE ! Exit the programming mode"	;
							 				
	"SRAM Fast Configuration" = "	INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password, 
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,									
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM	! Program Fuse Map,
										VERIFY_USERCODE		! Verify USERCODE,
										DISABLE ! Exit the programming mode,
										VERIFY_SRAM_DONE_BIT ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password,   
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,		
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										CHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SRAM_VERIFY	! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_CONTROL1_2	! Program Control1 Register,
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password, 
								CHECK_SRAM_READ_LOCK ! Check the SRAM lock,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password,  
								CHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
											 CHECK_PASSWORD ! Check the Password, 
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
											 CHECK_PASSWORD ! Check the Password, 
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SRAM_ENABLE,
									CHECK_PASSWORD ! Check the Password, 
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"INIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_PASSWORD ! Check the Password, 
									 CHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID, 
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure Plus" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_PASSWORD ! Check the Password,  
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"INIT 	! Initialize";	
	

	"Slave SPI SRAM Fast Configuration" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,  
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIBURST_PROGRAM	! Program Fuse Map,
										SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI SRAM Erase,Program,Verify" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIPROGRAM_CONTROL0	! Program Control Register0,
										SPIPROGRAM_CONTROL1	! Program Control Register1,
										SPISRAM_PROGRAM	! Program Fuse Map,
										SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SPISRAM_VERIFY	! Verify Fuse Map, 
										SPIVERIFY_USERCODE		! Verify USERCODE, 
										SPIPROGRAM_CONTROL1_2	! Program Control1 Register,
										SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,
										SPIDISABLE ! Exit the programming mode"	;									
										
	"Slave SPI SRAM Verify Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
							SPIVERIFY_CONTROL0 ! Verify Control Register0,
							SPIVERIFY_CONTROL1 ! Verify Control Register1,
							SPISRAM_VERIFY	! Verify Fuse Map, 
							SPIVERIFY_USERCODE		! Verify USERCODE, 
		 			 		SPIDISABLE ! Exit the programming mode"	;
							
	"Slave SPI SRAM Erase Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE,
							SPISRAM_ENABLE	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							SPISRAM_ERASE	! Erase the SRAM, 
		 			 		SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI SRAM Verify ID" = 	"SPIINIT 	! Initialize, 
						 			SPIREAD_ID ! Check the IDCODE"; 

	"Slave SPI SRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";

	"Slave SPI SRAM Program Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
								 SPIPROGRAM_CONTROL0 ! Program Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Display Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 SPICHECK_PASSWORD ! Check the Password,
					 			 SPISAVE_CONTROL0 !Read Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Program Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
					 			 SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             SPIDISABLE";

	"Slave SPI SRAM Display Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 SPICHECK_PASSWORD ! Check the Password,
					 			 SPISAVE_CONTROL1 !Read Control Register 1,
					             SPIDISABLE";	

	"Slave SPI SRAM Verify USERCODE"	=	"SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPIVERIFY_USERCODE		! Verify USERCODE,
											 SPIDISABLE"; 
								
	"Slave SPI SRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPISAVE_USERCODE,
											 SPIDISABLE";								
								
	"Slave SPI SRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPISAVE_USERCODE, 
										 SPIDISABLE";								
								
	"Slave SPI SRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID, 
								 			 SPISAVE_STATUS";									
								
	"Slave SPI SRAM Refresh" = "SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";								
	
	"Slave SPI SRAM Secure Plus" = "SPIINIT !Initialize,
							SPIREAD_ID !Check the IDCODE,
							SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 								             
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SPISRAM_SECURE ! Secure the SRAM,
							SPIDISABLE";
														
	"Slave SPI SRAM Bypass"	=	"SPIINIT 	! Initialize";	

					
	"I2C SRAM Fast Configuration" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C SRAM Erase,Program,Verify" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CCHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CPROGRAM_CONTROL0	! Program Control Register0,
										I2CPROGRAM_CONTROL1	! Program Control Register1,
										I2CSRAM_PROGRAM	! Program Fuse Map,
										I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
										I2CCHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										I2CSRAM_VERIFY	! Verify Fuse Map, 
										I2CVERIFY_USERCODE		! Verify USERCODE,
										I2CPROGRAM_CONTROL1_2 ! Program Control1 Register,
										I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"I2C SRAM Verify Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,  
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password,  
							I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
							I2CVERIFY_CONTROL0	! Verify Control Register0,
							I2CVERIFY_CONTROL1	! Verify Control Register1,
							I2CSRAM_VERIFY	! Verify Fuse Map, 
							I2CVERIFY_USERCODE		! Verify USERCODE, 
		 			 		I2CDISABLE ! Exit the programming mode"	;
							
	"I2C SRAM Erase Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CSRAM_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password, 
							I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							I2CSRAM_ERASE	! Erase the SRAM, 
		 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C SRAM Verify ID" = 	"I2CINIT 	! Initialize, 
						 	 I2CREAD_ID ! Check the IDCODE"; 

	"I2C SRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";

	"I2C SRAM Program Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
								 I2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Display Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
								 I2CCHECK_PASSWORD ! Check the Password, 
					 			 I2CSAVE_CONTROL0 !Read Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Program Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
								 I2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             I2CDISABLE";

	"I2C SRAM Display Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								 I2CCHECK_PASSWORD ! Check the Password, 
					 			 I2CSAVE_CONTROL1 !Read Control Register 1,
					             I2CDISABLE";	

	"I2C SRAM Verify USERCODE"	=	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_ENABLE,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE"	; 
								
	"I2C SRAM Display USERCODE"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID,
									 I2CSRAM_TRANSPARENT_READ_ENABLE,
									 I2CSAVE_USERCODE,
									 I2CDISABLE";								
								
	"I2C SRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password, 
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2CSAVE_USERCODE, 
									 I2CDISABLE";								
								
	"I2C SRAM Read Status Register" = "I2CINIT ! Initialize,
					 			 		I2CREAD_ID	! Check the IDCODE,
					 			 		I2CSAVE_ID,
					 			 		I2CSAVE_STATUS";									
								
	"I2C SRAM Refresh" = " 	I2CINIT !Initialize,
							I2CREAD_ID !Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh";								
	
	
	"I2C SRAM Secure Plus" = "I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						I2CCHECK_PASSWORD ! Check the Password,  
						I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						I2CSRAM_SECURE ! Secure the SRAM,
						I2CDISABLE";
														
	"I2C SRAM Bypass"	=	"I2CINIT 	! Initialize";	
	
	"SRAM External Primary Dry Run" =	"INIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										PRIMARY_DRYRUN";

	"Slave SPI SRAM External Primary Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Primary Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											I2CPRIMARY_DRYRUN"	;							

	"JTAGI2C SRAM External Primary Dry Run" =	"JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE,
												JTAGI2CPRIMARY_DRYRUN"	;	
											
	"SRAM External Golden Dry Run" =	"INIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										GOLDEN_DRYRUN"	;

	"Slave SPI SRAM External Golden Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Golden Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											I2CGOLDEN_DRYRUN"	;	

	"JTAGI2C SRAM External Golden Dry Run" =	"JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE,
												JTAGI2CGOLDEN_DRYRUN"	;	
											
	"JTAGI2C SRAM Fast Configuration" = "JTAGI2CINIT 	! Initialize,   
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
										JTAGI2CSRAM_ERASE	! Erase the SRAM, 
										JTAGI2CBURST_PROGRAM	! Program Fuse Map,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C SRAM Erase,Program,Verify" = "NOT_SUPPORTED"	;	
										
	"JTAGI2C SRAM Verify Only"	=	"NOT_SUPPORTED"	;
							
	"JTAGI2C SRAM Erase Only"	=	"	JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							JTAGI2CCHECK_PASSWORD ! Check the Password, 
							JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							JTAGI2CSRAM_ERASE	! Erase the SRAM, 
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C SRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
						 		 JTAGI2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C SRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";

	"JTAGI2C SRAM Program Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 JTAGI2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode,
								 JTAGI2CCHECK_PASSWORD ! Check the Password,  
					 			 JTAGI2CSAVE_CONTROL0 !Read Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Program Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             JTAGI2CDISABLE";

	"JTAGI2C SRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
								 JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSAVE_CONTROL1 !Read Control Register 1,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Verify USERCODE"	=	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_ENABLE,
									JTAGI2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
									JTAGI2CDISABLE"	; 
								
	"JTAGI2C SRAM Display USERCODE"	=	"JTAGI2CINIT, 
									 JTAGI2CREAD_ID, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CSRAM_ENABLE,
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE";								
								
	"JTAGI2C SRAM Read and Save"	=	"NOT_SUPPORTED";								
								
	"JTAGI2C SRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
					 			 		JTAGI2CREAD_ID	! Check the IDCODE,
					 			 		JTAGI2CSAVE_ID,
					 			 		JTAGI2CSAVE_STATUS";									
								
	"JTAGI2C SRAM Refresh" = " 	JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";								
	
	
	"JTAGI2C SRAM Secure Plus" = "JTAGI2CINIT !Initialize,
						JTAGI2CREAD_ID !Check the IDCODE,
						JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						JTAGI2CCHECK_PASSWORD ! Check the Password,  
						JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						JTAGI2CSRAM_SECURE ! Secure the SRAM,
						JTAGI2CDISABLE";
														
	"JTAGI2C SRAM Bypass"	=	"JTAGI2CINIT 	! Initialize";	
	
	
	"XSRAM SEI Fast Program" 	= "	INIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									CHECK_PASSWORD ! Check the Password,  
								 	CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;


	"XSRAM Verify ID" = 	"INIT 	! Initialize, 
								 READ_ID	! Check the IDCODE"	; 


	"XSRAM Display ID" = "INIT, READ_ID, SAVE_ID";	

	"XSRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 CHECK_PASSWORD ! Check the Password, 
								 			 SAVE_CONTROL0 ! Read Control Register 0,
								             DISABLE";	

	"XSRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,
											 CHECK_PASSWORD ! Check the Password,  
								 			 SAVE_CONTROL1 ! Read Control Register 1,
								             DISABLE";		

	"XSRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 SRAM_TRANSPARENT_READ_ENABLE, 
									 CHECK_PASSWORD ! Check the Password, 
									 CHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";			
	
	"XSRAM Display USERCODE"	=	"INIT, 
										 READ_ID, 
										 SAVE_ID,
										 SRAM_TRANSPARENT_READ_ENABLE,
										 SAVE_USERCODE,
										 DISABLE";
		
	"XSRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 SAVE_STATUS,
							 			 DISABLE ! Exit the programming mode";	

	"XSRAM Refresh" = "	INIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh" ;

	"XSRAM Bypass"	=	"	INIT 	! Initialize"	;
																	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;


	"Slave SPI XSRAM Verify ID" = 	"	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE"	; 


	"Slave SPI XSRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";	

	"Slave SPI XSRAM Display Control Register0" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL0 ! Read Control Register 0,
									             SPIDISABLE";	

	"Slave SPI XSRAM Display Control Register1" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL1 ! Read Control Register 1,
									             SPIDISABLE";		

	"Slave SPI XSRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,  
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPISAVE_USERCODE, 
										 SPIDISABLE";			
	
	"Slave SPI XSRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPISAVE_USERCODE,
											 SPIDISABLE";
		
	"Slave SPI XSRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID,
								 			 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
								 			 SPISAVE_STATUS,
								 			 SPIDISABLE ! Exit the programming mode";	

	"Slave SPI XSRAM Refresh" = "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPIREFRESH_FUNCTION ! Refresh" ;

	"Slave SPI XSRAM Bypass"	=	"	SPIINIT 	! Initialize"	;
	
	"I2C XSRAM SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;


	"I2C XSRAM Verify ID" = 	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE"	; 


	"I2C XSRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";	

	"I2C XSRAM Display Control Register0" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,
											 I2CCHECK_PASSWORD ! Check the Password,   
								 			 I2CSAVE_CONTROL0 ! Read Control Register 0,
								             I2CDISABLE";	

	"I2C XSRAM Display Control Register1" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 I2CCHECK_PASSWORD ! Check the Password,  
								 			 I2CSAVE_CONTROL1 ! Read Control Register 1,
								             I2CDISABLE";		

	"I2C XSRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password,  
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2CSAVE_USERCODE, 
									 I2CDISABLE";			
	
	"I2C XSRAM Display USERCODE"	=	"I2CINIT, 
										I2CREAD_ID, 
										I2CSAVE_ID,
										I2CSRAM_TRANSPARENT_READ_ENABLE,
										I2CSAVE_USERCODE,
										I2CDISABLE";
		
	"I2C XSRAM Read Status Register" = "I2CINIT ! Initialize,
							 			 I2CREAD_ID	! Check the IDCODE,
							 			 I2CSAVE_ID,
							 			 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 I2CSAVE_STATUS,
							 			 I2CDISABLE ! Exit the programming mode";	

	"I2C XSRAM Refresh" = "	I2CINIT 	! Initialize,   
							I2CREAD_ID	! Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh" ;

	"I2C XSRAM Bypass"	=	"	I2CINIT 	! Initialize"	;

	"JTAGI2C XSRAM SEI Fast Program" 	= "	JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;


	"JTAGI2C XSRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE"	; 


	"JTAGI2C XSRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";	

	"JTAGI2C XSRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
											 JTAGI2CCHECK_PASSWORD ! Check the Password,
								 			 JTAGI2CSAVE_CONTROL0 ! Read Control Register 0,
								             JTAGI2CDISABLE";	

	"JTAGI2C XSRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode,  
											 JTAGI2CCHECK_PASSWORD ! Check the Password,
								 			 JTAGI2CSAVE_CONTROL1 ! Read Control Register 1,
								             JTAGI2CDISABLE";		

	"JTAGI2C XSRAM Read and Save"	=	"NOT_SUPPORTED";			
	
	"JTAGI2C XSRAM Display USERCODE"	=	"JTAGI2CINIT, 
										JTAGI2CREAD_ID, 
										JTAGI2CSAVE_ID,
										JTAGI2CSRAM_TRANSPARENT_READ_ENABLE,
										JTAGI2CSAVE_USERCODE,
										JTAGI2CDISABLE";
		
	"JTAGI2C XSRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
							 			 JTAGI2CREAD_ID	! Check the IDCODE,
							 			 JTAGI2CSAVE_ID,
							 			 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 JTAGI2CSAVE_STATUS,
							 			 JTAGI2CDISABLE ! Exit the programming mode";	

	"JTAGI2C XSRAM Refresh" = "JTAGI2CINIT 	! Initialize,   
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh" ;

	"JTAGI2C XSRAM Bypass"	=	"JTAGI2CINIT 	! Initialize"	;
	
	"Program Feature Row" ="	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,										
									FLASH_ENABLE	! Enable the programming mode,    
									CHECK_ENABLE_PASSWORD ! Check the Password, 											 
									SELECT_FEA ! Select Feature sector,
									CHECK_ERASE_LOCK ! Check the Erase Locks,
									CHECK_PROG_LOCK ! Check the Program Locks,
									FEATURE_ERASE	! Erase the Feature,
									CHECK_STATUS ! Read the status bit,
									CHECK_READ_LOCK ! Check the Central Read Locks,
									FEATURE_PROGRAM ! Program Feature Rows,
									CHECK_STATUS ! Read the status bit,
									DISABLE ! Exit the programming mode"	;	
									
	"Update Feature Row" ="	INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,										
									FLASH_ENABLE	! Enable the programming mode,    
									CHECK_ENABLE_PASSWORD ! Check the Password, 											 
									SELECT_FEA ! Select Feature sector,
									CHECK_ERASE_LOCK ! Check the Erase Locks,
									CHECK_PROG_LOCK ! Check the Program Locks,
									FEATURE_ERASE	! Erase the Feature,
									CHECK_STATUS ! Read the status bit,
									CHECK_READ_LOCK ! Check the Central Read Locks,
									FEATURE_PROGRAM ! Program Feature Rows,
									CHECK_STATUS ! Read the status bit,
									DISABLE ! Exit the programming mode"	;

	"Program Feature Row Secure" ="	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_FEA ! Select Feature sector,
										CHECK_ERASE_LOCK ! Check the Erase Locks,
										CHECK_PROG_LOCK ! Check the Program Locks,									
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
					 					CHECK_READ_LOCK ! Check the Central Read Locks,
										FEATURE_PROGRAM ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										PROGRAM_LOCK ! Program the local lock policy,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
										
	"Program Feature Row Lock" ="	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,
										CHECK_PROG_LOCK ! Check the Locks,										
										PROGRAM_LOCK ! Program the lock information,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
																															
	"Erase Feature Row" ="	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the programming mode,
								CHECK_ENABLE_PASSWORD ! Check the Password, 									
								SELECT_FEA ! Select Feature sector,									
								CHECK_ERASE_LOCK ! Check the Locks,	
								FEATURE_ERASE	! Erase the Feature row, 
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;

	"Read Feature Row" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_ENABLE	! Enable the programming mode,	
									CHECK_ENABLE_PASSWORD ! Check the Password, 								
									SELECT_FEA ! Select Feature sector,	
									CHECK_READ_LOCK ! Check the Locks,														
									FEATURE_ROW_READ	! Read the Feature row, 
									DISABLE ! Exit the programming mode"	;
	
	"Program Control NV Register1" ="	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,										
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,		
										CHECK_READ_LOCK ! Check the Locks,	
										CHECK_PROG_LOCK ! Check the Locks,	
										CHECK_ERASE_LOCK ! Check the Locks,
										PROGRAM_CONTROL_NV1 ! Program Control Register1,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
	
	"Display Control NV Register1" ="	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SELECT_FEA ! Select Feature sector,		
										CHECK_READ_LOCK ! Check the Locks,
										SAVE_CONTROLNV1 ! Read Control Register1,
										DISABLE ! Exit the programming mode"	;		

	"Slave SPI Program Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,		
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	"Slave SPI Update Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,		
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;										

	"Slave SPI Program Feature Row Secure" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,									
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIPROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	"Slave SPI Program Feature Row Lock" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPIPROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;										

	"Slave SPI Erase Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 								
										SPISELECT_FEA ! Select Feature sector,	 											
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SPIFEATURE_ERASE	! Erase the Feature row,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI Read Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 
									    SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the key lock information,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Program Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,	
										SPICHECK_PROG_LOCK ! Check the Locks,	
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SPIPROGRAM_CONTROL_NV1 ! Program Control Register1,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI Display Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,
										SPISAVE_CONTROLNV1 ! Read Control Register1,
										SPIDISABLE ! Exit the programming mode"	;		

	"I2C Program Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,		
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;	

	"I2C Update Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,		
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;

	"I2C Program Feature Row Secure" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CPROGRAM_NEW_ADDRESS_LOCK ! Program the local lock policy,
										I2CFEATUREDISABLE ! Exit the programming mode"	;
										
	"I2C Program Feature Row Lock" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										I2CPROGRAM_LOCK ! Program the local lock policy,
										I2CCHECK_STATUS ! Read the status bit,
										I2CDISABLE ! Exit the programming mode"	;										

	"I2C Erase Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										I2CSELECT_FEA ! Select Feature sector,	 											
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										I2CFEATURE_ERASE	! Erase the Feature row,
										I2CDISABLE_DEFAULT ! Exit the programming mode"	;

	"I2C Read Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 
									    I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the key lock information,
										I2CFEATURE_ROW_READ	! Read the Feature row, 
										I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Program Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,	
										I2CCHECK_PROG_LOCK ! Check the Locks,	
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										I2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
										I2CCHECK_STATUS ! Read the status bit,
										I2CDISABLE ! Exit the programming mode"	;	
	
	"I2C Display Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
										I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,
										I2CSAVE_CONTROLNV1 ! Read Control Register1,
										I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C Program Feature Row" ="	JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,										
										JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
										JTAGI2CSELECT_FEA ! Select Feature sector,		
										JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature,
										JTAGI2CCHECK_STATUS ! Read the status bit,	
										JTAGI2CCHECK_READ_LOCK ! Check the Program Locks,
										JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
										JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
										JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;

	"JTAGI2C Update Feature Row" ="	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,										
									JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
									JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
									JTAGI2CSELECT_FEA ! Select Feature sector,		
									JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
									JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
									JTAGI2CFEATURE_ERASE	! Erase the Feature,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CCHECK_READ_LOCK ! Check the Program Locks,
									JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
									JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
									JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C Program Feature Row Lock" ="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode,
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,										
											JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;										

	"JTAGI2C Erase Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										JTAGI2CSELECT_FEA ! Select Feature sector,	 											
										JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature row,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Read Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 
										JTAGI2CSELECT_FEA ! Select Feature sector,
										JTAGI2CCHECK_READ_LOCK ! Check the key lock information,
										JTAGI2CFEATURE_ROW_READ	! Read the Feature row, 
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,										
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,	
											JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C Display Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,
											JTAGI2CSAVE_CONTROLNV1 ! Read Control Register1,
											JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"Security Program Auth Done FlashA" =   "INIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash, 										  
											  SELECT_CFG0 ! Select Flash A,
											  PROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashA" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash, 										  
											  SPISELECT_CFG0 ! Select Flash A,
											  SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;

	"I2C Security Program Auth Done FlashA" =   "I2CINIT 	! Initialize, 
												  I2CREAD_ID	! Check the IDCODE, 
												  I2CFLASH_ENABLE	! Enable the Flash,  											  
												  I2CSELECT_CFG0 ! Select Flash A,
												  I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
												  I2CDISABLE ! Exit the programming mode" ;
											  											  
	"JTAGI2C Security Program Auth Done FlashA" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  											  
													  JTAGI2CSELECT_CFG0 ! Select Flash A,
													  JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;	
																						  
	"Security Program Auth Done FlashB" =   "INIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash, 
											  SELECT_CFG1 ! Select Flash B,
											  PROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashB" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash, 
											  SPISELECT_CFG1 ! Select Flash B,
											  SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Auth Done FlashB" =   "I2CINIT 	! Initialize, 
											  I2CREAD_ID	! Check the IDCODE, 
											  I2CFLASH_ENABLE	! Enable the Flash,  	 
											  I2CSELECT_CFG1 ! Select Flash B,
											  I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Program Auth Done FlashB" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	 
													  JTAGI2CSELECT_CFG1 ! Select Flash B,
													  JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;												  

	"Security Read Password Key" =  "INIT 	! Initialize, 
									 READ_ID	! Check the IDCODE,									 
									 FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									 CHECK_ENABLE_PASSWORD ! Check the Password, 
									 SELECT_FEA ! Select Feature Sector,
									 CHECK_READ_LOCK ! Check the Locks,										   
									 READ_PASSWORD ! Read the Password key,
									 DISABLE ! Exit the programming mode" ;
										   									
	"Security Program Password Key" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,  
								  SELECT_FEA ! Select Feature Sector,
								  CHECK_PROG_LOCK ! Check the Locks,						
								  PROGRAM_PASSWORD ! Program the Password key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Password Key Secure" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks,
								  PROGRAM_PASSWORD ! Program the Password key, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  CHECK_STATUS ! Read the status bit,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Password Key Lock" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;

	"Security Read Encryption Key" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,									 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Locks,
								  READ_AESKEY ! Read the Encryption key,         
								  DISABLE ! Exit the programming mode" ;
	
	"Security Erase Encryption Key" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  DISABLE ! Exit the programming mode" ;
								  
	"Security Program Encryption Key" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_AESKEY ! Program the Encryption key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Encryption Key Secure" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_AESKEY ! Program the Encryption key, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key Lock" ="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_AESKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;	

	"Slave SPI Security Read Password Key" =  "SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,									 
											 SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
											 SPICHECK_ENABLE_PASSWORD ! Check the Password, 
											 SPISELECT_FEA ! Select Feature Sector,
											 SPICHECK_READ_LOCK ! Check the Locks,										   
											 SPIREAD_PASSWORD ! Read the Password key,
											 SPIDISABLE ! Exit the programming mode" ;
									 
	"Slave SPI Security Program Password Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPISELECT_FEA ! Select Feature Sector,
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_PASSWORD ! Program the Password key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Password Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_PASSWORD ! Program the Password key, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Password Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Erase Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SPIAESKEY_ERASE ! Erase AESKEY Sector,
								  SPIDISABLE ! Exit the programming mode" ;
								  
	"Slave SPI Security Read Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,									 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Locks,
								  SPIREAD_AESKEY ! Read the Encryption key,         
								  SPIDISABLE ! Exit the programming mode" ;
								  
	"Slave SPI Security Program Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_AESKEY ! Program the Encryption key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Encryption Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector, 	
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_AESKEY ! Program the Encryption key, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Encryption Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
	
	"I2C Security Read Password Key" =  "I2CINIT 	! Initialize, 
									 I2CREAD_ID	! Check the IDCODE,									 
									 I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 										
									 I2CCHECK_ENABLE_PASSWORD ! Check the Password, 
									 I2CSELECT_FEA ! Select Feature Sector,	
									 I2CCHECK_READ_LOCK ! Check the Locks,									   
									 I2CREAD_PASSWORD ! Read the Password key,
									 I2CDISABLE ! Exit the programming mode" ;
									 
	"I2C Security Program Password Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,  	
								  I2CSELECT_FEA ! Select Feature Sector,
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key,        
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Password Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 	 
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Password Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Erase Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,  
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  I2CAESKEY_ERASE ! Erase AESKEY Sector,
								  I2CDISABLE ! Exit the programming mode" ;
								  
	"I2C Security Read Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,									 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,  
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Locks,
								  I2CREAD_AESKEY ! Read the Encryption key,         
								  I2CDISABLE ! Exit the programming mode" ;
								  
	"I2C Security Program Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_AESKEY ! Program the Encryption key,         
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Encryption Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 	
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_AESKEY ! Program the Encryption key, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Encryption Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Read Password Key" =  "JTAGI2CINIT 	! Initialize, 
											 JTAGI2CREAD_ID	! Check the IDCODE,									 
											 JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode, 										
											 JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 
											 JTAGI2CSELECT_FEA ! Select Feature Sector,	
											 JTAGI2CCHECK_READ_LOCK ! Check the Locks,									   
											 JTAGI2CREAD_PASSWORD ! Read the Password key,
											 JTAGI2CDISABLE ! Exit the programming mode" ;
										 
	"JTAGI2C Security Program Password Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	
											  JTAGI2CSELECT_FEA ! Select Feature Sector,
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											  JTAGI2CPROGRAM_PASSWORD ! Program the Password key,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash, 	 
													  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
													  JTAGI2CPROGRAM_PASSWORD ! Program the Password key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Lock" ="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
												  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Erase Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CAESKEY_ERASE ! Erase AESKEY Sector,
											  JTAGI2CDISABLE ! Exit the programming mode" ;
								  
	"JTAGI2C Security Read Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,									 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_READ_LOCK ! Check the Locks,
											  JTAGI2CREAD_AESKEY ! Read the Encryption key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;
								  
	"JTAGI2C Security Program Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
											  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Encryption Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 	
													  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
													  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
													  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
													  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Encryption Key Lock" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;		
								  
	"Security Read Public Key" =	"INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,	 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Locks,
								  READ_PUBKEY ! Read the Public key,         
								  DISABLE ! Exit the programming mode" ;
	
	"Security Erase Public Key" =	"INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable PROGRAM mode,	 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,        
								  DISABLE ! Exit the programming mode" ;
								  
	"Security Program Public Key" =	"INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_PUBKEY ! Program the Public key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Public Key Secure"="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_PUBKEY ! Program the Public key, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  
	"Security Program Public Key Lock"="INIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  								  
	
	"Slave SPI Security Read Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,	 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Locks,
								  SPIREAD_PUBKEY ! Read the Public key,         
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Erase Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable PROGRAM mode,	 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SPIPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  SPIDISABLE ! Exit the programming mode" ;
								  
	"Slave SPI Security Program Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_PUBKEY ! Program the Public key,         
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Public Key Secure"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 	
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_PUBKEY ! Program the Public key, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Public Key Lock"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPIPROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
								  
	"I2C Security Read Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,	 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Locks,
								  I2CREAD_PUBKEY ! Read the Public key,         
								  I2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Erase Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable PROGRAM mode,	 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  I2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  I2CDISABLE ! Exit the programming mode" ;
								  								  
	"I2C Security Program Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_PUBKEY ! Program the Public key,         
								  I2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Public Key Secure"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_PUBKEY ! Program the Public key, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Public Key Lock"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CPROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;									  

	"JTAGI2C Security Read Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,	 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_READ_LOCK ! Check the Locks,
											  JTAGI2CREAD_PUBKEY ! Read the Public key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;
		
	"JTAGI2C Security Erase Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable PROGRAM mode,	 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;
																  
	"JTAGI2C Security Program Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
											  JTAGI2CPROGRAM_PUBKEY ! Program the Public key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Public Key Secure"="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 
												  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
												  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
												  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
												  JTAGI2CPROGRAM_PUBKEY ! Program the Public key, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Public Key Lock"="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
											  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											  JTAGI2CDISABLE ! Exit the programming mode" ;	
								  
	"Security Program TraceID"="	INIT 	! Initialize, 
							    READ_ID	! Check the IDCODE,
							    FLASH_ENABLE	! Enable the programming mode,
							    CHECK_ENABLE_PASSWORD ! Check the Password, 
							    SELECT_FEA ! Select Feature Sector, 								  
							    CHECK_PROG_LOCK ! Check the Locks,
							    PROGRAM_TRACEID ! Program the TraceID,
							    DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program TraceID"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIFLASH_ENABLE	! Enable the programming mode,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password, 
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_TRACEID ! Program the TraceID,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program TraceID"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CFLASH_ENABLE	! Enable the programming mode,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_TRACEID ! Program the TraceID,
								  I2CDISABLE ! Exit the programming mode" ;
								  							  
	"JTAGI2C Security Program TraceID"="JTAGI2CINIT 	! Initialize, 
									  JTAGI2CREAD_ID	! Check the IDCODE,
									  JTAGI2CFLASH_ENABLE	! Enable the programming mode,
									  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
									  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
									  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
									  JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
									  JTAGI2CDISABLE ! Exit the programming mode" ;	
															  
	"Security Program Authentication Mode"="	INIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID, 
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_PUBKEY ! Select PUBKEY Sector, 								  
										CHECK_PROG_LOCK ! Check the Locks,
										PROGRAM_AUTHENTICATION ! Program Authentication Mode,                             
										DISABLE ! Exit the programming mode"	;
										
	"Slave SPI Security Program Authentication Mode"="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID, 
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_PUBKEY ! Select PUBKEY Sector, 								  
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPIPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Security Program Authentication Mode"="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID, 
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_PUBKEY ! Select Feature Sector, 								  
										I2CCHECK_PROG_LOCK ! Check the Locks,
										I2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Security Program Authentication Mode"="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CSAVE_ID, 
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_PUBKEY ! Select Feature Sector, 								  
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
											JTAGI2CDISABLE ! Exit the programming mode"	;
	"FLASH Version Rollback Protection" ="INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD	! Check PASSWORD, 
										FLASHA_PROGRAM,
										SELECT_CFG0 ! Select Flash A,
										PROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										FLASHB_PROGRAM,	
										SELECT_CFG1 ! Select Flash B,
										PROGRAM_AUTH_DONE_B ! Program the Auth Done, 									
										DISABLE ! Exit the programming mode,
										VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit,
										SRAM_DISPLAY_USERCODE";
										
	"Slave SPI FLASH Version Rollback Protection" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPISELECT_CFG0 ! Select Flash A,
											SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											SPIFLASHB_PROGRAM,	
											SPISELECT_CFG1 ! Select Flash B,
											SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,												
											SPIDISABLE ! Exit the programming mode,
											SPISRAM_DISPLAY_USERCODE"	;

	"I2C FLASH Version Rollback Protection" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										I2CFLASHA_PROGRAM,
										I2CSELECT_CFG0 ! Select Flash A,
										I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										I2CFLASHB_PROGRAM,	
										I2CSELECT_CFG1 ! Select Flash B,
										I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
										I2CDISABLE ! Exit the programming mode,
										I2CSRAM_DISPLAY_USERCODE"	;																							

	"JTAGI2C FLASH Version Rollback Protection" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CSELECT_CFG0 ! Select Flash A,
											JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											JTAGI2CFLASHB_PROGRAM,
											JTAGI2CSELECT_CFG1 ! Select Flash B,
											JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
											JTAGI2CDISABLE ! Exit the programming mode,
											JTAGI2CSRAM_DISPLAY_USERCODE"	;	
											
	"FLASH Erase,Program,Verify" ="INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD	! Check PASSWORD, 
										FLASHA_PROGRAM,
										FLASHB_PROGRAM,										
										DISABLE ! Exit the programming mode,
										VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";										
												
	"Slave SPI FLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,													
											SPIDISABLE ! Exit the programming mode"	;

	"I2C FLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;																							

	"JTAGI2C FLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH CFG Erase,Program,Verify" ="INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_PASSWORD ! Check PASSWORD,  
												FLASHA_CFG_PROGRAM,
												FLASHB_CFG_PROGRAM,											
												DISABLE ! Exit the programming mode";
													
	"Slave SPI FLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPIFLASHB_CFG_PROGRAM,													
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C FLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											I2CFLASHA_CFG_PROGRAM,
											I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;
																							
	"JTAGI2C FLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;																								
	
	"FLASH UFM Erase,Program,Verify" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												UFM_PROGRAM_VERIFY,
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI FLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C FLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"FLASH Erase,Program,Verify,Secure" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_PASSWORD ! Check PASSWORD, 
												FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0,
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												FLASHB_PROGRAM,	
												SELECT_UFM1 ! Select UFM1,																																					
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,												
												DISABLE ! Exit the programming mode,
												VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
																									
	
	"Slave SPI FLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,
													SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SPIFLASHB_PROGRAM,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,														
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID ! Check the IDCODE, 
												I2CFLASH_ENABLE	! Enable the Flash,
												I2CCHECK_PASSWORD ! Check PASSWORD,  
												I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												I2CFLASHB_PROGRAM,	
												I2CSELECT_UFM1 ! Select UFM1,																																					
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																					
												I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,	
													JTAGI2CSELECT_UFM1	! Select UFM1,																																					
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													JTAGI2CSELECT_CFG1 ! Select CFG1,	
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																			
													JTAGI2CDISABLE ! Exit the programming mode"	;												
																							
	"FLASH CFG Erase,Program,Verify,Secure" ="INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_PASSWORD ! Check PASSWORD,  
													FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	
																							
	"JTAGI2C FLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;
																							
	"FLASH UFM Erase,Program,Verify,Secure" ="INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													UFM_PROGRAM_VERIFY,
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,	
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													I2CUFM_PROGRAM_VERIFY,	
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													 										
													I2CDISABLE ! Exit the programming mode"	;													

	"JTAGI2C FLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,	
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													 										
														JTAGI2CDISABLE ! Exit the programming mode"	;	
													
	"FLASH Recovery Erase Only" =	"INIT 	! Initialize, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE_READ_ID	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,
									FLASHA_ERASE,
									FLASHB_ERASE,
									FLASHC_ERASE,								
									DISABLE ! Exit the programming mode"	;	
									
	"FLASH Erase Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_ERASE,
								FLASHB_ERASE,
								FLASHC_ERASE,								
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI Recovery Erase Only"	=	"SPIINIT 	! Initialize, 
									SPIFLASH_ENABLE_READ_ID	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password, 
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
				 			 		
	"Slave SPI FLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password, 
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password, 
									I2CFLASHA_ERASE,
									I2CFLASHB_ERASE,
									I2CFLASHC_ERASE,
				 			 		I2CDISABLE ! Exit the programming mode"	;
				 			 		
	"I2C FLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password,
								I2CFLASHA_ERASE,
								I2CFLASHB_ERASE,
								I2CFLASHC_ERASE,								
								I2CDISABLE ! Exit the programming mode"	;					

	"JTAGI2C FLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_PASSWORD ! Check the Password,
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,								
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Erase Only" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_PASSWORD ! Check the Password,  
									FLASHACFG_ERASE,
									FLASHBCFG_ERASE,
									DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHACFG_ERASE,
									SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHACFG_ERASE,
								I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"FLASH UFM Erase Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_UFM_PASSWORD ! Check the Password,  
								FLASHAUFM_ERASE,
								FLASHBUFM_ERASE,
								FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SPIFLASHAUFM_ERASE,
									SPIFLASHBUFM_ERASE,
									SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								I2CFLASHAUFM_ERASE,
								I2CFLASHBUFM_ERASE,
								I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"FLASH Verify Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_PASSWORD ! Check the Password,
								FLASHA_VERIFY,
								FLASHB_VERIFY,
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password,
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_ENABLE	! Enable the Flash, 
								I2CCHECK_PASSWORD ! Check the Password, 
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,
								I2CDISABLE ! Exit the programming mode"	;																															

	"JTAGI2C FLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Verify Only" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C FLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH UFM Verify Only" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_UFM_PASSWORD ! Check the Password,  							
									SPIUFM_VERIFY_ONLY,
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,
									I2CDISABLE ! Exit the programming mode"	;						

	"JTAGI2C FLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
									
	"FLASH Read and Save" =	"INIT ! Initialize,
									 READ_ID ! Check the IDCODE,
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 FLASH_ENABLE ! Enable the Flash,
									 CHECK_PASSWORD ! Check the Password,
									 FLASHA_SAVE,
									 FLASHB_SAVE,
									 FLASHC_SAVE,									 
									 DISABLE ! Exit the programming mode";
											 																								
	"Slave SPI FLASH Read and Save" =	"SPIINIT ! Initialize,
										 SPIREAD_ID ! Check the IDCODE,
										 SPISAVE_ID, 
										 SPIFLASH_ENABLE ! Enable the Flash,
										 SPICHECK_PASSWORD ! Check the Password,
										 SPIFLASHA_SAVE,
									 	 SPIFLASHB_SAVE,
									 	 SPIFLASHC_SAVE,
										 SPIDISABLE ! Exit the programming mode";
	
	"I2C FLASH Read and Save" =	"I2CINIT ! Initialize,
								 I2CREAD_ID ! Check the IDCODE,
								 I2CSAVE_ID, 
								 I2CFLASH_ENABLE ! Enable the Flash,
								 I2CCHECK_PASSWORD ! Check the Password, 
								 I2CFLASHA_SAVE,
								 I2CFLASHB_SAVE,
								 I2CFLASHC_SAVE,
								 I2CDISABLE ! Exit the programming mode";											 										 					 										 

	"JTAGI2C FLASH Read and Save" =	"JTAGI2CINIT ! Initialize,
									 JTAGI2CREAD_ID ! Check the IDCODE,
									 JTAGI2CSAVE_ID, 
									 JTAGI2CFLASH_ENABLE ! Enable the Flash,
									 JTAGI2CCHECK_PASSWORD ! Check the Password, 
									 JTAGI2CFLASHA_SAVE,
									 JTAGI2CFLASHB_SAVE,
									 JTAGI2CFLASHC_SAVE,
									 JTAGI2CDISABLE ! Exit the programming mode";
								 
	"FLASH Bypass" ="INIT 	! Initialize"; 
								
	"Slave SPI FLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C FLASH Bypass" =	"I2CINIT 	! Initialize"; 
	
	"JTAGI2C FLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="INIT 	! Initialize"; 
															 	
	"FLASH Verify ID" ="INIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI FLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C FLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 																

	"JTAGI2C FLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
								 JTAGI2CREAD_ID ! Check the IDCODE"; 							 
							 
	"FLASH Display ID" =	"INIT, SAVE_ID";
	
	"Slave SPI FLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C FLASH Display ID" =	"I2CINIT, I2CSAVE_ID";	
	
	"JTAGI2C FLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";

	"FLASH Verify USERCODE" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									FLASH_ENABLE	! Enable the Flash access, 
									CHECK_PASSWORD ! Check PASSWORD, 
									SELECT_CFG0	! Select CFG0,
									CFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
									SELECT_CFG1	! Select CFG1 Sector,
									CFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
									DISABLE ! Exit the programming mode";
	
	"Slave SPI FLASH Verify USERCODE" =	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the Flash access, 
										SPICHECK_PASSWORD ! Check PASSWORD, 
										SPISELECT_CFG0	! Select CFG0,
										SPICFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
										SPISELECT_CFG1	! Select CFG1,
										SPICFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
																				

	"I2C FLASH Verify USERCODE" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CFLASH_ENABLE	! Enable the Flash access,
									I2CCHECK_PASSWORD ! Check PASSWORD, 									
									I2CSELECT_CFG0	! Select CFG0,
									I2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
									I2CSELECT_CFG1	! Select CFG1,
									I2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH Verify USERCODE" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access,
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 									
										JTAGI2CSELECT_CFG0	! Select CFG0,
										JTAGI2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;																				
	
	"FLASH Read Status Register" =	"INIT ! Initialize,
												 READ_ID	! Check the IDCODE,
												 SAVE_ID,
												 FLASH_ENABLE,
												 SAVE_STATUS,
												 DISABLE";
	
	"Slave SPI FLASH Read Status Register" =	"SPIINIT ! Initialize,
													 SPIREAD_ID	! Check the IDCODE,
													 SPISAVE_ID,
													 SPIFLASH_ENABLE,
													 SPISAVE_STATUS,
													 SPIDISABLE";
	
	"I2C FLASH Read Status Register" =	"I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CFLASH_ENABLE,
											 I2CSAVE_STATUS,
											 I2CDISABLE";		
										
	"JTAGI2C FLASH Read Status Register" =	"JTAGI2CINIT ! Initialize,
												 JTAGI2CREAD_ID	! Check the IDCODE,
												 JTAGI2CSAVE_ID,
												 JTAGI2CFLASH_ENABLE,
												 JTAGI2CSAVE_STATUS,
												 JTAGI2CDISABLE";											 												 	
	
	"FLASH Refresh" =" INIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI FLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C FLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C FLASH Refresh" ="JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";												
	
	"Security Lock Ports Interface" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Lock Ports Interface" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Lock Ports Interface" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C Security Lock Ports Interface" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
										JTAGI2CDISABLE	! Exit the programming mode";
									
	"FLASH Secure CFG Plus" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
	
	"FLASH Update CFG Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Update CFG Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Update CFG Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Update CFG Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																											
	"FLASH Secure UFM Plus" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
	
	"FLASH Update UFM Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Update UFM Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Update UFM Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Update UFM Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
										
	"FLASH Read CFG Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									SAVE_ID,
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_READ_LOCK ! Check LOCK information,
									CFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Read CFG Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPISAVE_ID,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPICFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Read CFG Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CSAVE_ID,
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Read CFG Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,
										JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
										JTAGI2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
										JTAGI2CDISABLE	! Exit the programming mode";
	
	"FLASH Read UFM Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									SAVE_ID,
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_READ_LOCK ! Check LOCK information,
									UFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Read UFM Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPISAVE_ID,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPIUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Read UFM Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CSAVE_ID,
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Read UFM Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
										JTAGI2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																																																																																						 												 												 																																																																																																																																																																																																																																											
	"XFLASH Erase,Program,Verify" ="INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										FLASHA_PROGRAM,
										FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode";										
												
	"Slave SPI XFLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C XFLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;																						

	"XFLASH CFG Erase,Program,Verify" ="INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD,  
												FLASHA_CFG_PROGRAM,
												FLASHB_CFG_PROGRAM,										
												DISABLE ! Exit the programming mode";
													
	"Slave SPI XFLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPIFLASHB_CFG_PROGRAM,														
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											I2CFLASHA_CFG_PROGRAM,
											I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C XFLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;
																																														
	"XFLASH UFM Erase,Program,Verify" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												UFM_PROGRAM_VERIFY,																 																	
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI XFLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C XFLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;	
												
	"JTAGI2C XFLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;												
																																			
	"XFLASH Erase,Program,Verify,Secure" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD, 
												FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0,
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												FLASHB_PROGRAM,	
												SELECT_UFM1 ! Select UFM1,																																					
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,													
												DISABLE ! Exit the programming mode";
																									
	"Slave SPI XFLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SPIFLASHB_PROGRAM,	
													SPISELECT_UFM1 ! Select UFM1,																																						
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												I2CCHECK_PASSWORD ! Check PASSWORD, 
												I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												I2CFLASHB_PROGRAM,				
												I2CSELECT_UFM1 ! Select UFM1,																																			
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
												I2CDISABLE ! Exit the programming mode"	;
												
	"JTAGI2C XFLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,				
													JTAGI2CSELECT_UFM1 ! Select UFM1,																																			
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													JTAGI2CSELECT_CFG1 ! Select CFG1,
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
													JTAGI2CDISABLE ! Exit the programming mode"	;		
																								
	"XFLASH CFG Erase,Program,Verify,Secure" ="INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_PASSWORD ! Check PASSWORD,  
													FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,			
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	
													
	"JTAGI2C XFLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;
																								
	"XFLASH UFM Erase,Program,Verify,Secure" ="INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													UFM_PROGRAM_VERIFY,	
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																												
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													I2CUFM_PROGRAM_VERIFY,																												
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
													I2CDISABLE ! Exit the programming mode"	;	
														
	"JTAGI2C XFLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,																												
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
														JTAGI2CDISABLE ! Exit the programming mode"	;
																								
	"XFLASH Erase Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_ERASE,
								FLASHB_ERASE,
								FLASHC_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password, 
								I2CFLASHA_ERASE,
								I2CFLASHB_ERASE,
								I2CFLASHC_ERASE,
								I2CDISABLE ! Exit the programming mode"	;
														
	"JTAGI2C XFLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,
									JTAGI2CDISABLE ! Exit the programming mode"	;						
	
	"XFLASH CFG Erase Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password,  
								FLASHACFG_ERASE,
								FLASHBCFG_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHACFG_ERASE,
									SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHACFG_ERASE,
								I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"XFLASH UFM Erase Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_UFM_PASSWORD ! Check the Password,  
								FLASHAUFM_ERASE,
								FLASHBUFM_ERASE,
								FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SPIFLASHAUFM_ERASE,
									SPIFLASHBUFM_ERASE,
									SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								I2CFLASHAUFM_ERASE,
								I2CFLASHBUFM_ERASE,
								I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	
														
	"JTAGI2C XFLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;							
								
	"XFLASH Verify Only" =	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_VERIFY,
								FLASHB_VERIFY,	
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									SPICHECK_PASSWORD ! Check the Password,  	
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
								I2CCHECK_PASSWORD ! Check the Password,  		
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,	
								I2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  		
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,	
									JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Verify Only" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C XFLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;											
									
	"XFLASH UFM Verify Only" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,									
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
											SPICHECK_UFM_PASSWORD ! Check the Password,  							
											SPIUFM_VERIFY_ONLY,	
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,	
									I2CDISABLE ! Exit the programming mode"	;											

	"JTAGI2C XFLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,	
										JTAGI2CDISABLE ! Exit the programming mode"	;											
									
	"XFLASH Read and Save" =	"INIT ! Initialize,
									 READ_ID ! Check the IDCODE,
									 SAVE_ID, 
									 FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									 CHECK_PASSWORD ! Check the Password,  
									 FLASHA_SAVE,
									 FLASHB_SAVE,
									 FLASHC_SAVE,
									 DISABLE ! Exit the programming mode";
											 																								
	"Slave SPI XFLASH Read and Save" =	"SPIINIT ! Initialize,
										 SPIREAD_ID ! Check the IDCODE,
										 SPISAVE_ID, 
										 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										 SPICHECK_PASSWORD ! Check the Password, 
										 SPIFLASHA_SAVE,
									 	 SPIFLASHB_SAVE,
									 	 SPIFLASHC_SAVE,
										 SPIDISABLE ! Exit the programming mode";
	
	"I2C XFLASH Read and Save" =	"I2CINIT ! Initialize,
								 I2CREAD_ID ! Check the IDCODE,
								 I2CSAVE_ID, 
								 I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								 I2CCHECK_PASSWORD ! Check the Password,  
								 I2CFLASHA_SAVE,
								 I2CFLASHB_SAVE,
								 I2CFLASHC_SAVE,
								 I2CDISABLE ! Exit the programming mode";

	"JTAGI2C XFLASH Read and Save" =	"JTAGI2CINIT ! Initialize,
										 JTAGI2CREAD_ID ! Check the IDCODE,
										 JTAGI2CSAVE_ID, 
										 JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										 JTAGI2CCHECK_PASSWORD ! Check the Password,  
										 JTAGI2CFLASHA_SAVE,
										 JTAGI2CFLASHB_SAVE,
										 JTAGI2CFLASHC_SAVE,
										 JTAGI2CDISABLE ! Exit the programming mode";											 																			 							 									
										 									 									 									 									 										 										 
	"XFLASH Bypass" ="INIT 	! Initialize"; 
								
	"Slave SPI XFLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C XFLASH Bypass" =	"I2CINIT 	! Initialize"; 	

	"JTAGI2C XFLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="INIT 	! Initialize"; 
															 	
	"XFLASH Verify ID" ="INIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI XFLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C XFLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C XFLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID ! Check the IDCODE"; 																

	"XFLASH Display ID" =	"INIT, SAVE_ID";
	
	"Slave SPI XFLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C XFLASH Display ID" =	"I2CINIT, I2CSAVE_ID";
								 
	"JTAGI2C XFLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";

	"XFLASH Verify USERCODE" =	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									FLASH_ENABLE	! Enable the Flash access, 
									CHECK_PASSWORD ! Check PASSWORD, 
									SELECT_CFG0	! Select CFG0,
									CFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
									SELECT_CFG1	! Select CFG1 Sector,
									CFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
									DISABLE ! Exit the programming mode";
	
	"Slave SPI XFLASH Verify USERCODE" =	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the Flash access, 
									    SPICHECK_PASSWORD ! Check PASSWORD, 
										SPISELECT_CFG0	! Select CFG0,
										SPICFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
										SPISELECT_CFG1	! Select CFG1,
										SPICFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
																				

	"I2C XFLASH Verify USERCODE" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CFLASH_ENABLE	! Enable the Flash access, 
									I2CCHECK_PASSWORD ! Check PASSWORD, 
									I2CSELECT_CFG0	! Select CFG0,
									I2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
									I2CSELECT_CFG1	! Select CFG1,
									I2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C XFLASH Verify USERCODE" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access, 
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
										JTAGI2CSELECT_CFG0	! Select CFG0,
										JTAGI2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
																														
	"XFLASH Display USERCODE" =	"INIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
											CHECK_PASSWORD ! Check PASSWORD, 
											SELECT_CFG0	! Select CFG0,
											DISPLAY_CFG0_USERCODE,
											SELECT_CFG1	! Select CFG1,
											DISPLAY_CFG1_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI XFLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash access, 
											SPICHECK_PASSWORD ! Check PASSWORD, 	
											SPISELECT_CFG0	! Select CFG1,
											SPIDISPLAY_CFG0__USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPIDISPLAY_CFG1__USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C XFLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
										I2CCHECK_PASSWORD ! Check PASSWORD,   
										I2CSELECT_CFG0	! Select CFG1,
										I2CDISPLAY_CFG0__USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2CDISPLAY_CFG1__USERCODE,
										I2CDISABLE ! Exit the programming mode";										

	"JTAGI2C XFLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD,   
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";		
										
	
	"XFLASH Read Status Register" =	"INIT ! Initialize,
												 READ_ID	! Check the IDCODE,
												 SAVE_ID,
												 FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												 SAVE_STATUS,
												 DISABLE";
	
	"Slave SPI XFLASH Read Status Register" =	"SPIINIT ! Initialize,
													 SPIREAD_ID	! Check the IDCODE,
													 SPISAVE_ID,
													 SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													 SPISAVE_STATUS,
													 SPIDISABLE";
	
	"I2C XFLASH Read Status Register" =	"I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											 I2CSAVE_STATUS,
											 I2CDISABLE";		
											
	"JTAGI2C XFLASH Read Status Register" =	"JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											 JTAGI2CSAVE_STATUS,
											 JTAGI2CDISABLE";												 												 	
	
	"XFLASH Refresh" =" INIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI XFLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C XFLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C XFLASH Refresh" ="JTAGI2CINIT !Initialize,
								JTAGI2CREAD_ID !Check the IDCODE,
								JTAGI2CREFRESH_FUNCTION ! Refresh";													
	
	"XFLASH Secure CFG Plus" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C XFLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
										
	"XFLASH Update CFG Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Update CFG Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Update CFG Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Update CFG Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																		
	"XFLASH Secure UFM Plus" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
										
	"XFLASH Update UFM Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Update UFM Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Update UFM Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Update UFM Locks Policies" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
		
	"XFLASH Read CFG Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_READ_LOCK ! Check LOCK information,
									CFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Read CFG Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPICFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Read CFG Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Read CFG Locks Policies" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
												JTAGI2CSELECT_CSEC	! Select CSEC,
												JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
												JTAGI2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
												JTAGI2CDISABLE	! Exit the programming mode";
	
	"XFLASH Read UFM Locks Policies" ="INIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_READ_LOCK ! Check LOCK information,
									UFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Read UFM Locks Policies" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPIUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Read UFM Locks Policies" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Read UFM Locks Policies" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CSELECT_USEC	! Select USEC,
												JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
												JTAGI2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
												JTAGI2CDISABLE	! Exit the programming mode";
																	
	"Enable SPI" = " INIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,  
					 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = " INIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
								 CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,										 
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 CHECK_PASSWORD ! Check the Password, 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;
								 
	"Verify ID" = 		"INIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 

	"Verify ID with Password" = 		"INIT 	! Initialize, 
										READ_ID ! Check the IDCODE, 
										CHECK_PASSWORD ! Check the Password"; 
						 
	"Security Display TraceID" = "INIT, SAVE_TRACEID";
	
	"Manufacturing Read Trim Register" = " INIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SAVE_ID,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   SELECT_TRIM ! Select Trim,
									   READ_TRIM_REGISTER ! Read the Trim Register,
									   DISABLE ! Exit the programming mode" ;
									   
	"Manufacturing Read PES Fuses" = " INIT 	! Initialize, 
									   READ_ID	! Check the IDCODE,
									   SAVE_ID,
									   FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									   SELECT_TRIM ! Select Trim,
									   READ_PES_FUSES ! Read the PES Register,
									   DISABLE ! Exit the programming mode" ;
									   							 
	"Manufacturing Read MES Fuses" = "INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									SELECT_TRIM ! Select Trim,
									READ_MES_REGISTER ! Read the MES Register,
									DISABLE ! Exit the programming mode" ;
									
	"Manufacturing Read DTR Fuses" = "INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									SELECT_TRIM ! Select Trim,
									READ_DTR_REGISTER ! Read the Manufacturing Register,
									DISABLE ! Exit the programming mode" ;

	"Read Manufacturing Register" = "INIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  SAVE_ID,
									  FLASH_SUDO_TRANSPARENT_ENABLE	! Enable the Manufacturing Mode,
									  READ_MANUFACTURING_REGISTER ! Read the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;

	"Program Manufacturing Register" = "INIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  FLASH_SUDO_TRANSPARENT_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_MANUFACTURING_REGISTER ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;									  
									  
	"Security Read CSEC" ="INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
							SELECT_CSEC	! Select CSEC,
							CHECK_READ_LOCK ! Check LOCK information,
							CFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Read CSEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPICFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Read CSEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Read CSEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									JTAGI2CSELECT_CSEC	! Select CSEC,
									JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
									JTAGI2CCFG_READ_CENTRAL_LOCK	! Read CSEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";
	
	
	"Security Read USEC" ="INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
							CHECK_UFM_PASSWORD ! Check PASSWORD,  
							SELECT_USEC	! Select USEC,
							CHECK_READ_LOCK ! Check LOCK information,
							UFM_READ_CENTRAL_LOCK	! Read USEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Read USEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_READ_LOCK ! Check LOCK information,
									SPIUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Read USEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_READ_LOCK ! Check LOCK information,
									I2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									I2CDISABLE	! Exit the programming mode";	
										
	"JTAGI2C Security Read USEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,
									JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									JTAGI2CSELECT_USEC	! Select USEC,
									JTAGI2CCHECK_READ_LOCK ! Check LOCK information,
									JTAGI2CUFM_READ_CENTRAL_LOCK	! Read USEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";									  
	
	
	"Security Erase CSEC" ="INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
							SELECT_CSEC	! Select CSEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							CSEC_ERASE	! Erase CSEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase CSEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SPICSEC_ERASE	! Erase CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase CSEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									I2CCSEC_ERASE	! Erase CSEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Erase CSEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_ENABLE_PASSWORD! Check PASSWORD,  
									JTAGI2CSELECT_CSEC	! Select CSEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CCSEC_ERASE	! Erase CSEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";
	
	"Security Erase USEC" ="INIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_UFM_PASSWORD ! Check PASSWORD,  
							SELECT_USEC	! Select USEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							USEC_ERASE	! Erase USEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase USEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SPIUSEC_ERASE	! Erase USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase USEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									I2CUSEC_ERASE	! Erase USEC central lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C Security Erase USEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									JTAGI2CSELECT_USEC	! Select USEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CUSEC_ERASE	! Erase USEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";
																									  
	"XFLASH TransFR" = "	INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh"	;

	"Slave SPI XFLASH TransFR" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh"	;
	"I2C XFLASH TransFR" = "	I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CREFRESH_FUNCTION ! Refresh"	;	
								
	"JTAGI2C XFLASH TransFR" = "	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CREFRESH_FUNCTION ! Refresh"	;							

	"XFLASH Program and TransFR" ="INIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										FLASHA_PROGRAM,
										FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode,									
										REFRESH_FUNCTION ! Refresh,
										VERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
										
	"Slave SPI XFLASH Program and TransFR" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode,									
											SPIREFRESH_FUNCTION ! Refresh,
											SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;		

	"I2C XFLASH Program and TransFR" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD,  
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode,									
										I2CREFRESH_FUNCTION ! Refresh,
										I2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
									
	"JTAGI2C XFLASH Program and TransFR" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE_REFRESH! Refresh,
											JTAGI2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;
										
	"FLASH Dry Run" =	"INIT 	! Initialize,  
							READ_ID	! Check the IDCODE, 
							CHECK_PASSWORD ! Check PASSWORD, 
							CHECK_AUTHTICATE ! Check Authenticate,
							FLASHA_DRYRUN,
							FLASHB_DRYRUN"	;													
	
	"Slave SPI FLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPICHECK_PASSWORD ! Check PASSWORD, 
									SPICHECK_AUTHTICATE ! Check Authenticate,
									SPIFLASHA_DRYRUN,
									SPIFLASHB_DRYRUN"	;
	
	"I2C FLASH Dry Run" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_PASSWORD ! Check PASSWORD, 
								I2CCHECK_AUTHTICATE ! Check Authenticate,
								I2CFLASHA_DRYRUN,
								I2CFLASHB_DRYRUN"	;		
											
	"JTAGI2C FLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;																			
	
	"XFLASH Dry Run" =	"INIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_PASSWORD ! Check PASSWORD, 
							CHECK_AUTHTICATE ! Check Authenticate,
							FLASHA_DRYRUN,
							FLASHB_DRYRUN"	;													
	
	"Slave SPI XFLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPICHECK_PASSWORD ! Check PASSWORD, 
									SPICHECK_AUTHTICATE ! Check Authenticate,
									SPIFLASHA_DRYRUN,
									SPIFLASHB_DRYRUN"	;
	
	"I2C XFLASH Dry Run" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CCHECK_PASSWORD ! Check PASSWORD, 
								I2CCHECK_AUTHTICATE ! Check Authenticate,
								I2CFLASHA_DRYRUN,
								I2CFLASHB_DRYRUN"	;	
									
	"JTAGI2C XFLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;

	"FLASH Display USERCODE" =	"INIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_ENABLE	! Enable the Flash access,
											SELECT_CFG0	! Select CFG0,
											DISPLAY_CFG0_USERCODE,
											SELECT_CFG1	! Select CFG1,
											DISPLAY_CFG1_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI FLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_ENABLE	! Enable the Flash access, 
											SPISELECT_CFG0	! Select CFG1,
											SPIDISPLAY_CFG0__USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPIDISPLAY_CFG1__USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C FLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_ENABLE	! Enable the Flash access,  
										I2CSELECT_CFG0	! Select CFG1,
										I2CDISPLAY_CFG0__USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2CDISPLAY_CFG1__USERCODE,
										I2CDISABLE ! Exit the programming mode";	
									
	"JTAGI2C FLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access,  
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";
	
	"Security Read TraceID" = "INIT, SAVE_TRACEID";	
										
	"Slave SPI Security Read TraceID" = "SPIINIT, SPISAVE_TRACEID";	

	"I2C Security Read TraceID" = "I2CINIT, I2CSAVE_TRACEID";	
											
	"JTAGI2C Security Read TraceID" = "JTAGI2CINIT, JTAGI2CSAVE_TRACEID";
	
	
</Operation_List>
<Operation_List label="SingleSVFOperation">		 		 
	"SRAM Fast Configuration" = "	SVFINIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password, 
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM	! Program Fuse Map,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify Status Register,
										VERIFY_USERCODE		! Verify USERCODE,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "SVFINIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password,   
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,											
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										CHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SRAM_VERIFY	! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_CONTROL1_2	! Program Control1 Register,
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password,
								CHECK_SRAM_READ_LOCK ! Check the SRAM lock,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password,  								
								CHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"SVFINIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "SVFINIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
											 CHECK_PASSWORD ! Check the Password,  			
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"SVFINIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SVF_SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"SVFINIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
								     CHECK_PASSWORD ! Check the Password, 
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SVF_SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "SVFINIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID, 
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure Plus" = " SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_PASSWORD ! Check the Password,  
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE_SVF ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"SVFINIT 	! Initialize";	
	

	"Slave SPI SRAM Fast Configuration" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,  
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIBURST_PROGRAM	! Program Fuse Map,
										SVF_SPIVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI SRAM Erase,Program,Verify" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIPROGRAM_CONTROL0	! Program Control Register0,
										SPIPROGRAM_CONTROL1	! Program Control Register1,
										SPISRAM_PROGRAM	! Program Fuse Map,
										SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SPISRAM_VERIFY	! Verify Fuse Map, 
										SPIVERIFY_USERCODE		! Verify USERCODE, 
										SPIPROGRAM_CONTROL1_2	! Program Control1 Register,
										SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,
										SPIDISABLE ! Exit the programming mode"	;									
										
	"Slave SPI SRAM Verify Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
							SPIVERIFY_CONTROL0 ! Verify Control Register0,
							SPIVERIFY_CONTROL1 ! Verify Control Register1,
							SPISRAM_VERIFY	! Verify Fuse Map, 
							SPIVERIFY_USERCODE		! Verify USERCODE, 
		 			 		SPIDISABLE ! Exit the programming mode"	;
							
	"Slave SPI SRAM Erase Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE,
							SPISRAM_ENABLE	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							SPISRAM_ERASE	! Erase the SRAM, 
		 			 		SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI SRAM Verify ID" = 	"SPIINIT 	! Initialize, 
						 			SPIREAD_ID ! Check the IDCODE"; 

	"Slave SPI SRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";

	"Slave SPI SRAM Program Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
								 SPIPROGRAM_CONTROL0 ! Program Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Display Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISAVE_CONTROL0 !Read Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Program Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
					 			 SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             SPIDISABLE";

	"Slave SPI SRAM Display Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISAVE_CONTROL1 !Read Control Register 1,
					             SPIDISABLE";	

	"Slave SPI SRAM Verify USERCODE"	=	"SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPIVERIFY_USERCODE		! Verify USERCODE,
											 SPIDISABLE"; 
								
	"Slave SPI SRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPI_SVF_SAVE_USERCODE,
											 SPIDISABLE";								
								
	"Slave SPI SRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
								         SPICHECK_PASSWORD ! Check the Password, 
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPI_SVF_SAVE_USERCODE, 
										 SPIDISABLE";								
								
	"Slave SPI SRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID, 
								 			 SPISAVE_STATUS";									
								
	"Slave SPI SRAM Refresh" = "SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";								
	
	"Slave SPI SRAM Secure Plus" = "SPIINIT !Initialize,
							SPIREAD_ID !Check the IDCODE,
							SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 								             
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SPISRAM_SECURE_SVF ! Secure the SRAM,
							SPIDISABLE";
														
	"Slave SPI SRAM Bypass"	=	"SPIINIT 	! Initialize";	

					
	"I2C SRAM Fast Configuration" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										SVF_I2CVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C SRAM Erase,Program,Verify" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CCHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CPROGRAM_CONTROL0	! Program Control Register0,
										I2CPROGRAM_CONTROL1	! Program Control Register1,
										I2CSRAM_PROGRAM	! Program Fuse Map,
										I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
										I2CCHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										I2CSRAM_VERIFY	! Verify Fuse Map, 
										I2CVERIFY_USERCODE		! Verify USERCODE, 
										I2CPROGRAM_CONTROL1_2	! Program Control1 Register,
										I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"I2C SRAM Verify Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,  
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password,  
							I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
							I2CVERIFY_CONTROL0	! Verify Control Register0,
							I2CVERIFY_CONTROL1	! Verify Control Register1,
							I2CSRAM_VERIFY	! Verify Fuse Map, 
							I2CVERIFY_USERCODE		! Verify USERCODE, 
		 			 		I2CDISABLE ! Exit the programming mode"	;
							
	"I2C SRAM Erase Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CSRAM_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password, 
							I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							I2CSRAM_ERASE	! Erase the SRAM, 
		 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C SRAM Verify ID" = 	"I2CINIT 	! Initialize, 
						 	 I2CREAD_ID ! Check the IDCODE"; 

	"I2C SRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";

	"I2C SRAM Program Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
								 I2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Display Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
					 			 I2CSAVE_CONTROL0 !Read Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Program Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
								 I2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             I2CDISABLE";

	"I2C SRAM Display Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
					 			 I2CSAVE_CONTROL1 !Read Control Register 1,
					             I2CDISABLE";	

	"I2C SRAM Verify USERCODE"	=	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_ENABLE,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE"	; 
								
	"I2C SRAM Display USERCODE"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID,
									 I2CSRAM_TRANSPARENT_READ_ENABLE,
									 I2C_SVF_SAVE_USERCODE,
									 I2CDISABLE";								
								
	"I2C SRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password, 
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2C_SVF_SAVE_USERCODE, 
									 I2CDISABLE";								
								
	"I2C SRAM Read Status Register" = "I2CINIT ! Initialize,
					 			 		I2CREAD_ID	! Check the IDCODE,
					 			 		I2CSAVE_ID,
					 			 		I2CSAVE_STATUS";									
								
	"I2C SRAM Refresh" = " 	I2CINIT !Initialize,
							I2CREAD_ID !Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh";								
	
	
	"I2C SRAM Secure Plus" = "I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						I2CCHECK_PASSWORD ! Check the Password,  
						I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						I2CSRAM_SECURE_SVF ! Secure the SRAM,
						I2CDISABLE";
														
	"I2C SRAM Bypass"	=	"I2CINIT 	! Initialize";	
	
	"SRAM External Primary Dry Run" =	"INIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										SVF_PRIMARY_DRYRUN"	;

	"Slave SPI SRAM External Primary Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Primary Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											SVF_I2CPRIMARY_DRYRUN"	;							

	"JTAGI2C SRAM External Primary Dry Run" =	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CPRIMARY_DRYRUN"	;	
											
	"SRAM External Golden Dry Run" =	"INIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										SVF_GOLDEN_DRYRUN"	;

	"Slave SPI SRAM External Golden Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Golden Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											SVF_I2CGOLDEN_DRYRUN"	;	

	"JTAGI2C SRAM External Golden Dry Run" =	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CGOLDEN_DRYRUN"	;												
	
	"JTAGI2C SRAM Fast Configuration" = "JTAGI2CINIT 	! Initialize,   
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
										JTAGI2CSRAM_ERASE	! Erase the SRAM, 
										JTAGI2CBURST_PROGRAM	! Program Fuse Map,
										JTAGI2CVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C SRAM Erase,Program,Verify" = "NOT_SUPPORTED"	;	
										
	"JTAGI2C SRAM Verify Only"	=	"NOT_SUPPORTED"	;
							
	"JTAGI2C SRAM Erase Only"	=	"	JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							JTAGI2CCHECK_PASSWORD ! Check the Password, 
							JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							JTAGI2CSRAM_ERASE	! Erase the SRAM, 
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C SRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
						 		 JTAGI2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C SRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";

	"JTAGI2C SRAM Program Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 JTAGI2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
					 			 JTAGI2CSAVE_CONTROL0 !Read Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Program Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             JTAGI2CDISABLE";

	"JTAGI2C SRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode,  
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
					 			 JTAGI2CSAVE_CONTROL1 !Read Control Register 1,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Verify USERCODE"	=	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_ENABLE,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
									JTAGI2CDISABLE"	; 
								
	"JTAGI2C SRAM Display USERCODE"	=	"JTAGI2CINIT, 
									 JTAGI2CREAD_ID, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CSRAM_ENABLE,
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE";								
								
	"JTAGI2C SRAM Read and Save"	=	"NOT_SUPPORTED";								
								
	"JTAGI2C SRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
					 			 		JTAGI2CREAD_ID	! Check the IDCODE,
					 			 		JTAGI2CSAVE_ID,
					 			 		JTAGI2CSAVE_STATUS";									
								
	"JTAGI2C SRAM Refresh" = " 	JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";								
	
	
	"JTAGI2C SRAM Secure Plus" = "JTAGI2CINIT !Initialize,
						JTAGI2CREAD_ID !Check the IDCODE,
						JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						JTAGI2CCHECK_PASSWORD ! Check the Password,  
						JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						JTAGI2CSRAM_SECURE ! Secure the SRAM,
						JTAGI2CDISABLE";
														
	"JTAGI2C SRAM Bypass"	=	"JTAGI2CINIT 	! Initialize";	
	
	
	"XSRAM SEI Fast Program" 	= "SVFINIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									CHECK_PASSWORD ! Check the Password,  
								 	CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;


	"XSRAM Verify ID" = 	"SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE"	; 


	"XSRAM Display ID" = "SVFINIT, READ_ID, SAVE_ID";	

	"XSRAM Display Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SAVE_CONTROL0 ! Read Control Register 0,
								             DISABLE";	

	"XSRAM Display Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SAVE_CONTROL1 ! Read Control Register 1,
								             DISABLE";		

	"XSRAM Read and Save"	=	"SVFINIT, 
									 READ_ID, 
									 SAVE_ID, 
									 SRAM_TRANSPARENT_READ_ENABLE, 
								     CHECK_PASSWORD ! Check the Password,  
									 CHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SVF_SAVE_USERCODE, 
									 DISABLE";			
	
	"XSRAM Display USERCODE"	=	"SVFINIT, 
										 READ_ID, 
										 SAVE_ID,
										 SRAM_TRANSPARENT_READ_ENABLE,
										 SVF_SAVE_USERCODE,
										 DISABLE";
		
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 SAVE_STATUS,
							 			 DISABLE ! Exit the programming mode";	

	"XSRAM Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh" ;

	"XSRAM Bypass"	=	"	SVFINIT 	! Initialize"	;
																	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;


	"Slave SPI XSRAM Verify ID" = 	"	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE"	; 


	"Slave SPI XSRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";	

	"Slave SPI XSRAM Display Control Register0" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL0 ! Read Control Register 0,
									             SPIDISABLE";	

	"Slave SPI XSRAM Display Control Register1" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
												 SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL1 ! Read Control Register 1,
									             SPIDISABLE";		

	"Slave SPI XSRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
									     SPICHECK_PASSWORD ! Check the Password,  
										 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPI_SVF_SAVE_USERCODE, 
										 SPIDISABLE";			
	
	"Slave SPI XSRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPI_SVF_SAVE_USERCODE,
											 SPIDISABLE";
		
	"Slave SPI XSRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID,
								 			 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
								 			 SPISAVE_STATUS,
								 			 SPIDISABLE ! Exit the programming mode";	

	"Slave SPI XSRAM Refresh" = "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPIREFRESH_FUNCTION ! Refresh" ;

	"Slave SPI XSRAM Bypass"	=	"	SPIINIT 	! Initialize"	;
	
	"I2C XSRAM SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;


	"I2C XSRAM Verify ID" = 	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE"	; 


	"I2C XSRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";	

	"I2C XSRAM Display Control Register0" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 I2CCHECK_PASSWORD ! Check the Password,
								 			 I2CSAVE_CONTROL0 ! Read Control Register 0,
								             I2CDISABLE";	

	"I2C XSRAM Display Control Register1" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 I2CCHECK_PASSWORD ! Check the Password,
								 			 I2CSAVE_CONTROL1 ! Read Control Register 1,
								             I2CDISABLE";		

	"I2C XSRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password,
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2C_SVF_SAVE_USERCODE, 
									 I2CDISABLE";			
	
	"I2C XSRAM Display USERCODE"	=	"I2CINIT, 
										I2CREAD_ID, 
										I2CSAVE_ID,
										I2CSRAM_TRANSPARENT_READ_ENABLE,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE";
		
	"I2C XSRAM Read Status Register" = "I2CINIT ! Initialize,
							 			 I2CREAD_ID	! Check the IDCODE,
							 			 I2CSAVE_ID,
							 			 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 I2CSAVE_STATUS,
							 			 I2CDISABLE ! Exit the programming mode";	

	"I2C XSRAM Refresh" = "	I2CINIT 	! Initialize,   
							I2CREAD_ID	! Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh" ;

	"I2C XSRAM Bypass"	=	"	I2CINIT 	! Initialize"	;

	"JTAGI2C XSRAM SEI Fast Program" 	= "	JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;


	"JTAGI2C XSRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE"	; 


	"JTAGI2C XSRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";	

	"JTAGI2C XSRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 			 JTAGI2CSAVE_CONTROL0 ! Read Control Register 0,
								             JTAGI2CDISABLE";	

	"JTAGI2C XSRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
											 JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 			 JTAGI2CSAVE_CONTROL1 ! Read Control Register 1,
								             JTAGI2CDISABLE";		

	"JTAGI2C XSRAM Read and Save"	=	"NOT_SUPPORTED";			
	
	"JTAGI2C XSRAM Display USERCODE"	=	"JTAGI2CINIT, 
										JTAGI2CREAD_ID, 
										JTAGI2CSAVE_ID,
										JTAGI2CSRAM_TRANSPARENT_READ_ENABLE,
										JTAGI2CSAVE_USERCODE,
										JTAGI2CDISABLE";
		
	"JTAGI2C XSRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
							 			 JTAGI2CREAD_ID	! Check the IDCODE,
							 			 JTAGI2CSAVE_ID,
							 			 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 JTAGI2CSAVE_STATUS,
							 			 JTAGI2CDISABLE ! Exit the programming mode";	

	"JTAGI2C XSRAM Refresh" = "JTAGI2CINIT 	! Initialize,   
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh" ;

	"JTAGI2C XSRAM Bypass"	=	"JTAGI2CINIT 	! Initialize"	;
			 	
	"Program Feature Row" ="	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,										
									FLASH_ENABLE	! Enable the programming mode,    
									CHECK_ENABLE_PASSWORD ! Check the Password, 											 
									SELECT_FEA ! Select Feature sector,
									CHECK_ERASE_LOCK ! Check the Erase Locks,
									CHECK_PROG_LOCK ! Check the Program Locks,
									FEATURE_ERASE	! Erase the Feature,
									CHECK_STATUS ! Read the status bit,
									CHECK_READ_LOCK ! Check the Central Read Locks,
									FEATURE_PROGRAM ! Program Feature Rows,
									CHECK_STATUS ! Read the status bit,
									DISABLE ! Exit the programming mode"	;	

	"Program Feature Row Secure" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_FEA ! Select Feature sector,
									    CHECK_ERASE_LOCK ! Check the Erase Locks,
										CHECK_PROG_LOCK ! Check the Program Locks,										
										FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
					 					CHECK_READ_LOCK ! Check the Central Read Locks,
										FEATURE_PROGRAM ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										SVF_PROGRAM_LOCK ! Program the local lock policy,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
										
	"Program Feature Row Lock" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,
										CHECK_PROG_LOCK ! Check the Locks,										
										SVF_PROGRAM_LOCK ! Program the lock information,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
																															
	"Erase Feature Row" ="	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the programming mode,
								CHECK_ENABLE_PASSWORD ! Check the Password, 									
								SELECT_FEA ! Select Feature sector,									
								CHECK_ERASE_LOCK ! Check the Locks,	
								FEATURE_ERASE	! Erase the Feature row, 
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;

	"Read Feature Row" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_ENABLE	! Enable the programming mode,									
									CHECK_ENABLE_PASSWORD ! Check the Password, 
									SELECT_FEA ! Select Feature sector,	
									CHECK_READ_LOCK ! Check the Locks,														
									FEATURE_ROW_READ	! Read the Feature row, 
									DISABLE ! Exit the programming mode"	;
	
	"Program Control NV Register1" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,										
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,	
										CHECK_READ_LOCK ! Check the Locks,	
										CHECK_PROG_LOCK ! Check the Locks,	
										CHECK_ERASE_LOCK ! Check the Locks,
										PROGRAM_CONTROL_NV1 ! Program Control Register1,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
	
	"Display Control NV Register1" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SELECT_FEA ! Select Feature sector,		
										CHECK_READ_LOCK ! Check the Locks,
										SAVE_CONTROLNV1 ! Read Control Register1,
										DISABLE ! Exit the programming mode"	;		

	"Slave SPI Program Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	
										
	"Slave SPI Update Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	

	"Slave SPI Program Feature Row Secure" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,									
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPISVF_PROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	"Slave SPI Program Feature Row Lock" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPISVF_PROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;										

	"Slave SPI Erase Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 								
										SPISELECT_FEA ! Select Feature sector,	 											
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SPIFEATURE_ERASE	! Erase the Feature row,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI Read Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 
									    SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the key lock information,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Program Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,	
										SPICHECK_PROG_LOCK ! Check the Locks,	
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SPIPROGRAM_CONTROL_NV1 ! Program Control Register1,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI Display Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,
										SPISAVE_CONTROLNV1 ! Read Control Register1,
										SPIDISABLE ! Exit the programming mode"	;		

	"I2C Program Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;	

	"I2C Update Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,		
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;

	"I2C Program Feature Row Secure" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CSVF_PROGRAM_NEW_ADDRESS_LOCK ! Program the local lock policy,
										I2CFEATUREDISABLE ! Exit the programming mode"	;
										
	"I2C Program Feature Row Lock" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
										I2CFEATUREDISABLE ! Exit the programming mode"	;										

	"I2C Erase Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										I2CSELECT_FEA ! Select Feature sector,	 											
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										I2CFEATURE_ERASE	! Erase the Feature row,
										I2CDISABLE_DEFAULT ! Exit the programming mode"	;

	"I2C Read Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 
									    I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the key lock information,
										I2CFEATURE_ROW_READ	! Read the Feature row, 
										I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Program Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,	
										I2CCHECK_PROG_LOCK ! Check the Locks,	
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										I2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
										I2CCHECK_STATUS ! Read the status bit,
										I2CDISABLE ! Exit the programming mode"	;	
	
	"I2C Display Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
										I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,
										I2CSAVE_CONTROLNV1 ! Read Control Register1,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C Program Feature Row" ="	JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,										
										JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
										JTAGI2CSELECT_FEA ! Select Feature sector,		
										JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
										JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
										JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;

	"JTAGI2C Update Feature Row" ="	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,										
									JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
									JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
									JTAGI2CSELECT_FEA ! Select Feature sector,		
									JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
									JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
									JTAGI2CFEATURE_ERASE	! Erase the Feature,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
									JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
									JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C Program Feature Row Lock" ="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode,
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,										
											JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;										

	"JTAGI2C Erase Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										JTAGI2CSELECT_FEA ! Select Feature sector,	 											
										JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature row,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Read Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 
										JTAGI2CSELECT_FEA ! Select Feature sector,
										JTAGI2CCHECK_READ_LOCK ! Check the key lock information,
										JTAGI2CFEATURE_ROW_READ	! Read the Feature row, 
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,										
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,	
											JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C Display Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,
											JTAGI2CSAVE_CONTROLNV1 ! Read Control Register1,
											JTAGI2CDISABLE ! Exit the programming mode"	;										
	
	"Security Program Auth Done FlashA" =   "SVFINIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash, 	 											 
											  SELECT_CFG0 ! Select Flash A,
											  PROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashA" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash, 	 											 
											  SPISELECT_CFG0 ! Select Flash A,
											  SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;

	"I2C Security Program Auth Done FlashA" =   "I2CINIT 	! Initialize, 
												  I2CREAD_ID	! Check the IDCODE, 
												  I2CFLASH_ENABLE	! Enable the Flash, 												 
											      I2CSELECT_CFG0 ! Select Flash A,
												  I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
												  I2CDISABLE ! Exit the programming mode" ;
											  											  
	"JTAGI2C Security Program Auth Done FlashA" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  											  
													  JTAGI2CSELECT_CFG0 ! Select Flash A,
													  JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;	
																						  
	"Security Program Auth Done FlashB" =   "SVFINIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash,  											 
										      SELECT_CFG1 ! Select Flash B,
											  PROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashB" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash, 											 
										      SPISELECT_CFG1 ! Select Flash B,
											  SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Auth Done FlashB" =   "I2CINIT 	! Initialize, 
											  I2CREAD_ID	! Check the IDCODE, 
											  I2CFLASH_ENABLE	! Enable the Flash,  											 
										      I2CSELECT_CFG1 ! Select Flash B,
											  I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Program Auth Done FlashB" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	 
													  JTAGI2CSELECT_CFG1 ! Select Flash B,
													  JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;	
											  
	"Security Program Password Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  SELECT_FEA ! Select Feature Sector,
								  CHECK_PROG_LOCK ! Check the Locks,						
								  PROGRAM_PASSWORD ! Program the Password key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Password Key Secure" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks,
								  PROGRAM_PASSWORD ! Program the Password key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  CHECK_STATUS ! Read the status bit,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Password Key Lock" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;

	"Security Program Encryption Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_AESKEY ! Program the Encryption key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Encryption Key Secure" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_AESKEY ! Select AESKEY Sector, 
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_AESKEY ! Program the Encryption key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key Lock" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_AESKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;	

	"Slave SPI Security Program Password Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPISELECT_FEA ! Select Feature Sector,
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_PASSWORD ! Program the Password key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Password Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_PASSWORD ! Program the Password key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Password Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_AESKEY ! Program the Encryption key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Encryption Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector, 		
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_AESKEY ! Program the Encryption key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Encryption Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
	
	"I2C Security Program Password Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CSELECT_FEA ! Select Feature Sector,
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key,        
								  I2CDISABLE ! Exit the programming mode" ;
									 
	"JTAGI2C Security Program Password Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	
											  JTAGI2CSELECT_FEA ! Select Feature Sector,
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											  JTAGI2CPROGRAM_PASSWORD ! Program the Password key,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Password Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash, 	 
													  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
													  JTAGI2CPROGRAM_PASSWORD ! Program the Password key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Password Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Lock" ="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
												  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_AESKEY ! Program the Encryption key,         
								  I2CDISABLE ! Exit the programming mode" ;
								  
	"JTAGI2C Security Program Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
											  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Encryption Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 	
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_AESKEY ! Program the Encryption key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Encryption Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 	
													  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
													  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
													  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
													  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Encryption Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Program Encryption Key Lock" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;		
	
	"Security Program Public Key" =	"SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_PUBKEY ! Program the Public key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Public Key Secure"="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_PUBKEY ! Select AESKEY Sector, 
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  PROGRAM_PUBKEY ! Program the Public key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  
	"Security Program Public Key Lock"="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  								  
	
	"Slave SPI Security Program Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_PUBKEY ! Program the Public key,         
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Public Key Secure"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SPIPROGRAM_PUBKEY ! Program the Public key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Public Key Lock"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
	"I2C Security Program Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_PUBKEY ! Program the Public key,         
								  I2CDISABLE ! Exit the programming mode" ;
																  
	"JTAGI2C Security Program Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
											  JTAGI2CPROGRAM_PUBKEY ! Program the Public key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Public Key Secure"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 	
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  I2CPROGRAM_PUBKEY ! Program the Public key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Public Key Secure"="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 
												  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
												  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
												  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
												  JTAGI2CPROGRAM_PUBKEY ! Program the Public key, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Public Key Lock"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;		

	"JTAGI2C Security Program Public Key Lock"="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
											  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											  JTAGI2CDISABLE ! Exit the programming mode" ;								  
	
	"Security Program TraceID"="SVFINIT 	! Initialize, 
							    READ_ID	! Check the IDCODE,
							    FLASH_ENABLE	! Enable the programming mode,
							    CHECK_ENABLE_PASSWORD ! Check the Password, 
							    SELECT_FEA ! Select Feature Sector, 								  
							    CHECK_PROG_LOCK ! Check the Locks,
							    PROGRAM_TRACEID ! Program the TraceID,
							    DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program TraceID"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIFLASH_ENABLE	! Enable the programming mode,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password, 
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SPIPROGRAM_TRACEID ! Program the TraceID,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program TraceID"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CFLASH_ENABLE	! Enable the programming mode,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_TRACEID ! Program the TraceID,
								  I2CDISABLE ! Exit the programming mode" ;
								  							  
	"JTAGI2C Security Program TraceID"="JTAGI2CINIT 	! Initialize, 
									  JTAGI2CREAD_ID	! Check the IDCODE,
									  JTAGI2CFLASH_ENABLE	! Enable the programming mode,
									  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
									  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
									  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
									  JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
									  JTAGI2CDISABLE ! Exit the programming mode" ;	
															  
	"Security Program Authentication Mode"="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID, 
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_PUBKEY ! Select PUBKEY Sector, 								  
										CHECK_PROG_LOCK ! Check the Locks,
										PROGRAM_AUTHENTICATION ! Program Authentication Mode,                             
										DISABLE ! Exit the programming mode"	;
										
	"Slave SPI Security Program Authentication Mode"="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID, 
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_PUBKEY ! Select PUBKEY Sector, 								  
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPIPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Security Program Authentication Mode"="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID, 
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_PUBKEY ! Select Feature Sector, 								  
										I2CCHECK_PROG_LOCK ! Check the Locks,
										I2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										I2CDISABLE ! Exit the programming mode"	;		

	"JTAGI2C Security Program Authentication Mode"="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CSAVE_ID, 
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_PUBKEY ! Select Feature Sector, 								  
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
											JTAGI2CDISABLE ! Exit the programming mode"	;										
	
	"FLASH Recovery Erase Only" =	"SVFINIT 	! Initialize, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE_READ_ID	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,
									FLASHA_ERASE,
									FLASHB_ERASE,
									FLASHC_ERASE,								
									DISABLE ! Exit the programming mode"	;
																		
	"FLASH Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_ERASE,
								FLASHB_ERASE,
								FLASHC_ERASE,								
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI Recovery Erase Only"	=	"SPIINIT 	! Initialize, 
									SPIFLASH_ENABLE_READ_ID	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password, 
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
									
	"Slave SPI FLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password, 
									I2CFLASHA_ERASE,
									I2CFLASHB_ERASE,
									I2CFLASHC_ERASE,
				 			 		I2CDISABLE ! Exit the programming mode"	;
				 			 		
	"I2C FLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password,
								I2CFLASHA_ERASE,
								I2CFLASHB_ERASE,
								I2CFLASHC_ERASE,								
								I2CDISABLE ! Exit the programming mode"	;			

	"JTAGI2C FLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_PASSWORD ! Check the Password,
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,								
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Erase Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_PASSWORD ! Check the Password,  
									FLASHACFG_ERASE,
									FLASHBCFG_ERASE,
									DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHACFG_ERASE,
									SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHACFG_ERASE,
								I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"FLASH UFM Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_UFM_PASSWORD ! Check the Password,  
								FLASHAUFM_ERASE,
								FLASHBUFM_ERASE,
								FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SPIFLASHAUFM_ERASE,
									SPIFLASHBUFM_ERASE,
									SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								I2CFLASHAUFM_ERASE,
								I2CFLASHBUFM_ERASE,
								I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;				

	"JTAGI2C FLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"FLASH Version Rollback Protection" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD	! Check PASSWORD, 
										FLASHA_PROGRAM,
										SELECT_CFG0 ! Select Flash A,
										PROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										FLASHB_PROGRAM,	
										SELECT_CFG1 ! Select Flash B,
										PROGRAM_AUTH_DONE_B ! Program the Auth Done, 									
										DISABLE ! Exit the programming mode,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
										
	"Slave SPI FLASH Version Rollback Protection" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPISELECT_CFG0 ! Select Flash A,
											SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											SPIFLASHB_PROGRAM,	
											SPISELECT_CFG1 ! Select Flash B,
											SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,												
											SPIDISABLE ! Exit the programming mode"	;

	"I2C FLASH Version Rollback Protection" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										I2CFLASHA_PROGRAM,
										I2CSELECT_CFG0 ! Select Flash A,
										I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										I2CFLASHB_PROGRAM,	
										I2CSELECT_CFG1 ! Select Flash B,
										I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
										I2CDISABLE ! Exit the programming mode"	;																							

	"JTAGI2C FLASH Version Rollback Protection" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CSELECT_CFG0 ! Select Flash A,
											JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											JTAGI2CFLASHB_PROGRAM,
											JTAGI2CSELECT_CFG1 ! Select Flash B,
											JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
											JTAGI2CDISABLE ! Exit the programming mode"	;	
											
	"FLASH Erase,Program,Verify" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD ! Check PASSWORD,
										FULL_FLASHA_PROGRAM,
										FULL_FLASHB_PROGRAM,										
										DISABLE ! Exit the programming mode,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";										
												
	"Slave SPI FLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD,
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,													
											SPIDISABLE ! Exit the programming mode"	;	

	"I2C FLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD,
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH Verify Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_PASSWORD ! Check the Password,
								FLASHA_VERIFY,
								FLASHB_VERIFY,
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password,
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_ENABLE	! Enable the Flash, 
								I2CCHECK_PASSWORD ! Check the Password, 
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,
								I2CDISABLE ! Exit the programming mode"	;																															

	"JTAGI2C FLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C FLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH UFM Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_UFM_PASSWORD ! Check the Password,  							
									SPIUFM_VERIFY_ONLY,
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,
									I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
									
	"FLASH CFG Erase,Program,Verify" ="SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											FLASH_ENABLE	! Enable the Flash,
											CHECK_PASSWORD ! Check PASSWORD,  
											FULL_FLASHA_CFG_PROGRAM,
											FULL_FLASHB_CFG_PROGRAM,											
											DISABLE ! Exit the programming mode";
													
	"Slave SPI FLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPIFLASHB_CFG_PROGRAM,													
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C FLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											I2CFLASHA_CFG_PROGRAM,
											I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"FLASH UFM Erase,Program,Verify" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												FULL_UFM_PROGRAM_VERIFY,
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI FLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C FLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"FLASH Erase,Program,Verify,Secure" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_PASSWORD ! Check PASSWORD, 
												FULL_FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0,
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												FULL_FLASHB_PROGRAM,		
												SELECT_UFM1 ! Select UFM1,																																					
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,												
												DISABLE ! Exit the programming mode,
												SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
																									
	
	"Slave SPI FLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SPIFLASHB_PROGRAM,	
													SPISELECT_UFM1 ! Select UFM1,																																					
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_ENABLE	! Enable the Flash,
												I2CCHECK_PASSWORD ! Check PASSWORD,
												I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												I2CFLASHB_PROGRAM,		
												I2CSELECT_UFM1 ! Select UFM1,																																					
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																					
												I2CDISABLE ! Exit the programming mode"	;	
	
	"JTAGI2C FLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,	
													JTAGI2CSELECT_UFM1	! Select UFM1,																																					
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													JTAGI2CSELECT_CFG1 ! Select CFG1,
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																					
													JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"FLASH CFG Erase,Program,Verify,Secure" ="INIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_PASSWORD ! Check PASSWORD,  
													FULL_FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													FULL_FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;													
	
	"FLASH UFM Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													FULL_UFM_PROGRAM_VERIFY,																												
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																												
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													I2CUFM_PROGRAM_VERIFY,																												
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													 										
													I2CDISABLE ! Exit the programming mode"	;		

	"JTAGI2C FLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,	
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													 										
														JTAGI2CDISABLE ! Exit the programming mode"	;	
													
	"FLASH Refresh" =" SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI FLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C FLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C FLASH Refresh" ="JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";												
	
	"Security Lock Ports Interface" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Lock Ports Interface" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Lock Ports Interface" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C Security Lock Ports Interface" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
										JTAGI2CDISABLE	! Exit the programming mode";
									
	"FLASH Secure CFG Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																			
	"FLASH Secure UFM Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
									
	"FLASH Bypass" ="SVFINIT 	! Initialize"; 
								
	"Slave SPI FLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C FLASH Bypass" =	"I2CINIT 	! Initialize"; 

	"JTAGI2C FLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="SVFINIT 	! Initialize"; 
															 	
	"FLASH Verify ID" ="SVFINIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI FLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C FLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 																

	"JTAGI2C FLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
								 JTAGI2CREAD_ID ! Check the IDCODE"; 							 
							 
	"FLASH Display ID" =	"SVFINIT, SAVE_ID";
	
	"Slave SPI FLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C FLASH Display ID" =	"I2CINIT, I2CSAVE_ID";	
								 
	"JTAGI2C FLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";																					
	
	"XFLASH Erase,Program,Verify" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										FULL_FLASHA_PROGRAM,
										FULL_FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode";										
												
	"Slave SPI XFLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD,  
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C XFLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;																							
	
	"XFLASH CFG Erase,Program,Verify" ="SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD,  
												FULL_FLASHA_CFG_PROGRAM,
												FULL_FLASHB_CFG_PROGRAM,										
												DISABLE ! Exit the programming mode";
													
	"Slave SPI XFLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPIFLASHB_CFG_PROGRAM,														
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											I2CFLASHA_CFG_PROGRAM,
											I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C XFLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;
																																														
	"XFLASH UFM Erase,Program,Verify" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												FULL_UFM_PROGRAM_VERIFY,																 																	
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI XFLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C XFLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;	
												
	"JTAGI2C XFLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;												
																																			
	"XFLASH Erase,Program,Verify,Secure" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD,  
												FULL_FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0, 
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												FULL_FLASHB_PROGRAM,	
												SELECT_UFM1 ! Select UFM1,																																						
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,													
												DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SPIFLASHB_PROGRAM,	
													SPISELECT_UFM1 ! Select UFM1,																																					
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												I2CCHECK_PASSWORD ! Check PASSWORD,  
												I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												I2CFLASHB_PROGRAM,	
												I2CSELECT_UFM1 ! Select UFM1,																																					
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
												I2CDISABLE ! Exit the programming mode"	;	
												
	"JTAGI2C XFLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,				
													JTAGI2CSELECT_UFM1 ! Select UFM1,																																			
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													JTAGI2CSELECT_CFG1 ! Select CFG1,
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
													JTAGI2CDISABLE ! Exit the programming mode"	;	
																								
	"XFLASH CFG Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_PASSWORD ! Check PASSWORD,  
													FULL_FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													FULL_FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,			
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	
													
	"JTAGI2C XFLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;
																									
	"XFLASH UFM Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													FULL_UFM_PROGRAM_VERIFY,																												
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SPIUFM_PROGRAM_VERIFY,																												
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													I2CUFM_PROGRAM_VERIFY,																												
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
													I2CDISABLE ! Exit the programming mode"	;		
														
	"JTAGI2C XFLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,																												
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
														JTAGI2CDISABLE ! Exit the programming mode"	;
													
	"XFLASH Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_ERASE,
								FLASHB_ERASE,
								FLASHC_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHA_ERASE,
									SPIFLASHB_ERASE,
									SPIFLASHC_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password,
								I2CFLASHA_ERASE,
								I2CFLASHB_ERASE,
								I2CFLASHC_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	
														
	"JTAGI2C XFLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,
									JTAGI2CDISABLE ! Exit the programming mode"	;					
	
	"XFLASH CFG Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password,  
								FLASHACFG_ERASE,
								FLASHBCFG_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHACFG_ERASE,
									SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHACFG_ERASE,
								I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
									
	"XFLASH UFM Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_UFM_PASSWORD ! Check the Password,  
								FLASHAUFM_ERASE,
								FLASHBUFM_ERASE,
								FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SPIFLASHAUFM_ERASE,
									SPIFLASHBUFM_ERASE,
									SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								I2CFLASHAUFM_ERASE,
								I2CFLASHBUFM_ERASE,
								I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;
																
	"JTAGI2C XFLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"XFLASH Verify Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_VERIFY,
								FLASHB_VERIFY,	
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									SPICHECK_PASSWORD ! Check the Password, 
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,	
								I2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  		
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,	
									JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C XFLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;											
									
	"XFLASH UFM Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,									
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
											SPICHECK_UFM_PASSWORD ! Check the Password,  							
											SPIUFM_VERIFY_ONLY,	
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,	
									I2CDISABLE ! Exit the programming mode"	;											

	"JTAGI2C XFLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,	
										JTAGI2CDISABLE ! Exit the programming mode"	;								
			 									 									 									 										 										 
	"XFLASH Bypass" ="SVFINIT 	! Initialize"; 
								
	"Slave SPI XFLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C XFLASH Bypass" =	"I2CINIT 	! Initialize"; 	

	"JTAGI2C XFLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="INIT 	! Initialize"; 
															 	
	"XFLASH Verify ID" ="SVFINIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI XFLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C XFLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 	

	"JTAGI2C XFLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID ! Check the IDCODE"; 															

	"XFLASH Display ID" =	"SVFINIT, SAVE_ID";
	
	"Slave SPI XFLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C XFLASH Display ID" =	"I2CINIT, I2CSAVE_ID";
								 
	"JTAGI2C XFLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";

	"XFLASH Verify USERCODE" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									FLASH_ENABLE	! Enable the Flash access, 
									SELECT_CFG0	! Select CFG0,
									CFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
									SELECT_CFG1	! Select CFG1 Sector,
									CFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
									DISABLE ! Exit the programming mode";
	
	"Slave SPI XFLASH Verify USERCODE" =	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the Flash access, 
										SPISELECT_CFG0	! Select CFG0,
										SPICFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
										SPISELECT_CFG1	! Select CFG1,
										SPICFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
																				

	"I2C XFLASH Verify USERCODE" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CFLASH_ENABLE	! Enable the Flash access, 
									I2CSELECT_CFG0	! Select CFG0,
									I2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
									I2CSELECT_CFG1	! Select CFG1,
									I2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH Verify USERCODE" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access, 
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
										JTAGI2CSELECT_CFG0	! Select CFG0,
										JTAGI2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;																																			 												 	
	
	"XFLASH Refresh" =" SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI XFLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C XFLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C XFLASH Refresh" ="JTAGI2CINIT !Initialize,
								JTAGI2CREAD_ID !Check the IDCODE,
								JTAGI2CREFRESH_FUNCTION ! Refresh";													
	
	"XFLASH Secure CFG Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C XFLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																		
	"XFLASH Secure UFM Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";

	"Enable SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM,
					 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = " SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
								 CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,										 
								 CHECK_PASSWORD ! Check the Password, 
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;	
								 
	"Verify ID" = 		"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 

	"Verify ID with Password" = 		"SVFINIT 	! Initialize, 
										READ_ID ! Check the IDCODE, 
										CHECK_PASSWORD ! Check the Password"; 								 

	"Program Manufacturing Register" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  FLASH_SUDO_TRANSPARENT_ENABLE	! Enable the Manufacturing Mode,
									  CHECK_ENABLE_PASSWORD ! Check the Password, 								 
									  PROGRAM_MANUFACTURING_REGISTER ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;

	"XFLASH TransFR" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh"	;

	"Slave SPI XFLASH TransFR" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh"	;
	"I2C XFLASH TransFR" = "	I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CREFRESH_FUNCTION ! Refresh"	;
								
	"JTAGI2C XFLASH TransFR" = "	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CREFRESH_FUNCTION ! Refresh"	;	

	"XFLASH Program and TransFR" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										FULL_FLASHA_PROGRAM,
										FULL_FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode,									
										REFRESH_FUNCTION ! Refresh,
										SVF_VERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
										
	"Slave SPI XFLASH Program and TransFR" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SPIFLASHA_PROGRAM,
											SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode,									
											SPIREFRESH_FUNCTION ! Refresh,
											SVF_SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;		

	"I2C XFLASH Program and TransFR" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD,  
										I2CFLASHA_PROGRAM,
										I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode,									
										I2CREFRESH_FUNCTION ! Refresh,
										SVF_I2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
									
	"JTAGI2C XFLASH Program and TransFR" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE_REFRESH! Refresh,
											JTAGI2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;
										
	"FLASH Dry Run" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_PASSWORD ! Check PASSWORD, 
							SVF_CHECK_AUTHTICATE ! Check Authenticate,
							SVF_FLASHA_DRYRUN,
							SVF_FLASHB_DRYRUN"	;													
	
	"Slave SPI FLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									CHECK_PASSWORD ! Check PASSWORD, 
									SVF_SPICHECK_AUTHTICATE ! Check Authenticate,
									SVF_SPIFLASHA_DRYRUN,
									SVF_SPIFLASHB_DRYRUN"	;
	
	"I2C FLASH Dry Run" =	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_PASSWORD ! Check PASSWORD, 
							SVF_I2CCHECK_AUTHTICATE ! Check Authenticate,
							SVF_I2CFLASHA_DRYRUN,
							SVF_I2CFLASHB_DRYRUN"	;	
											
	"JTAGI2C FLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								SVF_JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;																			
	
	"XFLASH Dry Run" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_PASSWORD ! Check PASSWORD, 
							SVF_CHECK_AUTHTICATE ! Check Authenticate,
							SVF_FLASHA_DRYRUN,
							SVF_FLASHB_DRYRUN"	;													
	
	"Slave SPI XFLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									CHECK_PASSWORD ! Check PASSWORD, 
									SVF_SPICHECK_AUTHTICATE ! Check Authenticate,
									SVF_SPIFLASHA_DRYRUN,
									SVF_SPIFLASHB_DRYRUN"	;
	
	"I2C XFLASH Dry Run" =	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_PASSWORD ! Check PASSWORD, 
							SVF_I2CCHECK_AUTHTICATE ! Check Authenticate,
							SVF_I2CFLASHA_DRYRUN,
							SVF_I2CFLASHB_DRYRUN"	;	
									
	"JTAGI2C XFLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								SVF_JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;

	"Security Erase Encryption Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  AESKEY_ERASE ! Erase AESKEY Sector,
								  DISABLE ! Exit the programming mode" ;		

	"Slave SPI Security Erase Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SPIAESKEY_ERASE ! Erase AESKEY Sector,
								  SPIDISABLE ! Exit the programming mode" ;	
								  
	"I2C Security Erase Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,  
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  I2CAESKEY_ERASE ! Erase AESKEY Sector,
								  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Erase Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CAESKEY_ERASE ! Erase AESKEY Sector,
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"Security Erase Public Key" =	"SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable PROGRAM mode,	 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  PUBKEY_ERASE ! Erase PUBKEY Sector,        
								  DISABLE ! Exit the programming mode" ;	

	"Slave SPI Security Erase Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable PROGRAM mode,	 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SPIPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  SPIDISABLE ! Exit the programming mode" ;	

	"I2C Security Erase Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable PROGRAM mode,	 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  I2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  I2CDISABLE ! Exit the programming mode" ;	
		
	"JTAGI2C Security Erase Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable PROGRAM mode,	 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"Security Erase CSEC" ="SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
							SELECT_CSEC	! Select CSEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							CSEC_ERASE	! Erase CSEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase CSEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SPICSEC_ERASE	! Erase CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase CSEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									I2CCSEC_ERASE	! Erase CSEC central lock,
									I2CDISABLE	! Exit the programming mode";	
										
	"JTAGI2C Security Erase CSEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_ENABLE_PASSWORD! Check PASSWORD,  
									JTAGI2CSELECT_CSEC	! Select CSEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CCSEC_ERASE	! Erase CSEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";							  
								  
	"Security Erase USEC" ="SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_UFM_PASSWORD ! Check PASSWORD,  
							SELECT_USEC	! Select USEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							USEC_ERASE	! Erase USEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase USEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SPIUSEC_ERASE	! Erase USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase USEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									I2CUSEC_ERASE	! Erase USEC central lock,
									I2CDISABLE	! Exit the programming mode";		
										
	"JTAGI2C Security Erase USEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									JTAGI2CSELECT_USEC	! Select USEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CUSEC_ERASE	! Erase USEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";						  
								
	"FLASH Display USERCODE" =	"SVFINIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_ENABLE	! Enable the Flash access,
											SELECT_CFG0	! Select CFG0,
											SVF_SAVE_USERCODE,
											SELECT_CFG1	! Select CFG1,
											SVF_SAVE_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI FLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_ENABLE	! Enable the Flash access, 
											SPISELECT_CFG0	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C FLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_ENABLE	! Enable the Flash access,  
										I2CSELECT_CFG0	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE ! Exit the programming mode";
									
	"JTAGI2C FLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access,  
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";
	
	"XFLASH Display USERCODE" =	"SVFINIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
											SELECT_CFG0	! Select CFG0,
											SVF_SAVE_USERCODE,
											SELECT_CFG1	! Select CFG1,
											SVF_SAVE_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI XFLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash access, 
											SPISELECT_CFG0	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C XFLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,  
										I2CSELECT_CFG0	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE ! Exit the programming mode";										

	"JTAGI2C XFLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD,   
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";	
	
</Operation_List>
<Operation_List label="TurboOperation">
	"Bypass"	=	"INIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  														 															 			 							
</Operation_List>
<Operation_List label="ChainSVFOperation">	
	"Bypass"	=	"SVFINIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  																 			 		
</Operation_List>
<Operation_List label="SingleSVFOperationRevC">					 
	"SRAM Fast Configuration" = "	SVFINIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password, 
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,											
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM	! Program Fuse Map,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify Status Register,
										VERIFY_USERCODE		! Verify USERCODE,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "SVFINIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_PASSWORD ! Check the Password,   
										CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
										CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,											
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										CHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SRAM_VERIFY	! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_CONTROL1_2	! Program Control1 Register,
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_READ_LOCK ! Check the SRAM lock,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password, 
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_PASSWORD ! Check the Password,  
								CHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"SVFINIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "SVFINIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"SVFINIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SVF_SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"SVFINIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_PASSWORD ! Check the Password,  
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SVF_SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "SVFINIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure Plus" = " SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_PASSWORD ! Check the Password,  
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE_SVF ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"SVFINIT 	! Initialize";	
	

	"Slave SPI SRAM Fast Configuration" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,  
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIBURST_PROGRAM	! Program Fuse Map,
										SVF_SPIVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										SPISRAM_VERIFY_USERCODE		! Verify USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
								
	"Slave SPI SRAM Erase,Program,Verify" = "	SPIINIT 	! Initialize,   
										SPIREAD_ID	! Check the IDCODE,
										SPICHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										SPICHECK_PASSWORD ! Check the Password,
										SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										SPISRAM_ERASE	! Erase the SRAM, 
										SPIPROGRAM_CONTROL0	! Program Control Register0,
										SPIPROGRAM_CONTROL1	! Program Control Register1,
										SPISRAM_PROGRAM	! Program Fuse Map,
										SPISRAM_PROGRAM_USERCODE	! Program USERCODE,
										SPICHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										SPISRAM_VERIFY	! Verify Fuse Map, 
										SPIVERIFY_USERCODE		! Verify USERCODE, 
										SPIPROGRAM_CONTROL1_2	! Program Control1 Register,
										SPISRAMPROGRAM_DONE_BIT	! Program DONE bit,
										SPIDISABLE ! Exit the programming mode"	;									
										
	"Slave SPI SRAM Verify Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE, 
							SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
							SPIVERIFY_CONTROL0 ! Verify Control Register0,
							SPIVERIFY_CONTROL1 ! Verify Control Register1,
							SPISRAM_VERIFY	! Verify Fuse Map, 
							SPIVERIFY_USERCODE		! Verify USERCODE, 
		 			 		SPIDISABLE ! Exit the programming mode"	;
							
	"Slave SPI SRAM Erase Only"	=	"	SPIINIT 	! Initialize, 
							SPIREAD_ID	! Check the IDCODE,
							SPISRAM_ENABLE	! Enable SRAM programming mode, 
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							SPISRAM_ERASE	! Erase the SRAM, 
		 			 		SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI SRAM Verify ID" = 	"SPIINIT 	! Initialize, 
						 			SPIREAD_ID ! Check the IDCODE"; 

	"Slave SPI SRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";

	"Slave SPI SRAM Program Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
								 SPIPROGRAM_CONTROL0 ! Program Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Display Control Register0" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISAVE_CONTROL0 !Read Control Register 0,
					             SPIDISABLE";	

	"Slave SPI SRAM Program Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
					 			 SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             SPIDISABLE";

	"Slave SPI SRAM Display Control Register1" = "SPIINIT ! Initialize,
								 SPIREAD_ID	! Check the IDCODE,
								 SPISAVE_ID,
								 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             SPICHECK_PASSWORD ! Check the Password,  
					 			 SPISAVE_CONTROL1 !Read Control Register 1,
					             SPIDISABLE";	

	"Slave SPI SRAM Verify USERCODE"	=	"SPIINIT 	! Initialize, 
											 SPIREAD_ID	! Check the IDCODE,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPIVERIFY_USERCODE		! Verify USERCODE,
											 SPIDISABLE"; 
								
	"Slave SPI SRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPI_SVF_SAVE_USERCODE,
											 SPIDISABLE";								
								
	"Slave SPI SRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,  
								 		 SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPI_SVF_SAVE_USERCODE, 
										 SPIDISABLE";								
								
	"Slave SPI SRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID,
								 			 SPISAVE_STATUS";									
								
	"Slave SPI SRAM Refresh" = "SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";								
	
	"Slave SPI SRAM Secure Plus" = "SPIINIT !Initialize,
							SPIREAD_ID !Check the IDCODE,
							SPISRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 								             
							SPICHECK_PASSWORD ! Check the Password,  
							SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SPISRAM_SECURE_SVF ! Secure the SRAM,
							SPIDISABLE";
														
	"Slave SPI SRAM Bypass"	=	"SPIINIT 	! Initialize";	

					
	"I2C SRAM Fast Configuration" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CBURST_PROGRAM	! Program Fuse Map,
										SVF_I2CVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										I2CSRAM_VERIFY_USERCODE		! Verify USERCODE,
										I2CDISABLE ! Exit the programming mode"	;
										
	"I2C SRAM Erase,Program,Verify" = "	I2CINIT 	! Initialize,   
										I2CREAD_ID	! Check the IDCODE,
										I2CCHECK_AUTHTICATE_ENABLE ! Check Authentication Enable,
										I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
										I2CCHECK_PASSWORD ! Check the Password,  
										I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
										I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
										I2CSRAM_ERASE	! Erase the SRAM, 
										I2CPROGRAM_CONTROL0	! Program Control Register0,
										I2CPROGRAM_CONTROL1	! Program Control Register1,
										I2CSRAM_PROGRAM	! Program Fuse Map,
										I2CSRAM_PROGRAM_USERCODE	! Program USERCODE,
										I2CCHECK_SRAM_READ_LOCK ! Check the SRAM read Lock,
										I2CSRAM_VERIFY	! Verify Fuse Map, 
										I2CVERIFY_USERCODE		! Verify USERCODE,
										I2CPROGRAM_CONTROL1_2	! Program Control1 Register,										
										I2CSRAMPROGRAM_DONE_BIT	! Program DONE bit,
										I2CDISABLE ! Exit the programming mode"	;	
										
	"I2C SRAM Verify Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,  
							I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password,  
							I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
							I2CVERIFY_CONTROL0	! Verify Control Register0,
							I2CVERIFY_CONTROL1	! Verify Control Register1,
							I2CSRAM_VERIFY	! Verify Fuse Map, 
							I2CVERIFY_USERCODE		! Verify USERCODE, 
		 			 		I2CDISABLE ! Exit the programming mode"	;
							
	"I2C SRAM Erase Only"	=	"	I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CSRAM_ENABLE	! Enable SRAM programming mode, 
							I2CCHECK_PASSWORD ! Check the Password, 
							I2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							I2CSRAM_ERASE	! Erase the SRAM, 
		 			 		I2CDISABLE ! Exit the programming mode"	;

	"I2C SRAM Verify ID" = 	"I2CINIT 	! Initialize, 
						 	 I2CREAD_ID ! Check the IDCODE"; 

	"I2C SRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";

	"I2C SRAM Program Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
								 I2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Display Control Register0" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password,  
					 			 I2CSAVE_CONTROL0 !Read Control Register 0,
					             I2CDISABLE";	

	"I2C SRAM Program Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
					 			 I2CSRAM_ENABLE_NO_REFRESH	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
								 I2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             I2CDISABLE";

	"I2C SRAM Display Control Register1" = "I2CINIT ! Initialize,
								 I2CREAD_ID	! Check the IDCODE,
								 I2CSAVE_ID,
								 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
					             I2CCHECK_PASSWORD ! Check the Password, 
					 			 I2CSAVE_CONTROL1 !Read Control Register 1,
					             I2CDISABLE";	

	"I2C SRAM Verify USERCODE"	=	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_ENABLE,
									I2CVERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE"	; 
								
	"I2C SRAM Display USERCODE"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID,
									 I2CSRAM_TRANSPARENT_READ_ENABLE,
									 I2C_SVF_SAVE_USERCODE,
									 I2CDISABLE";								
								
	"I2C SRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
									 I2CCHECK_PASSWORD ! Check the Password, 
								     I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2C_SVF_SAVE_USERCODE, 
									 I2CDISABLE";								
								
	"I2C SRAM Read Status Register" = "I2CINIT ! Initialize,
					 			 		I2CREAD_ID	! Check the IDCODE,
					 			 		I2CSAVE_ID,
					 			 		I2CSAVE_STATUS";									
								
	"I2C SRAM Refresh" = " 	I2CINIT !Initialize,
							I2CREAD_ID !Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh";								
	
	
	"I2C SRAM Secure Plus" = "I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						I2CCHECK_PASSWORD ! Check the Password,  
						I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						I2CSRAM_SECURE_SVF ! Secure the SRAM,
						I2CDISABLE";
														
	"I2C SRAM Bypass"	=	"I2CINIT 	! Initialize";	
	
	"SRAM External Primary Dry Run" =	"SVFINIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										SVF_PRIMARY_DRYRUN"	;

	"Slave SPI SRAM External Primary Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Primary Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											SVF_I2CPRIMARY_DRYRUN"	;							

	"JTAGI2C SRAM External Primary Dry Run" =	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CPRIMARY_DRYRUN"	;
											
	"SRAM External Golden Dry Run" =	"SVFINIT 	! Initialize,  
										READ_ID	! Check the IDCODE, 
										SVF_GOLDEN_DRYRUN"	;

	"Slave SPI SRAM External Golden Dry Run" =	"NOT_SUPPORTED"	;
	
	"I2C SRAM External Golden Dry Run" =	"I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE,
											SVF_I2CGOLDEN_DRYRUN"	;	

	"JTAGI2C SRAM External Golden Dry Run" =	"JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CGOLDEN_DRYRUN"	;												
	
	"JTAGI2C SRAM Fast Configuration" = "JTAGI2CINIT 	! Initialize,   
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,
										JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,
										JTAGI2CSRAM_ERASE	! Erase the SRAM, 
										JTAGI2CBURST_PROGRAM	! Program Fuse Map,
										JTAGI2CVERIFY_SRAM_DONE_BIT ! Verify Status Register,
										JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"JTAGI2C SRAM Erase,Program,Verify" = "NOT_SUPPORTED"	;	
										
	"JTAGI2C SRAM Verify Only"	=	"NOT_SUPPORTED"	;
							
	"JTAGI2C SRAM Erase Only"	=	"	JTAGI2CINIT 	! Initialize, 
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
							JTAGI2CCHECK_PASSWORD ! Check the Password, 
							JTAGI2CCHECK_SRAM_ERASE_LOCK ! Check the SRAM Lock,
							JTAGI2CSRAM_ERASE	! Erase the SRAM, 
		 			 		JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C SRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
						 		 JTAGI2CREAD_ID ! Check the IDCODE"; 

	"JTAGI2C SRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";

	"JTAGI2C SRAM Program Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 JTAGI2CPROGRAM_CONTROL0 ! Program Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password,  
					 			 JTAGI2CSAVE_CONTROL0 !Read Control Register 0,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Program Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
					 			 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
								 JTAGI2CSRAM_PROGRAM_CONTROL1 ! Program Control Register 1,
					             JTAGI2CDISABLE";

	"JTAGI2C SRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
								 JTAGI2CREAD_ID	! Check the IDCODE,
								 JTAGI2CSAVE_ID,
								 JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 
					             JTAGI2CCHECK_PASSWORD ! Check the Password, 
					 			 JTAGI2CSAVE_CONTROL1 !Read Control Register 1,
					             JTAGI2CDISABLE";	

	"JTAGI2C SRAM Verify USERCODE"	=	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_ENABLE,
									JTAGI2CVERIFY_USERCODE		! Verify USERCODE,
									JTAGI2CDISABLE"	; 
								
	"JTAGI2C SRAM Display USERCODE"	=	"JTAGI2CINIT, 
									 JTAGI2CREAD_ID, 
									 JTAGI2CSAVE_ID,
									 JTAGI2CSRAM_ENABLE,
									 JTAGI2CSAVE_USERCODE,
									 JTAGI2CDISABLE";								
								
	"JTAGI2C SRAM Read and Save"	=	"NOT_SUPPORTED";								
								
	"JTAGI2C SRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
					 			 		JTAGI2CREAD_ID	! Check the IDCODE,
					 			 		JTAGI2CSAVE_ID,
					 			 		JTAGI2CSAVE_STATUS";									
								
	"JTAGI2C SRAM Refresh" = " 	JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";								
	
	
	"JTAGI2C SRAM Secure Plus" = "JTAGI2CINIT !Initialize,
						JTAGI2CREAD_ID !Check the IDCODE,
						JTAGI2CCHECK_PASSWORD ! Check the Password,  
						JTAGI2CSRAM_ENABLE	! Enable SRAM programming mode, 								             
						JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
						JTAGI2CSRAM_SECURE ! Secure the SRAM,
						JTAGI2CDISABLE";
														
	"JTAGI2C SRAM Bypass"	=	"JTAGI2CINIT 	! Initialize";	
	
	
	"XSRAM SEI Fast Program" 	= "SVFINIT 	! Initialize,   
									READ_ID	! Check the IDCODE,
									SRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									CHECK_PASSWORD ! Check the Password,  
								 	CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									BURST_PROGRAM	! Program Fuse Map,
									DISABLE ! Exit the programming mode,
									VERIFY_STATUS ! Verify Status Register"	;


	"XSRAM Verify ID" = 	"SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE"	; 


	"XSRAM Display ID" = "SVFINIT, READ_ID, SAVE_ID";	

	"XSRAM Display Control Register0" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SAVE_CONTROL0 ! Read Control Register 0,
								             DISABLE";	

	"XSRAM Display Control Register1" = "SVFINIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             CHECK_PASSWORD ! Check the Password,  
								 			 SAVE_CONTROL1 ! Read Control Register 1,
								             DISABLE";		

	"XSRAM Read and Save"	=	"SVFINIT, 
									 READ_ID, 
									 SAVE_ID, 
									 SRAM_TRANSPARENT_READ_ENABLE, 
									 CHECK_PASSWORD ! Check the Password,  
								 	 CHECK_SRAM_READ_LOCK ! Check the SRAM Lock,
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SVF_SAVE_USERCODE, 
									 DISABLE";			
	
	"XSRAM Display USERCODE"	=	"SVFINIT, 
										 READ_ID, 
										 SAVE_ID,
										 SRAM_TRANSPARENT_READ_ENABLE,
										 SVF_SAVE_USERCODE,
										 DISABLE";
		
	"XSRAM Read Status Register" = "SVFINIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 SAVE_STATUS,
							 			 DISABLE ! Exit the programming mode";	

	"XSRAM Refresh" = "	SVFINIT 	! Initialize,   
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh" ;

	"XSRAM Bypass"	=	"	SVFINIT 	! Initialize"	;
																	
	"Slave SPI XSRAM SEI Fast Program" 	= "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									SPICHECK_PASSWORD ! Check the Password,  
								 	SPICHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									SPIBURST_PROGRAM	! Program Fuse Map,
									SPIDISABLE ! Exit the programming mode"	;


	"Slave SPI XSRAM Verify ID" = 	"	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE"	; 


	"Slave SPI XSRAM Display ID" = "SPIINIT, SPIREAD_ID, SPISAVE_ID";	

	"Slave SPI XSRAM Display Control Register0" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									             SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL0 ! Read Control Register 0,
									             SPIDISABLE";	

	"Slave SPI XSRAM Display Control Register1" = "SPIINIT ! Initialize,
												 SPIREAD_ID	! Check the IDCODE,
												 SPISAVE_ID,
												 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
									             SPICHECK_PASSWORD ! Check the Password,  
									 			 SPISAVE_CONTROL1 ! Read Control Register 1,
									             SPIDISABLE";		

	"Slave SPI XSRAM Read and Save"	=	"SPIINIT, 
										 SPIREAD_ID, 
										 SPISAVE_ID, 
										 SPISRAM_TRANSPARENT_READ_ENABLE, 
										 SPICHECK_PASSWORD ! Check the Password,  
								 	     SPICHECK_SRAM_READ_LOCK ! Check the SRAM Lock,  
										 SPISAVE_CONTROL0,
										 SPISAVE_CONTROL1,
										 SPISRAM_SAVE_ARRAY, 
										 SPI_SVF_SAVE_USERCODE, 
										 SPIDISABLE";			
	
	"Slave SPI XSRAM Display USERCODE"	=	"SPIINIT, 
											 SPIREAD_ID, 
											 SPISAVE_ID,
											 SPISRAM_TRANSPARENT_READ_ENABLE,
											 SPI_SVF_SAVE_USERCODE,
											 SPIDISABLE";
		
	"Slave SPI XSRAM Read Status Register" = "SPIINIT ! Initialize,
								 			 SPIREAD_ID	! Check the IDCODE,
								 			 SPISAVE_ID,
								 			 SPISRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
								 			 SPISAVE_STATUS,
								 			 SPIDISABLE ! Exit the programming mode";	

	"Slave SPI XSRAM Refresh" = "	SPIINIT 	! Initialize,   
									SPIREAD_ID	! Check the IDCODE,
									SPIREFRESH_FUNCTION ! Refresh" ;

	"Slave SPI XSRAM Bypass"	=	"	SPIINIT 	! Initialize"	;
	
	"I2C XSRAM SEI Fast Program" 	= "	I2CINIT 	! Initialize,   
									I2CREAD_ID	! Check the IDCODE,
									I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									I2CCHECK_PASSWORD ! Check the Password,  
								 	I2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									I2CBURST_PROGRAM	! Program Fuse Map,
									I2CDISABLE ! Exit the programming mode"	;


	"I2C XSRAM Verify ID" = 	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE"	; 


	"I2C XSRAM Display ID" = "I2CINIT, I2CREAD_ID, I2CSAVE_ID";	

	"I2C XSRAM Display Control Register0" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             I2CCHECK_PASSWORD ! Check the Password,  
								 			 I2CSAVE_CONTROL0 ! Read Control Register 0,
								             I2CDISABLE";	

	"I2C XSRAM Display Control Register1" = "I2CINIT ! Initialize,
											 I2CREAD_ID	! Check the IDCODE,
											 I2CSAVE_ID,
											 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             I2CCHECK_PASSWORD ! Check the Password,  
								 			 I2CSAVE_CONTROL1 ! Read Control Register 1,
								             I2CDISABLE";		

	"I2C XSRAM Read and Save"	=	"I2CINIT, 
									 I2CREAD_ID, 
									 I2CSAVE_ID, 
									 I2CSRAM_TRANSPARENT_READ_ENABLE, 
								     I2CCHECK_PASSWORD ! Check the Password, 
									 I2CCHECK_SRAM_READ_LOCK ! Check the SRAM Lock, 
									 I2CSAVE_CONTROL0,
									 I2CSAVE_CONTROL1,
									 I2CSRAM_SAVE_ARRAY, 
									 I2C_SVF_SAVE_USERCODE, 
									 I2CDISABLE";			
	
	"I2C XSRAM Display USERCODE"	=	"I2CINIT, 
										I2CREAD_ID, 
										I2CSAVE_ID,
										I2CSRAM_TRANSPARENT_READ_ENABLE,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE";
		
	"I2C XSRAM Read Status Register" = "I2CINIT ! Initialize,
							 			 I2CREAD_ID	! Check the IDCODE,
							 			 I2CSAVE_ID,
							 			 I2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 I2CSAVE_STATUS,
							 			 I2CDISABLE ! Exit the programming mode";	

	"I2C XSRAM Refresh" = "	I2CINIT 	! Initialize,   
							I2CREAD_ID	! Check the IDCODE,
							I2CREFRESH_FUNCTION ! Refresh" ;

	"I2C XSRAM Bypass"	=	"	I2CINIT 	! Initialize"	;

	"JTAGI2C XSRAM SEI Fast Program" 	= "	JTAGI2CINIT 	! Initialize,   
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE	! Enable SRAM TRANSPARENT mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 	JTAGI2CCHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
									JTAGI2CBURST_PROGRAM	! Program Fuse Map,
									JTAGI2CDISABLE ! Exit the programming mode"	;


	"JTAGI2C XSRAM Verify ID" = 	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE"	; 


	"JTAGI2C XSRAM Display ID" = "JTAGI2CINIT, JTAGI2CREAD_ID, JTAGI2CSAVE_ID";	

	"JTAGI2C XSRAM Display Control Register0" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 			 JTAGI2CSAVE_CONTROL0 ! Read Control Register 0,
								             JTAGI2CDISABLE";	

	"JTAGI2C XSRAM Display Control Register1" = "JTAGI2CINIT ! Initialize,
											 JTAGI2CREAD_ID	! Check the IDCODE,
											 JTAGI2CSAVE_ID,
											 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM programming mode, 
								             JTAGI2CCHECK_PASSWORD ! Check the Password,  
								 			 JTAGI2CSAVE_CONTROL1 ! Read Control Register 1,
								             JTAGI2CDISABLE";		

	"JTAGI2C XSRAM Read and Save"	=	"NOT_SUPPORTED";			
	
	"JTAGI2C XSRAM Display USERCODE"	=	"JTAGI2CINIT, 
										JTAGI2CREAD_ID, 
										JTAGI2CSAVE_ID,
										JTAGI2CSRAM_TRANSPARENT_READ_ENABLE,
										JTAGI2CSAVE_USERCODE,
										JTAGI2CDISABLE";
		
	"JTAGI2C XSRAM Read Status Register" = "JTAGI2CINIT ! Initialize,
							 			 JTAGI2CREAD_ID	! Check the IDCODE,
							 			 JTAGI2CSAVE_ID,
							 			 JTAGI2CSRAM_TRANSPARENT_READ_ENABLE	! Enable SRAM TRANSPARENT programming mode,
							 			 JTAGI2CSAVE_STATUS,
							 			 JTAGI2CDISABLE ! Exit the programming mode";	

	"JTAGI2C XSRAM Refresh" = "JTAGI2CINIT 	! Initialize,   
							JTAGI2CREAD_ID	! Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh" ;

	"JTAGI2C XSRAM Bypass"	=	"JTAGI2CINIT 	! Initialize"	;
			 	
	"Program Feature Row" ="	SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,										
									FLASH_ENABLE	! Enable the programming mode,    
									CHECK_ENABLE_PASSWORD ! Check the Password, 											 
									SELECT_FEA ! Select Feature sector,
									CHECK_ERASE_LOCK ! Check the Erase Locks,
									CHECK_PROG_LOCK ! Check the Program Locks,
									SVF_FEATURE_ERASE	! Erase the Feature,
									CHECK_STATUS ! Read the status bit,
									CHECK_READ_LOCK ! Check the Central Read Locks,
									SVF_FEATURE_PROGRAM ! Program Feature Rows,
									CHECK_STATUS ! Read the status bit,
									DISABLE ! Exit the programming mode"	;	

	"Program Feature Row Secure" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_FEA ! Select Feature sector,
									    CHECK_ERASE_LOCK ! Check the Erase Locks,
										CHECK_PROG_LOCK ! Check the Program Locks,									
										SVF_FEATURE_ERASE	! Erase the Feature,
					 					CHECK_STATUS ! Read the status bit,
					 					CHECK_READ_LOCK ! Check the Central Read Locks,
										SVF_FEATURE_PROGRAM ! Program Feature Rows,
										CHECK_STATUS ! Read the status bit,
										SVF_PROGRAM_LOCK ! Program the local lock policy,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
										
	"Program Feature Row Lock" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode,
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,
										CHECK_PROG_LOCK ! Check the Locks,										
										SVF_PROGRAM_LOCK ! Program the lock information,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
																															
	"Erase Feature Row" ="	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the programming mode,
								CHECK_ENABLE_PASSWORD ! Check the Password, 									
								SELECT_FEA ! Select Feature sector,									
								CHECK_ERASE_LOCK ! Check the Locks,	
								SVF_FEATURE_ERASE	! Erase the Feature row, 
								CHECK_STATUS ! Read the status bit,
								DISABLE ! Exit the programming mode"	;

	"Read Feature Row" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SAVE_ID,
									FLASH_ENABLE	! Enable the programming mode,									
									CHECK_ENABLE_PASSWORD ! Check the Password, 									
								    SELECT_FEA ! Select Feature sector,	
									CHECK_READ_LOCK ! Check the Locks,														
									FEATURE_ROW_READ	! Read the Feature row, 
									DISABLE ! Exit the programming mode"	;
	
	"Program Control NV Register1" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,										
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SELECT_FEA ! Select Feature sector,	
										CHECK_READ_LOCK ! Check the Locks,	
										CHECK_PROG_LOCK ! Check the Locks,	
										CHECK_ERASE_LOCK ! Check the Locks,
										PROGRAM_CONTROL_NV1 ! Program Control Register1,
										CHECK_STATUS ! Read the status bit,
										DISABLE ! Exit the programming mode"	;
	
	"Display Control NV Register1" ="	SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SELECT_FEA ! Select Feature sector,		
										CHECK_READ_LOCK ! Check the Locks,
										SAVE_CONTROLNV1 ! Read Control Register1,
										DISABLE ! Exit the programming mode"	;		

	"Slave SPI Program Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
								        SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
									    SPICHECK_PROG_LOCK ! Check the Program Locks,
										SVF_SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SVF_SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	
										
	"Slave SPI Update Feature Row" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
										SPICHECK_PROG_LOCK ! Check the Program Locks,
										SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	

	"Slave SPI Program Feature Row Secure" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SPISELECT_FEA ! Select Feature sector,	
								        SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
									    SPICHECK_PROG_LOCK ! Check the Program Locks,									
										SVF_SPIFEATURE_ERASE	! Erase the Feature,
					 					SPICHECK_STATUS ! Read the status bit,
					 					SPICHECK_READ_LOCK ! Check the Central Read Locks,
										SVF_SPIFEATURE_PROGRAM ! Program Feature Rows,
										SPICHECK_STATUS ! Read the status bit,
										SPISVF_PROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;
										
	"Slave SPI Program Feature Row Lock" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,	
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPISVF_PROGRAM_LOCK ! Program the local lock policy,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;										

	"Slave SPI Erase Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode,
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 								
										SPISELECT_FEA ! Select Feature sector,	 											
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SVF_SPIFEATURE_ERASE	! Erase the Feature row,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;

	"Slave SPI Read Feature Row" =		"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID,
										SPIFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 
									    SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the key lock information,
										SPIFEATURE_ROW_READ	! Read the Feature row, 
										SPIDISABLE ! Exit the programming mode"	;
	
	"Slave SPI Program Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,										
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,	
										SPICHECK_PROG_LOCK ! Check the Locks,	
										SPICHECK_ERASE_LOCK ! Check the Locks,
										SPIPROGRAM_CONTROL_NV1 ! Program Control Register1,
										SPICHECK_STATUS ! Read the status bit,
										SPIDISABLE ! Exit the programming mode"	;	
	
	"Slave SPI Display Control NV Register1" ="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the programming mode, 										
										SPICHECK_ENABLE_PASSWORD ! Check the Password, 											 
										SPISELECT_FEA ! Select Feature sector,
										SPICHECK_READ_LOCK ! Check the Locks,
										SPISAVE_CONTROLNV1 ! Read Control Register1,
										SPIDISABLE ! Exit the programming mode"	;		

	"I2C Program Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										SVF_I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;	

	"I2C Update Feature Row" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,		
										I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										I2CCHECK_PROG_LOCK ! Check the Program Locks,
										I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CFEATUREDISABLE ! Exit the programming mode"	;

	"I2C Program Feature Row Secure" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										SVF_I2CFEATURE_ERASE	! Erase the Feature,
					 					I2CFEATURE_PROGRAM ! Program Feature Rows,
										I2CSVF_PROGRAM_NEW_ADDRESS_LOCK ! Program the local lock policy,
										I2CFEATUREDISABLE ! Exit the programming mode"	;
										
	"I2C Program Feature Row Lock" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_FEA ! Select Feature sector,	
										I2CCHECK_PROG_LOCK ! Check the Locks,										
										I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
										I2CCHECK_STATUS ! Read the status bit,
										I2CDISABLE ! Exit the programming mode"	;										

	"I2C Erase Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode,
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										I2CSELECT_FEA ! Select Feature sector,	 											
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										SVF_I2CFEATURE_ERASE	! Erase the Feature row,
										I2CDISABLE_DEFAULT ! Exit the programming mode"	;

	"I2C Read Feature Row" =		"I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 
									    I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the key lock information,
										I2CFEATURE_ROW_READ	! Read the Feature row, 
										I2CDISABLE ! Exit the programming mode"	;
	
	"I2C Program Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,										
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,	
										I2CCHECK_PROG_LOCK ! Check the Locks,	
										I2CCHECK_ERASE_LOCK ! Check the Locks,
										I2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
										I2CCHECK_STATUS ! Read the status bit,
										I2CDISABLE ! Exit the programming mode"	;	
	
	"I2C Display Control NV Register1" ="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CFLASH_ENABLE	! Enable the programming mode, 										
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
										I2CSELECT_FEA ! Select Feature sector,
										I2CCHECK_READ_LOCK ! Check the Locks,
										I2CSAVE_CONTROLNV1 ! Read Control Register1,
										I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program Feature Row" ="	JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,										
										JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
										JTAGI2CSELECT_FEA ! Select Feature sector,		
										JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
										JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
										JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
										JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;

	"JTAGI2C Update Feature Row" ="	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,										
									JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
									JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
									JTAGI2CSELECT_FEA ! Select Feature sector,		
									JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
									JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
									JTAGI2CFEATURE_ERASE	! Erase the Feature,
									JTAGI2CCHECK_STATUS ! Read the status bit,
									JTAGI2CFEATURE_PROGRAM ! Program Feature Rows,
									JTAGI2CFEATURECHECK_STATUS ! Read the status bit,
									JTAGI2CFEATUREDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C Program Feature Row Lock" ="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode,
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,										
											JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;										

	"JTAGI2C Erase Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the programming mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 									
										JTAGI2CSELECT_FEA ! Select Feature sector,	 											
										JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
										JTAGI2CFEATURE_ERASE	! Erase the Feature row,
										JTAGI2CCHECK_STATUS ! Read the status bit,
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Read Feature Row" =		"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable XPROGRAM mode,										
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 
										JTAGI2CSELECT_FEA ! Select Feature sector,
										JTAGI2CCHECK_READ_LOCK ! Check the key lock information,
										JTAGI2CFEATURE_ROW_READ	! Read the Feature row, 
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C Program Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,										
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password, 											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,	
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,	
											JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_CONTROL_NV1 ! Program Control Register1,
											JTAGI2CCHECK_STATUS ! Read the status bit,
											JTAGI2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C Display Control NV Register1" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 										
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_FEA ! Select Feature sector,
											JTAGI2CCHECK_READ_LOCK ! Check the Locks,
											JTAGI2CSAVE_CONTROLNV1 ! Read Control Register1,
											JTAGI2CDISABLE ! Exit the programming mode"	;										
	
	"Security Program Auth Done FlashA" =   "SVFINIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash, 												 
										      SELECT_CFG0 ! Select Flash A,
											  PROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashA" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash, 	 											 
										      SPISELECT_CFG0 ! Select Flash A,
											  SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;

	"I2C Security Program Auth Done FlashA" =   "I2CINIT 	! Initialize, 
												  I2CREAD_ID	! Check the IDCODE, 
												  I2CFLASH_ENABLE	! Enable the Flash, 	 											 
										          I2CSELECT_CFG0 ! Select Flash A,
												  I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
												  I2CDISABLE ! Exit the programming mode" ;
												  
	"JTAGI2C Security Program Auth Done FlashA" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  											  
													  JTAGI2CSELECT_CFG0 ! Select Flash A,
													  JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;												  											  
											  
	"Security Program Auth Done FlashB" =   "SVFINIT 	! Initialize, 
											  READ_ID	! Check the IDCODE, 
											  FLASH_ENABLE	! Enable the Flash, 											 
										      SELECT_CFG1 ! Select Flash B,
											  PROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Auth Done FlashB" =   "SPIINIT 	! Initialize, 
											  SPIREAD_ID	! Check the IDCODE, 
											  SPIFLASH_ENABLE	! Enable the Flash,  											 
										      SPISELECT_CFG1 ! Select Flash B,
											  SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Auth Done FlashB" =   "I2CINIT 	! Initialize, 
											  I2CREAD_ID	! Check the IDCODE, 
											  I2CFLASH_ENABLE	! Enable the Flash, 										 
										      I2CSELECT_CFG1 ! Select Flash B,
											  I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
											  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Program Auth Done FlashB" =   "JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	 
													  JTAGI2CSELECT_CFG1 ! Select Flash B,
													  JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,         
													  JTAGI2CDISABLE ! Exit the programming mode" ;	
											  
	"Security Program Password Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  SELECT_FEA ! Select Feature Sector,
								  CHECK_PROG_LOCK ! Check the Locks,						
								  SVF_PROGRAM_PASSWORD ! Program the Password key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Password Key Secure" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks,
								  SVF_PROGRAM_PASSWORD ! Program the Password key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  CHECK_STATUS ! Read the status bit,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Password Key Lock" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_FEA ! Select Feature Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;

	"Security Program Encryption Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_PROGRAM_AESKEY ! Program the Encryption key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Encryption Key Secure" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_AESKEY ! Select AESKEY Sector, 	
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_AESKEY_ERASE ! Erase AESKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_PROGRAM_AESKEY ! Program the Encryption key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
	
	"Security Program Encryption Key Lock" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_AESKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;	

	"Slave SPI Security Program Password Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPISELECT_FEA ! Select Feature Sector,
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SVF_SPIPROGRAM_PASSWORD ! Program the Password key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Password Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SVF_SPIPROGRAM_PASSWORD ! Program the Password key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Password Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_SPIPROGRAM_AESKEY ! Program the Encryption key,        
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Encryption Key Secure" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_AESKEY ! Select AESKEY Sector, 
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_SPIAESKEY_ERASE	! Erase AESKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_SPIPROGRAM_AESKEY ! Program the Encryption key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Encryption Key Lock" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
	
	"I2C Security Program Password Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CSELECT_FEA ! Select Feature Sector,
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key,        
								  I2CDISABLE ! Exit the programming mode" ;
									 
	"JTAGI2C Security Program Password Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,  	
											  JTAGI2CSELECT_FEA ! Select Feature Sector,
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											  JTAGI2CPROGRAM_PASSWORD ! Program the Password key,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Password Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  I2CPROGRAM_PASSWORD ! Program the Password key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash, 	 
													  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
													  JTAGI2CPROGRAM_PASSWORD ! Program the Password key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Password Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Password Key Lock" ="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
												  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_I2CPROGRAM_AESKEY ! Program the Encryption key,         
								  I2CDISABLE ! Exit the programming mode" ;
								  
	"JTAGI2C Security Program Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
											  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Encryption Key Secure" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 	
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_I2CAESKEY_ERASE	! Erase AESKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_I2CPROGRAM_AESKEY ! Program the Encryption key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Encryption Key Secure" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 	
													  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
													  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
													  JTAGI2CAESKEY_ERASE	! Erase AESKEY Sector,
													  JTAGI2CPROGRAM_AESKEY ! Program the Encryption key, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Encryption Key Lock" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_AESKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Program Encryption Key Lock" ="JTAGI2CINIT 	! Initialize, 
													  JTAGI2CREAD_ID	! Check the IDCODE, 
													  JTAGI2CFLASH_ENABLE	! Enable the Flash,
													  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
													  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector, 								  
													  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
													  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
													  JTAGI2CDISABLE ! Exit the programming mode" ;		
	
	"Security Program Public Key" =	"SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_PROGRAM_PUBKEY ! Program the Public key,         
								  DISABLE ! Exit the programming mode" ;

	"Security Program Public Key Secure"="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password, 
								  SELECT_PUBKEY ! Select AESKEY Sector, 
								  CHECK_ERASE_LOCK ! Check the Erase Locks,
								  CHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_PUBKEY_ERASE ! Erase PUBKEY Sector,
								  CHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_PROGRAM_PUBKEY ! Program the Public key, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  
	"Security Program Public Key Lock"="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash,
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector, 								  
								  CHECK_PROG_LOCK ! Check the Locks, 
								  SVF_PROGRAM_LOCK ! Program the local lock policy,
								  DISABLE ! Exit the programming mode" ;
								  								  
	
	"Slave SPI Security Program Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_SPIPROGRAM_PUBKEY ! Program the Public key,         
								  SPIDISABLE ! Exit the programming mode" ;

	"Slave SPI Security Program Public Key Secure"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,    
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 
								  SPICHECK_ERASE_LOCK ! Check the Erase Locks,		
								  SPICHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_SPIPUBKEY_ERASE	! Erase PUBKEY Sector,
								  SPICHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_SPIPROGRAM_PUBKEY ! Program the Public key, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program Public Key Lock"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks, 
								  SPISVF_PROGRAM_LOCK ! Program the local lock policy,
								  SPIDISABLE ! Exit the programming mode" ;	
	"I2C Security Program Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_I2CPROGRAM_PUBKEY ! Program the Public key,         
								  I2CDISABLE ! Exit the programming mode" ;
																  
	"JTAGI2C Security Program Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
											  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
											  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
											  JTAGI2CPROGRAM_PUBKEY ! Program the Public key,         
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"I2C Security Program Public Key Secure"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 
								  I2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
								  I2CCHECK_PROG_LOCK ! Check the Program Locks,
								  SVF_I2CPUBKEY_ERASE	! Erase PUBKEY Sector,
								  I2CCHECK_READ_LOCK ! Check the Central Read Locks,	
								  SVF_I2CPROGRAM_PUBKEY ! Program the Public key, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program Public Key Secure"="JTAGI2CINIT 	! Initialize, 
												  JTAGI2CREAD_ID	! Check the IDCODE, 
												  JTAGI2CFLASH_ENABLE	! Enable the Flash,
												  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
												  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 
												  JTAGI2CCHECK_ERASE_LOCK ! Check the Erase Locks,		
												  JTAGI2CCHECK_PROG_LOCK ! Check the Program Locks,
												  JTAGI2CPUBKEY_ERASE	! Erase PUBKEY Sector,
												  JTAGI2CPROGRAM_PUBKEY ! Program the Public key, 
												  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
												  JTAGI2CDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program Public Key Lock"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks, 
								  I2CSVF_PROGRAM_LOCK ! Program the local lock policy,
								  I2CDISABLE ! Exit the programming mode" ;			

	"JTAGI2C Security Program Public Key Lock"="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash,
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector, 								  
											  JTAGI2CCHECK_PROG_LOCK ! Check the Locks, 
											  JTAGI2CPROGRAM_LOCK ! Program the local lock policy,
											  JTAGI2CDISABLE ! Exit the programming mode" ;							  
	
	"Security Program TraceID"="SVFINIT 	! Initialize, 
							    READ_ID	! Check the IDCODE,
							    FLASH_ENABLE	! Enable the programming mode,
							    CHECK_ENABLE_PASSWORD ! Check the Password, 
							    SELECT_FEA ! Select Feature Sector, 								  
							    CHECK_PROG_LOCK ! Check the Locks,
							    SVF_PROGRAM_TRACEID ! Program the TraceID,
							    DISABLE ! Exit the programming mode" ;
	
	"Slave SPI Security Program TraceID"="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE,
								  SPIFLASH_ENABLE	! Enable the programming mode,
								  SPICHECK_ENABLE_PASSWORD ! Check the Password, 
								  SPISELECT_FEA ! Select Feature Sector, 								  
								  SPICHECK_PROG_LOCK ! Check the Locks,
								  SVF_SPIPROGRAM_TRACEID ! Program the TraceID,
								  SPIDISABLE ! Exit the programming mode" ;
	
	"I2C Security Program TraceID"="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE,
								  I2CFLASH_ENABLE	! Enable the programming mode,
								  I2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
								  I2CSELECT_FEA ! Select Feature Sector, 								  
								  I2CCHECK_PROG_LOCK ! Check the Locks,
								  SVF_I2CPROGRAM_TRACEID ! Program the TraceID,
								  I2CDISABLE ! Exit the programming mode" ;

	"JTAGI2C Security Program TraceID"="JTAGI2CINIT 	! Initialize, 
									  JTAGI2CREAD_ID	! Check the IDCODE,
									  JTAGI2CFLASH_ENABLE	! Enable the programming mode,
									  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Key Lock
									  JTAGI2CSELECT_FEA ! Select Feature Sector, 								  
									  JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
									  JTAGI2CPROGRAM_TRACEID ! Program the TraceID,
									  JTAGI2CDISABLE ! Exit the programming mode" ;									  
																			
	"Security Program Authentication Mode"="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE,
										SAVE_ID, 
										FLASH_ENABLE	! Enable the programming mode, 
										CHECK_ENABLE_PASSWORD ! Check the Password, 											 
					 					SELECT_PUBKEY ! Select PUBKEY Sector, 								  
										CHECK_PROG_LOCK ! Check the Locks,
										PROGRAM_AUTHENTICATION ! Program Authentication Mode,                             
										DISABLE ! Exit the programming mode"	;
										
	"Slave SPI Security Program Authentication Mode"="	SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPISAVE_ID, 
										SPIFLASH_ENABLE	! Enable the programming mode, 
										SPICHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					SPISELECT_PUBKEY ! Select PUBKEY Sector, 								  
										SPICHECK_PROG_LOCK ! Check the Locks,
										SPIPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Security Program Authentication Mode"="	I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID, 
										I2CFLASH_ENABLE	! Enable the programming mode, 
										I2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
					 					I2CSELECT_PUBKEY ! Select Feature Sector, 								  
										I2CCHECK_PROG_LOCK ! Check the Locks,
										I2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
										I2CDISABLE ! Exit the programming mode"	;		

	"JTAGI2C Security Program Authentication Mode"="	JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE,
											JTAGI2CSAVE_ID, 
											JTAGI2CFLASH_ENABLE	! Enable the programming mode, 
											JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  											 
											JTAGI2CSELECT_PUBKEY ! Select Feature Sector, 								  
											JTAGI2CCHECK_PROG_LOCK ! Check the Locks,
											JTAGI2CPROGRAM_AUTHENTICATION ! Program Authentication Mode,                              
											JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"FLASH Recovery Erase Only" =	"SVFINIT 	! Initialize, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE_READ_ID	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,
									SVF_FLASHA_ERASE,
									SVF_FLASHB_ERASE,
									SVF_FLASHC_ERASE,								
									DISABLE ! Exit the programming mode"	;	
																	
	"FLASH Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_PASSWORD ! Check the Password,
								SVF_FLASHA_ERASE,
								SVF_FLASHB_ERASE,
								SVF_FLASHC_ERASE,								
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI Recovery Erase Only"	=	"SPIINIT 	! Initialize, 
									SPIFLASH_ENABLE_READ_ID	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password, 
									SVF_SPIFLASHA_ERASE,
									SVF_SPIFLASHB_ERASE,
									SVF_SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
									
	"Slave SPI FLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password,
									SVF_SPIFLASHA_ERASE,
									SVF_SPIFLASHB_ERASE,
									SVF_SPIFLASHC_ERASE,																	
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C Recovery Erase Only"	=	"I2CINIT 	! Initialize, 
									I2CFLASH_ENABLE_READ_ID	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password, 
									SVF_I2CFLASHA_ERASE,
									SVF_I2CFLASHB_ERASE,
									SVF_I2CFLASHC_ERASE,
				 			 		I2CDISABLE ! Exit the programming mode"	;
				 			 		
	"I2C FLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password, 
								SVF_I2CFLASHA_ERASE,
								SVF_I2CFLASHB_ERASE,
								SVF_I2CFLASHC_ERASE,								
								I2CDISABLE ! Exit the programming mode"	;			

	"JTAGI2C FLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_PASSWORD ! Check the Password,
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,								
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Erase Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_PASSWORD ! Check the Password,  
									SVF_FLASHACFG_ERASE,
									SVF_FLASHBCFG_ERASE,
									DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_PASSWORD ! Check the Password,  
									SVF_SPIFLASHACFG_ERASE,
									SVF_SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_PASSWORD ! Check the Password,  
								SVF_I2CFLASHACFG_ERASE,
								SVF_I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"FLASH UFM Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash,
								CHECK_UFM_PASSWORD ! Check the Password,  
								SVF_FLASHAUFM_ERASE,
								SVF_FLASHBUFM_ERASE,
								SVF_FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI FLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SVF_SPIFLASHAUFM_ERASE,
									SVF_SPIFLASHBUFM_ERASE,
									SVF_SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_ENABLE	! Enable the Flash,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								SVF_I2CFLASHAUFM_ERASE,
								SVF_I2CFLASHBUFM_ERASE,
								SVF_I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;				

	"JTAGI2C FLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;

	"FLASH Version Rollback Protection" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD	! Check PASSWORD, 
										SVF_FLASHA_PROGRAM,
										SELECT_CFG0 ! Select Flash A,
										PROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										SVF_FLASHB_PROGRAM,	
										SELECT_CFG1 ! Select Flash B,
										PROGRAM_AUTH_DONE_B ! Program the Auth Done, 									
										DISABLE ! Exit the programming mode,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
										
	"Slave SPI FLASH Version Rollback Protection" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SVF_SPIFLASHA_PROGRAM,
											SPISELECT_CFG0 ! Select Flash A,
											SPIPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											SVF_SPIFLASHB_PROGRAM,	
											SPISELECT_CFG1 ! Select Flash B,
											SPIPROGRAM_AUTH_DONE_B ! Program the Auth Done,												
											SPIDISABLE ! Exit the programming mode"	;

	"I2C FLASH Version Rollback Protection" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										SVF_I2CFLASHA_PROGRAM,
										I2CSELECT_CFG0 ! Select Flash A,
										I2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
										SVF_I2CFLASHB_PROGRAM,	
										I2CSELECT_CFG1 ! Select Flash B,
										I2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
										I2CDISABLE ! Exit the programming mode"	;																							

	"JTAGI2C FLASH Version Rollback Protection" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CSELECT_CFG0 ! Select Flash A,
											JTAGI2CPROGRAM_AUTH_DONE_A ! Program the Auth Done,   
											JTAGI2CFLASHB_PROGRAM,
											JTAGI2CSELECT_CFG1 ! Select Flash B,
											JTAGI2CPROGRAM_AUTH_DONE_B ! Program the Auth Done,											
											JTAGI2CDISABLE ! Exit the programming mode"	;
										
	"FLASH Erase,Program,Verify" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										IO_STATE ! Program Bscan register,
										FLASH_ENABLE	! Enable the Flash,
										CHECK_PASSWORD ! Check PASSWORD,
										SVF_FLASHA_PROGRAM,
										SVF_FLASHB_PROGRAM,										
										DISABLE ! Exit the programming mode,
										SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";										
												
	"Slave SPI FLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash,
											SPICHECK_PASSWORD ! Check PASSWORD, 
											SVF_SPIFLASHA_PROGRAM,
											SVF_SPIFLASHB_PROGRAM,													
											SPIDISABLE ! Exit the programming mode"	;	

	"I2C FLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_ENABLE	! Enable the Flash,
										I2CCHECK_PASSWORD ! Check PASSWORD,
										SVF_I2CFLASHA_PROGRAM,
										SVF_I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_ENABLE	! Enable the Flash,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH Verify Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								IO_STATE ! Program Bscan register,
								FLASH_ENABLE	! Enable the Flash, 
								CHECK_PASSWORD ! Check the Password, 
								FLASHA_VERIFY,
								FLASHB_VERIFY,
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_ENABLE	! Enable the Flash, 
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,
								I2CDISABLE ! Exit the programming mode"	;																															

	"JTAGI2C FLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash, 
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,
									JTAGI2CDISABLE ! Exit the programming mode"	;	
								
	"FLASH CFG Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_ENABLE	! Enable the Flash, 
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C FLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
										
	"FLASH UFM Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI FLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash, 
									SPICHECK_UFM_PASSWORD ! Check the Password,  							
									SPIUFM_VERIFY_ONLY,
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C FLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,
									I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,
										JTAGI2CDISABLE ! Exit the programming mode"	;	
									
	"FLASH CFG Erase,Program,Verify" ="SVFINIT 	! Initialize, 
											READ_ID	! Check the IDCODE, 
											IO_STATE ! Program Bscan register,
											FLASH_ENABLE	! Enable the Flash,
											CHECK_PASSWORD ! Check PASSWORD,  
											SVF_FLASHA_CFG_PROGRAM,
											SVF_FLASHB_CFG_PROGRAM,											
											DISABLE ! Exit the programming mode";
													
	"Slave SPI FLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_CFG_PROGRAM,
													SVF_SPIFLASHB_CFG_PROGRAM,													
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C FLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											SVF_I2CFLASHA_CFG_PROGRAM,
											SVF_I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"FLASH UFM Erase,Program,Verify" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												SVF_UFM_PROGRAM_VERIFY,
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI FLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C FLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_ENABLE	! Enable the Flash,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											SVF_I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;

	"JTAGI2C FLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_ENABLE	! Enable the Flash,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;
											
	"FLASH Erase,Program,Verify,Secure" ="	INIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												IO_STATE ! Program Bscan register,
												FLASH_ENABLE	! Enable the Flash,
												CHECK_PASSWORD ! Check PASSWORD,
												SVF_FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0, 
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												SVF_FLASHB_PROGRAM,		
												SELECT_UFM1 ! Select UFM1,																																					
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,												
												DISABLE ! Exit the programming mode,
												SVF_VERIFY_SRAM_DONE_BIT ! Verify SRAM DONE Bit";
																									
	
	"Slave SPI FLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SVF_SPIFLASHB_PROGRAM,	
													SPISELECT_UFM1 ! Select UFM1,																																					
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_ENABLE	! Enable the Flash,
												I2CCHECK_PASSWORD ! Check PASSWORD,
												SVF_I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												SVF_I2CFLASHB_PROGRAM,	
												I2CSELECT_UFM1 ! Select UFM1,																																					
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																					
												I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C FLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_ENABLE	! Enable the Flash,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,	
													JTAGI2CSELECT_UFM1	! Select UFM1,																																					
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													JTAGI2CSELECT_CFG1 ! Select CFG1,
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																					
													JTAGI2CDISABLE ! Exit the programming mode"	;												
																							
	"FLASH CFG Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_PASSWORD ! Check PASSWORD,  
													SVF_FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													SVF_I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	
																							
	"JTAGI2C FLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;
																							
	"FLASH UFM Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													IO_STATE ! Program Bscan register,
													FLASH_ENABLE	! Enable the Flash,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_UFM_PROGRAM_VERIFY,																												
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI FLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_ENABLE	! Enable the Flash,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_SPIUFM_PROGRAM_VERIFY,																												
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C FLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_ENABLE	! Enable the Flash,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_I2CUFM_PROGRAM_VERIFY,																												
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,													 										
													I2CDISABLE ! Exit the programming mode"	;		

	"JTAGI2C FLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_ENABLE	! Enable the Flash,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,	
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													 										
														JTAGI2CDISABLE ! Exit the programming mode"	;	
													
	"FLASH Refresh" =" SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI FLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C FLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C FLASH Refresh" ="JTAGI2CINIT !Initialize,
							JTAGI2CREAD_ID !Check the IDCODE,
							JTAGI2CREFRESH_FUNCTION ! Refresh";												
	
	"Security Lock Ports Interface" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Lock Ports Interface" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Lock Ports Interface" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C Security Lock Ports Interface" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_PORTS_LOCK	! Program CSEC ports lock,
										JTAGI2CDISABLE	! Exit the programming mode";
									
	"FLASH Secure CFG Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																		
	"FLASH Secure UFM Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									IO_STATE ! Program Bscan register,
									FLASH_ENABLE	! Enable the Flash,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI FLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C FLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C FLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_ENABLE	! Enable the Flash,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
									
	"FLASH Bypass" ="SVFINIT 	! Initialize"; 
								
	"Slave SPI FLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C FLASH Bypass" =	"I2CINIT 	! Initialize"; 

	"JTAGI2C FLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="SVFINIT 	! Initialize"; 
															 	
	"FLASH Verify ID" ="SVFINIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI FLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C FLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 																

	"JTAGI2C FLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
								 JTAGI2CREAD_ID ! Check the IDCODE"; 							 
							 
	"FLASH Display ID" =	"SVFINIT, SAVE_ID";
	
	"Slave SPI FLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C FLASH Display ID" =	"I2CINIT, I2CSAVE_ID";	
								 
	"JTAGI2C FLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";																					
	
	"XFLASH Erase,Program,Verify" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										SVF_FLASHA_PROGRAM,
										SVF_FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode";										
												
	"Slave SPI XFLASH Erase,Program,Verify" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD, 
											SVF_SPIFLASHA_PROGRAM,
											SVF_SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH Erase,Program,Verify" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD, 
										SVF_I2CFLASHA_PROGRAM,
										SVF_I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode"	;	
										
	"JTAGI2C XFLASH Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE ! Exit the programming mode"	;																						

	"XFLASH CFG Erase,Program,Verify" ="SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD,  
												SVF_FLASHA_CFG_PROGRAM,
												SVF_FLASHB_CFG_PROGRAM,										
												DISABLE ! Exit the programming mode";
													
	"Slave SPI XFLASH CFG Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_CFG_PROGRAM,
													SVF_SPIFLASHB_CFG_PROGRAM,														
													SPIDISABLE ! Exit the programming mode"	;	

	"I2C XFLASH CFG Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_PASSWORD ! Check PASSWORD,  
											SVF_I2CFLASHA_CFG_PROGRAM,
											SVF_I2CFLASHB_CFG_PROGRAM,																							
											I2CDISABLE ! Exit the programming mode"	;
											
	"JTAGI2C XFLASH CFG Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
												JTAGI2CFLASHA_CFG_PROGRAM,
												JTAGI2CFLASHB_CFG_PROGRAM,																							
												JTAGI2CDISABLE ! Exit the programming mode"	;
																																															
	"XFLASH UFM Erase,Program,Verify" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_UFM_PASSWORD ! Check PASSWORD,  
												SVF_UFM_PROGRAM_VERIFY,																 																	
												DISABLE ! Exit the programming mode"	;
																																															
	"Slave SPI XFLASH UFM Erase,Program,Verify" ="	SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_SPIUFM_PROGRAM_VERIFY,																 																	
													SPIDISABLE ! Exit the programming mode"	;
													
	"I2C XFLASH UFM Erase,Program,Verify" ="I2CINIT 	! Initialize, 
											I2CREAD_ID	! Check the IDCODE, 
											I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
											SVF_I2CUFM_PROGRAM_VERIFY,																	 																	
											I2CDISABLE ! Exit the programming mode"	;	
												
	"JTAGI2C XFLASH UFM Erase,Program,Verify" ="JTAGI2CINIT 	! Initialize, 
												JTAGI2CREAD_ID	! Check the IDCODE, 
												JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
												JTAGI2CUFM_PROGRAM_VERIFY,																	 																	
												JTAGI2CDISABLE ! Exit the programming mode"	;												
																																			
	"XFLASH Erase,Program,Verify,Secure" ="	SVFINIT 	! Initialize, 
												READ_ID	! Check the IDCODE, 
												FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												CHECK_PASSWORD ! Check PASSWORD, 
												SVF_FLASHA_PROGRAM,
												SELECT_UFM0 ! Select UFM0, 
												UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												SELECT_CFG0 ! Select CFG0,
												CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												SVF_FLASHB_PROGRAM,		
												SELECT_UFM1 ! Select UFM1,																																					
												UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												SELECT_CFG1 ! Select CFG1,
												CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,													
												DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_PROGRAM,
													SPISELECT_UFM0 ! Select UFM0,
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,
													SPISELECT_CFG0 ! Select CFG0,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													SVF_SPIFLASHB_PROGRAM,		
													SPISELECT_UFM1 ! Select UFM1,																																				
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_CFG1 ! Select CFG1,
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,		
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
												I2CREAD_ID	! Check the IDCODE, 
												I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
												I2CCHECK_PASSWORD ! Check PASSWORD,
												SVF_I2CFLASHA_PROGRAM,
												I2CSELECT_UFM0 ! Select UFM0,
												I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
												I2CSELECT_CFG0 ! Select CFG0,
												I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
												SVF_I2CFLASHB_PROGRAM,	
												I2CSELECT_UFM1 ! Select UFM1,																																						
												I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
												I2CSELECT_CFG1 ! Select CFG1,
												I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
												I2CDISABLE ! Exit the programming mode"	;	
												
	"JTAGI2C XFLASH Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
													JTAGI2CREAD_ID	! Check the IDCODE, 
													JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
													JTAGI2CFLASHA_PROGRAM,
													JTAGI2CSELECT_UFM0 ! Select UFM0,
													JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy, 
													JTAGI2CSELECT_CFG0 ! Select CFG0,
													JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,																								
													JTAGI2CFLASHB_PROGRAM,				
													JTAGI2CSELECT_UFM1 ! Select UFM1,																																			
													JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													JTAGI2CSELECT_CFG1 ! Select CFG1,
													JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,																						
													JTAGI2CDISABLE ! Exit the programming mode"	;	
																							
	"XFLASH CFG Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_PASSWORD ! Check PASSWORD,  
													SVF_FLASHA_CFG_PROGRAM,
													CFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_FLASHB_CFG_PROGRAM,	
													CFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH CFG Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_PASSWORD ! Check PASSWORD,  
													SVF_SPIFLASHA_CFG_PROGRAM,
													SPICFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_SPIFLASHB_CFG_PROGRAM,	
													SPICFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,			
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_PASSWORD ! Check PASSWORD,  
													SVF_I2CFLASHA_CFG_PROGRAM,
													I2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
													SVF_I2CFLASHB_CFG_PROGRAM,	
													I2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
													I2CDISABLE ! Exit the programming mode"	;	
													
	"JTAGI2C XFLASH CFG Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
														JTAGI2CFLASHA_CFG_PROGRAM,
														JTAGI2CCFG0_PROGRAM_LOCK ! 	Program the local CFG0 lock policy,													
														JTAGI2CFLASHB_CFG_PROGRAM,	
														JTAGI2CCFG1_PROGRAM_LOCK ! 	Program the local CFG1 lock policy,	
														JTAGI2CDISABLE ! Exit the programming mode"	;
																								
	"XFLASH UFM Erase,Program,Verify,Secure" ="SVFINIT 	! Initialize, 
													READ_ID	! Check the IDCODE, 
													FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													CHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_UFM_PROGRAM_VERIFY,																												
													SELECT_UFM0 ! Select UFM0,
													UFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SELECT_UFM1 ! Select UFM1,
													UFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,	
													SELECT_UFM2 ! Select UFM2,
													UFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SELECT_UFM3 ! Select UFM3,
													UFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	 													
													DISABLE ! Exit the programming mode";
																									
	
	"Slave SPI XFLASH UFM Erase,Program,Verify,Secure" ="SPIINIT 	! Initialize, 
													SPIREAD_ID	! Check the IDCODE, 
													SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_SPIUFM_PROGRAM_VERIFY,																												
													SPISELECT_UFM0 ! Select UFM0,																											
													SPIUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													SPISELECT_UFM1 ! Select UFM1,
													SPIUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													SPISELECT_UFM2 ! Select UFM2,	
													SPIUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,	
													SPISELECT_UFM3 ! Select UFM3,
													SPIUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,	  													
													SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase,Program,Verify,Secure" ="	I2CINIT 	! Initialize, 
													I2CREAD_ID	! Check the IDCODE, 
													I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
													I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
													SVF_I2CUFM_PROGRAM_VERIFY,																												
													I2CSELECT_UFM0 ! Select UFM0,																										
													I2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
													I2CSELECT_UFM1 ! Select UFM1,
													I2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
													I2CSELECT_UFM2 ! Select UFM2,	
													I2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
													I2CSELECT_UFM3 ! Select UFM3,	
													I2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
													I2CDISABLE ! Exit the programming mode"	;	
														
	"JTAGI2C XFLASH UFM Erase,Program,Verify,Secure" ="	JTAGI2CINIT 	! Initialize, 
														JTAGI2CREAD_ID	! Check the IDCODE, 
														JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
														JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
														JTAGI2CUFM_PROGRAM_VERIFY,																												
														JTAGI2CSELECT_UFM0 ! Select UFM0,																										
														JTAGI2CUFM0_PROGRAM_LOCK ! 	Program the local UFM0 lock policy,	
														JTAGI2CSELECT_UFM1 ! Select UFM1,
														JTAGI2CUFM1_PROGRAM_LOCK ! 	Program the local UFM1 lock policy,
														JTAGI2CSELECT_UFM2 ! Select UFM2,	
														JTAGI2CUFM2_PROGRAM_LOCK ! 	Program the local UFM2 lock policy,
														JTAGI2CSELECT_UFM3 ! Select UFM3,	
														JTAGI2CUFM3_PROGRAM_LOCK ! 	Program the local UFM3 lock policy,														 										
														JTAGI2CDISABLE ! Exit the programming mode"	;	
													
	"XFLASH Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password,  
								SVF_FLASHA_ERASE,
								SVF_FLASHB_ERASE,
								SVF_FLASHC_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password, 
									SVF_SPIFLASHA_ERASE,
									SVF_SPIFLASHB_ERASE,
									SVF_SPIFLASHC_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password,  
								SVF_I2CFLASHA_ERASE,
								SVF_I2CFLASHB_ERASE,
								SVF_I2CFLASHC_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	
														
	"JTAGI2C XFLASH Erase Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									JTAGI2CCHECK_PASSWORD ! Check the Password, 
									JTAGI2CFLASHA_ERASE,
									JTAGI2CFLASHB_ERASE,
									JTAGI2CFLASHC_ERASE,
									JTAGI2CDISABLE ! Exit the programming mode"	;					
	
	"XFLASH CFG Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password,  
								SVF_FLASHACFG_ERASE,
								SVF_FLASHBCFG_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH CFG Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,  
									SVF_SPIFLASHACFG_ERASE,
									SVF_SPIFLASHBCFG_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH CFG Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_PASSWORD ! Check the Password,  
								SVF_I2CFLASHACFG_ERASE,
								SVF_I2CFLASHBCFG_ERASE,
								I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH CFG Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_PASSWORD ! Check the Password,  
										JTAGI2CFLASHACFG_ERASE,
										JTAGI2CFLASHBCFG_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
									
	"XFLASH UFM Erase Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_UFM_PASSWORD ! Check the Password,  
								SVF_FLASHAUFM_ERASE,
								SVF_FLASHBUFM_ERASE,
								SVF_FLASHCUFM_ERASE,
								DISABLE ! Exit the programming mode"	;													
	
	"Slave SPI XFLASH UFM Erase Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check the Password,  
									SVF_SPIFLASHAUFM_ERASE,
									SVF_SPIFLASHBUFM_ERASE,
									SVF_SPIFLASHCUFM_ERASE,
									SPIDISABLE ! Exit the programming mode"	;
	
	"I2C XFLASH UFM Erase Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								I2CCHECK_UFM_PASSWORD ! Check the Password,  
								SVF_I2CFLASHAUFM_ERASE,
								SVF_I2CFLASHBUFM_ERASE,
								SVF_I2CFLASHCUFM_ERASE,
								I2CDISABLE ! Exit the programming mode"	;
																
	"JTAGI2C XFLASH UFM Erase Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  
										JTAGI2CFLASHAUFM_ERASE,
										JTAGI2CFLASHBUFM_ERASE,
										JTAGI2CFLASHCUFM_ERASE,
										JTAGI2CDISABLE ! Exit the programming mode"	;
								
	"XFLASH Verify Only" =	"SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE, 
								FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
								CHECK_PASSWORD ! Check the Password,  	
								FLASHA_VERIFY,
								FLASHB_VERIFY,	
								DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH Verify Only" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_PASSWORD ! Check the Password,  
									SPIFLASHA_VERIFY,
									SPIFLASHB_VERIFY,	
									SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH Verify Only" =	"I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE, 
								I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
								I2CCHECK_PASSWORD ! Check the Password,  
								I2CFLASHA_VERIFY,
								I2CFLASHB_VERIFY,	
								I2CDISABLE ! Exit the programming mode"	;
								
	"JTAGI2C XFLASH Verify Only" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									JTAGI2CCHECK_PASSWORD ! Check the Password,  		
									JTAGI2CFLASHA_VERIFY,
									JTAGI2CFLASHB_VERIFY,	
									JTAGI2CDISABLE ! Exit the programming mode"	;
	
	"XFLASH CFG Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_PASSWORD ! Check the Password,  							
									FLASHA_CFG_VERIFY,
									FLASHB_CFG_VERIFY,
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH CFG Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
											SPICHECK_PASSWORD ! Check the Password,  							
											SPIFLASHA_CFG_VERIFY,
											SPIFLASHB_CFG_VERIFY,
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH CFG Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
									I2CCHECK_PASSWORD ! Check the Password,  							
									I2CFLASHA_CFG_VERIFY,
									I2CFLASHB_CFG_VERIFY,
									I2CDISABLE ! Exit the programming mode"	;	
									
	"JTAGI2C XFLASH CFG Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,  
										JTAGI2CCHECK_PASSWORD ! Check the Password,  							
										JTAGI2CFLASHA_CFG_VERIFY,
										JTAGI2CFLASHB_CFG_VERIFY,
										JTAGI2CDISABLE ! Exit the programming mode"	;											
									
	"XFLASH UFM Verify Only" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									CHECK_UFM_PASSWORD ! Check the Password,  							
									UFM_VERIFY_ONLY,									
									DISABLE ! Exit the programming mode";	
																																				
	"Slave SPI XFLASH UFM Verify Only" =	"SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
											SPICHECK_UFM_PASSWORD ! Check the Password,  							
											SPIUFM_VERIFY_ONLY,	
											SPIDISABLE ! Exit the programming mode"	;	
	
	"I2C XFLASH UFM Verify Only" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
									I2CCHECK_UFM_PASSWORD ! Check the Password,  							
									I2CUFM_VERIFY_ONLY,	
									I2CDISABLE ! Exit the programming mode"	;											

	"JTAGI2C XFLASH UFM Verify Only" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode, 
										JTAGI2CCHECK_UFM_PASSWORD ! Check the Password,  							
										JTAGI2CUFM_VERIFY_ONLY,	
										JTAGI2CDISABLE ! Exit the programming mode"	;								
			 									 									 									 										 										 
	"XFLASH Bypass" ="SVFINIT 	! Initialize"; 
								
	"Slave SPI XFLASH Bypass" ="SPIINIT 	! Initialize"; 
								
	"I2C XFLASH Bypass" =	"I2CINIT 	! Initialize"; 	

	"JTAGI2C XFLASH Bypass" =	"JTAGI2CINIT 	! Initialize"; 
	
	"Bypass" ="INIT 	! Initialize"; 
															 	
	"XFLASH Verify ID" ="SVFINIT 	! Initialize, 
							 READ_ID ! Check the IDCODE"; 
								
	"Slave SPI XFLASH Verify ID" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID ! Check the IDCODE"; 
								
	"I2C XFLASH Verify ID" =	"I2CINIT 	! Initialize, 
							 I2CREAD_ID ! Check the IDCODE"; 	

	"JTAGI2C XFLASH Verify ID" =	"JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID ! Check the IDCODE"; 															

	"XFLASH Display ID" =	"SVFINIT, SAVE_ID";
	
	"Slave SPI XFLASH Display ID" =	"SPIINIT, SPISAVE_ID";
	
	"I2C XFLASH Display ID" =	"I2CINIT, I2CSAVE_ID";
								 
	"JTAGI2C XFLASH Display ID" =	"JTAGI2CINIT, JTAGI2CSAVE_ID";

	"XFLASH Verify USERCODE" =	"SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									FLASH_ENABLE	! Enable the Flash access, 
									SELECT_CFG0	! Select CFG0,
									CFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
									SELECT_CFG1	! Select CFG1 Sector,
									CFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
									DISABLE ! Exit the programming mode";
	
	"Slave SPI XFLASH Verify USERCODE" =	"SPIINIT 	! Initialize, 
										SPIREAD_ID	! Check the IDCODE,
										SPIFLASH_ENABLE	! Enable the Flash access, 
										SPISELECT_CFG0	! Select CFG0,
										SPICFG0_VERIFY_USERCODE		! Verify CFG0 USERCODE,
										SPISELECT_CFG1	! Select CFG1,
										SPICFG1_VERIFY_USERCODE		! Verify CFG1 USERCODE,
										SPIDISABLE ! Exit the programming mode"	;
																				

	"I2C XFLASH Verify USERCODE" =	"I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE,
									I2CFLASH_ENABLE	! Enable the Flash access, 
									I2CSELECT_CFG0	! Select CFG0,
									I2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
									I2CSELECT_CFG1	! Select CFG1,
									I2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
									I2CDISABLE ! Exit the programming mode"	;	

	"JTAGI2C XFLASH Verify USERCODE" =	"JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access, 
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
										JTAGI2CSELECT_CFG0	! Select CFG0,
										JTAGI2CCFG0_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CCFG1_VERIFY_USERCODE		! Verify USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode"	;																																			 												 	
	
	"XFLASH Refresh" =" SVFINIT !Initialize,
							READ_ID !Check the IDCODE,
							REFRESH_FUNCTION ! Refresh";
							
	"Slave SPI XFLASH Refresh" ="SPIINIT !Initialize,
								SPIREAD_ID !Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh";	
									
	"I2C XFLASH Refresh" ="I2CINIT !Initialize,
						I2CREAD_ID !Check the IDCODE,
						I2CREFRESH_FUNCTION ! Refresh";	
												 
	"JTAGI2C XFLASH Refresh" ="JTAGI2CINIT !Initialize,
								JTAGI2CREAD_ID !Check the IDCODE,
								JTAGI2CREFRESH_FUNCTION ! Refresh";													
	
	"XFLASH Secure CFG Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SELECT_CSEC	! Select CSEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									CSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									CSEC_PROGRAM_LOCK ! Program CSEC local lock,									
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure CFG Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPICSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									SPICSEC_PROGRAM_LOCK ! Program CSEC local lock,	
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure CFG Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CCSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program CSEC central lock,
									I2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
									I2CDISABLE	! Exit the programming mode";
							
	"JTAGI2C XFLASH Secure CFG Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_CSEC	! Select CSEC,									
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK	! Program CSEC central lock,
										JTAGI2CCSEC_PROGRAM_LOCK ! Program CSEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";
																		
	"XFLASH Secure UFM Plus" ="SVFINIT 	! Initialize, 
									READ_ID	! Check the IDCODE, 
									FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									CHECK_UFM_PASSWORD ! Check PASSWORD,  
									SELECT_USEC	! Select USEC,
									CHECK_PROG_LOCK ! Check LOCK information,
									USEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									USEC_PROGRAM_LOCK	! Program USEC local lock,
									DISABLE	! Exit the programming mode";
	
	"Slave SPI XFLASH Secure UFM Plus" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_PROG_LOCK ! Check LOCK information,
									SPIUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									SPIUSEC_PROGRAM_LOCK	! Program USEC local lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C XFLASH Secure UFM Plus" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,
									I2CCHECK_PROG_LOCK ! Check LOCK information,
									I2CUSEC_PROGRAM_CENTRAL_LOCK_SVF	! Program USEC central lock,
									I2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
									I2CDISABLE	! Exit the programming mode";
										
	"JTAGI2C XFLASH Secure UFM Plus" ="JTAGI2CINIT 	! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE, 
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
										JTAGI2CSELECT_USEC	! Select USEC,
										JTAGI2CCHECK_PROG_LOCK ! Check LOCK information,
										JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK	! Program USEC central lock,
										JTAGI2CUSEC_PROGRAM_LOCK	! Program USEC local lock,
										JTAGI2CDISABLE	! Exit the programming mode";

	"Enable SPI" = " SVFINIT 	! Initialize, 
					 READ_ID	! Check the IDCODE,
					 SRAM_ENABLE	! Enable SRAM programming mode, 
					 SRAM_ERASE	! Erase the SRAM, 
					 DISABLE ! Exit the programming mode" ;
	
	"Enable SPI with Password" = " SVFINIT 	! Initialize, 
								 READ_ID	! Check the IDCODE,
								 CHECK_SRAM_ERASE_LOCK ! Check the SRAM Erase Lock,	
								 CHECK_SRAM_PROG_LOCK ! Check the SRAM Program Lock,											 
								 SRAM_ENABLE	! Enable SRAM programming mode, 
								 CHECK_PASSWORD ! Check the Password, 
								 SRAM_ERASE	! Erase the SRAM,  
					 			 DISABLE ! Exit the programming mode" ;	

	"Verify ID" = 		"SVFINIT 	! Initialize, 
						 READ_ID ! Check the IDCODE"; 

	"Verify ID with Password" = 		"SVFINIT 	! Initialize, 
										READ_ID ! Check the IDCODE, 
										CHECK_PASSWORD ! Check the Password"; 								 

	"Program Manufacturing Register" = "SVFINIT 	! Initialize, 
									  READ_ID	! Check the IDCODE,
									  FLASH_SUDO_TRANSPARENT_ENABLE	! Enable the Manufacturing Mode,
									  PROGRAM_MANUFACTURING_REGISTER ! Program the Manufacturing Register,
									  DISABLE ! Exit the programming mode" ;

	"XFLASH TransFR" = "	SVFINIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								REFRESH_FUNCTION ! Refresh"	;

	"Slave SPI XFLASH TransFR" = "	SPIINIT 	! Initialize, 
								SPIREAD_ID	! Check the IDCODE,
								SPIREFRESH_FUNCTION ! Refresh"	;
	"I2C XFLASH TransFR" = "	I2CINIT 	! Initialize, 
								I2CREAD_ID	! Check the IDCODE,
								I2CREFRESH_FUNCTION ! Refresh"	;
								
	"JTAGI2C XFLASH TransFR" = "	JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE,
									JTAGI2CREFRESH_FUNCTION ! Refresh"	;	

	"XFLASH Program and TransFR" ="SVFINIT 	! Initialize, 
										READ_ID	! Check the IDCODE, 
										FLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										CHECK_PASSWORD ! Check PASSWORD,  
										SVF_FLASHA_PROGRAM,
										SVF_FLASHB_PROGRAM,	
										DISABLE ! Exit the programming mode,									
										REFRESH_FUNCTION ! Refresh,
										SVF_VERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
										
	"Slave SPI XFLASH Program and TransFR" ="SPIINIT 	! Initialize, 
											SPIREAD_ID	! Check the IDCODE, 
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											SPICHECK_PASSWORD ! Check PASSWORD,  
											SVF_SPIFLASHA_PROGRAM,
											SVF_SPIFLASHB_PROGRAM,												
											SPIDISABLE ! Exit the programming mode,									
											SPIREFRESH_FUNCTION ! Refresh,
											SVF_SPIVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;		

	"I2C XFLASH Program and TransFR" ="I2CINIT 	! Initialize, 
										I2CREAD_ID	! Check the IDCODE, 
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
										I2CCHECK_PASSWORD ! Check PASSWORD,  
										SVF_I2CFLASHA_PROGRAM,
										SVF_I2CFLASHB_PROGRAM,										
										I2CDISABLE ! Exit the programming mode,									
										I2CREFRESH_FUNCTION ! Refresh,
										SVF_I2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;	
									
	"JTAGI2C XFLASH Program and TransFR" ="JTAGI2CINIT 	! Initialize, 
											JTAGI2CREAD_ID	! Check the IDCODE, 
											JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash Transparent mode,
											JTAGI2CCHECK_PASSWORD ! Check PASSWORD,  
											JTAGI2CFLASHA_PROGRAM,
											JTAGI2CFLASHB_PROGRAM,										
											JTAGI2CDISABLE_REFRESH! Refresh,
											JTAGI2CVERIFY_SRAM_DONE_BIT ! Check SRAM Status Register"	;
										
	"FLASH Dry Run" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_PASSWORD ! Check PASSWORD, 
							SVF_CHECK_AUTHTICATE ! Check Authenticate,
							SVF_FLASHA_DRYRUN,
							SVF_FLASHB_DRYRUN"	;													
	
	"Slave SPI FLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPICHECK_PASSWORD ! Check PASSWORD, 
									SVF_SPICHECK_AUTHTICATE ! Check Authenticate,
									SVF_SPIFLASHA_DRYRUN,
									SVF_SPIFLASHB_DRYRUN"	;
	
	"I2C FLASH Dry Run" =	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_PASSWORD ! Check PASSWORD, 
							SVF_I2CCHECK_AUTHTICATE ! Check Authenticate,
							SVF_I2CFLASHA_DRYRUN,
							SVF_I2CFLASHB_DRYRUN"	;	
											
	"JTAGI2C FLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								SVF_JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;																			
	
	"XFLASH Dry Run" =	"SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE,
							CHECK_PASSWORD ! Check PASSWORD, 
							SVF_CHECK_AUTHTICATE ! Check Authenticate,
							SVF_FLASHA_DRYRUN,
							SVF_FLASHB_DRYRUN"	;													
	
	"Slave SPI XFLASH Dry Run" =	"SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE,
									SPICHECK_PASSWORD ! Check PASSWORD, 
									SVF_SPICHECK_AUTHTICATE ! Check Authenticate,
									SVF_SPIFLASHA_DRYRUN,
									SVF_SPIFLASHB_DRYRUN"	;
	
	"I2C XFLASH Dry Run" =	"I2CINIT 	! Initialize, 
							I2CREAD_ID	! Check the IDCODE,
							I2CCHECK_PASSWORD ! Check PASSWORD, 
							SVF_I2CCHECK_AUTHTICATE ! Check Authenticate,
							SVF_I2CFLASHA_DRYRUN,
							SVF_I2CFLASHB_DRYRUN"	;	
									
	"JTAGI2C XFLASH Dry Run" =	"JTAGI2CINIT 	! Initialize, 
								JTAGI2CREAD_ID	! Check the IDCODE,
								JTAGI2CCHECK_PASSWORD ! Check PASSWORD, 
								SVF_JTAGI2CCHECK_AUTHTICATE ! Check Authenticate,
								JTAGI2CFLASHA_DRYRUN,
								JTAGI2CFLASHB_DRYRUN"	;

	"Security Erase Encryption Key" ="SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable the Flash, 
								  CHECK_ENABLE_PASSWORD ! Check the Password,  
								  SELECT_AESKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  SVF_AESKEY_ERASE ! Erase AESKEY Sector,
								  DISABLE ! Exit the programming mode" ;		

	"Slave SPI Security Erase Encryption Key" ="SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable the Flash, 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,  
								  SPISELECT_AESKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SVF_SPIAESKEY_ERASE ! Erase AESKEY Sector,
								  SPIDISABLE ! Exit the programming mode" ;	
								  
	"I2C Security Erase Encryption Key" ="I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable the Flash, 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,  
								  I2CSELECT_AESKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  SVF_I2CAESKEY_ERASE ! Erase AESKEY Sector,
								  I2CDISABLE ! Exit the programming mode" ;	

	"JTAGI2C Security Erase Encryption Key" ="JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable the Flash, 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,  
											  JTAGI2CSELECT_AESKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CAESKEY_ERASE ! Erase AESKEY Sector,
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"Security Erase Public Key" =	"SVFINIT 	! Initialize, 
								  READ_ID	! Check the IDCODE, 
								  FLASH_ENABLE	! Enable PROGRAM mode,	 
								  CHECK_ENABLE_PASSWORD ! Check the Password,   
								  SELECT_PUBKEY ! Select AESKEY Sector,
								  CHECK_ERASE_LOCK ! Check the Locks,
								  SVF_PUBKEY_ERASE ! Erase PUBKEY Sector,        
								  DISABLE ! Exit the programming mode" ;	

	"Slave SPI Security Erase Public Key" =	"SPIINIT 	! Initialize, 
								  SPIREAD_ID	! Check the IDCODE, 
								  SPIFLASH_ENABLE	! Enable PROGRAM mode,	 
								  SPICHECK_ENABLE_PASSWORD ! Check the Password,   
								  SPISELECT_PUBKEY ! Select AESKEY Sector,
								  SPICHECK_ERASE_LOCK ! Check the Locks,
								  SVF_SPIPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  SPIDISABLE ! Exit the programming mode" ;	

	"I2C Security Erase Public Key" =	"I2CINIT 	! Initialize, 
								  I2CREAD_ID	! Check the IDCODE, 
								  I2CFLASH_ENABLE	! Enable PROGRAM mode,	 
								  I2CCHECK_ENABLE_PASSWORD ! Check the Password,   
								  I2CSELECT_PUBKEY ! Select AESKEY Sector,
								  I2CCHECK_ERASE_LOCK ! Check the Locks,
								  SVF_I2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
								  I2CDISABLE ! Exit the programming mode" ;	
		
	"JTAGI2C Security Erase Public Key" =	"JTAGI2CINIT 	! Initialize, 
											  JTAGI2CREAD_ID	! Check the IDCODE, 
											  JTAGI2CFLASH_ENABLE	! Enable PROGRAM mode,	 
											  JTAGI2CCHECK_ENABLE_PASSWORD ! Check the Password,   
											  JTAGI2CSELECT_PUBKEY ! Select AESKEY Sector,
											  JTAGI2CCHECK_ERASE_LOCK ! Check the Locks,
											  JTAGI2CPUBKEY_ERASE ! Erase PUBKEY Sector,        
											  JTAGI2CDISABLE ! Exit the programming mode" ;

	"Security Erase CSEC" ="SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_ENABLE_PASSWORD ! Check PASSWORD,  
							SELECT_CSEC	! Select CSEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							SVF_CSEC_ERASE	! Erase CSEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase CSEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									SPISELECT_CSEC	! Select CSEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SVF_SPICSEC_ERASE	! Erase CSEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase CSEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_ENABLE_PASSWORD ! Check PASSWORD,  
									I2CSELECT_CSEC	! Select CSEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									SVF_I2CCSEC_ERASE	! Erase CSEC central lock,
									I2CDISABLE	! Exit the programming mode";	
										
	"JTAGI2C Security Erase CSEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_ENABLE_PASSWORD! Check PASSWORD,  
									JTAGI2CSELECT_CSEC	! Select CSEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CCSEC_ERASE	! Erase CSEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";							  
								  
	"Security Erase USEC" ="SVFINIT 	! Initialize, 
							READ_ID	! Check the IDCODE, 
							FLASH_ENABLE	! Enable the Flash,
							CHECK_UFM_PASSWORD ! Check PASSWORD,  
							SELECT_USEC	! Select USEC,
							CHECK_ERASE_LOCK ! Check LOCK information,
							SVF_USEC_ERASE	! Erase USEC central lock,
							DISABLE	! Exit the programming mode";
	
	"Slave SPI Security Erase USEC" ="SPIINIT 	! Initialize, 
									SPIREAD_ID	! Check the IDCODE, 
									SPIFLASH_ENABLE	! Enable the Flash,
									SPICHECK_UFM_PASSWORD ! Check PASSWORD,  
									SPISELECT_USEC	! Select USEC,
									SPICHECK_ERASE_LOCK ! Check LOCK information,
									SVF_SPIUSEC_ERASE	! Erase USEC central lock,
									SPIDISABLE	! Exit the programming mode";
	
	"I2C Security Erase USEC" ="I2CINIT 	! Initialize, 
									I2CREAD_ID	! Check the IDCODE, 
									I2CFLASH_ENABLE	! Enable the Flash,
									I2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									I2CSELECT_USEC	! Select USEC,									
									I2CCHECK_ERASE_LOCK ! Check LOCK information,
									SVF_I2CUSEC_ERASE	! Erase USEC central lock,
									I2CDISABLE	! Exit the programming mode";	
										
	"JTAGI2C Security Erase USEC" ="JTAGI2CINIT 	! Initialize, 
									JTAGI2CREAD_ID	! Check the IDCODE, 
									JTAGI2CFLASH_ENABLE	! Enable the Flash,
									JTAGI2CCHECK_UFM_PASSWORD ! Check PASSWORD,  
									JTAGI2CSELECT_USEC	! Select USEC,									
									JTAGI2CCHECK_ERASE_LOCK ! Check LOCK information,
									JTAGI2CUSEC_ERASE	! Erase USEC central lock,
									JTAGI2CDISABLE	! Exit the programming mode";							  
								
	"FLASH Display USERCODE" =	"SVFINIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_ENABLE	! Enable the Flash access,
											SELECT_CFG0	! Select CFG0,
											SVF_SAVE_USERCODE,
											SELECT_CFG1	! Select CFG1,
											SVF_SAVE_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI FLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_ENABLE	! Enable the Flash access, 
											SPISELECT_CFG0	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C FLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_ENABLE	! Enable the Flash access,  
										I2CSELECT_CFG0	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE ! Exit the programming mode";
									
	"JTAGI2C FLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_ENABLE	! Enable the Flash access,  
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";
	
	"XFLASH Display USERCODE" =	"SVFINIT ! Initialize, 
											READ_ID	! Check the IDCODE,
											SAVE_ID,
											FLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
											SELECT_CFG0	! Select CFG0,
											SVF_SAVE_USERCODE,
											SELECT_CFG1	! Select CFG1,
											SVF_SAVE_USERCODE,
											DISABLE ! Exit the programming mode";																					
	
	"Slave SPI XFLASH Display USERCODE" ="SPIINIT ! Initialize, 
											SPIREAD_ID	! Check the IDCODE,
											SPISAVE_ID,
											SPIFLASH_TRANSPARENT_ENABLE	! Enable the Flash access, 
											SPISELECT_CFG0	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPISELECT_CFG1	! Select CFG1,
											SPI_SVF_SAVE_USERCODE,
											SPIDISABLE ! Exit the programming mode";
											
	"I2C XFLASH Display USERCODE" =	"I2CINIT ! Initialize, 
										I2CREAD_ID	! Check the IDCODE,
										I2CSAVE_ID,
										I2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,  
										I2CSELECT_CFG0	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CSELECT_CFG1	! Select CFG1,
										I2C_SVF_SAVE_USERCODE,
										I2CDISABLE ! Exit the programming mode";											

	"JTAGI2C XFLASH Display USERCODE" =	"JTAGI2CINIT ! Initialize, 
										JTAGI2CREAD_ID	! Check the IDCODE,
										JTAGI2CSAVE_ID,
										JTAGI2CFLASH_TRANSPARENT_ENABLE	! Enable the Flash access,
										JTAGI2CCHECK_PASSWORD ! Check PASSWORD,   
										JTAGI2CSELECT_CFG0	! Select CFG1,
										JTAGI2CDISPLAY_CFG0_USERCODE,
										JTAGI2CSELECT_CFG1	! Select CFG1,
										JTAGI2CDISPLAY_CFG1_USERCODE,
										JTAGI2CDISABLE ! Exit the programming mode";										 
</Operation_List>
<Operation_List label="ChainSVFOperationRevC">	
	"Bypass"	=	"SVFINIT 	! Initialize";	
</Operation_List>
<Script>
<![CDATA[
int32   Temp_Row_Count = 0;
int32   Temp_UFM_Count = 0;
int32   Temp_UFM2_Count = 0;
int32	Temp_UFM3_Count = 0;
int32   MutexOn = 0;

function NOT_SUPPORTED
{
	set_return_code (-1);	
	print (1,"Operation is not supported for JTAGI2C Mode. Cannot continue.");	
}
function INIT 
{
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12542;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    	Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SVFINIT 
{
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12542;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    	Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SPIINIT 
{
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	setpin ISPEN HIGH;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12542;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    	Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}										
function I2CINIT 
{
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12542;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    	Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function JTAGI2CINIT 
{
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12542;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    	Temp_UFM2_Count = 1151;
		Temp_UFM3_Count = 191;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
    ! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
}
function PRELOAD {
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
}

function INI_PRELOAD {				
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length);
}
function SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}

function INI_SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}
function CAPTURE {	
	datastream SavedBScanTDO[1][BSCAN_Length];	
	file NewFile = "FILE_SAVE";		
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length)
   					TDO(SavedBScanTDO[1]);
   Bscan[1] = SavedBScanTDO[1];	
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
   // Write To file 
   fopen NewFile att "w"
					 format "SVF_Plus";	
   fwrite NewFile (BSCAN_TDO, Bscan);
   fclose 	NewFile;
   
}
function DYNAMIC {	
   ENDDR DRPAUSE;
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1])
   					DMASK(BscanMask[1]);
   STATE IDLE;
}
function READ_ID 
{
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length 	TDI (IDCODE_PUB);
	SDR_VERIFY	ID_Length	TDI (#0^ID_Length)
					        TDO	(IDTDI[1])
					        MASK (DEVICE_ID_MASK);
}
function SPIREAD_ID 
{
    IDTDI[1] = $IDTDI[1];
	TRY 1{
		FREQUENCY 10 HZ;
		setpin ISPEN LOW;
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFFF);						
		setpin ISPEN HIGH;
		FREQUENCY 1E6 HZ;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		FREQUENCY 1E6 HZ;
		print (1,"Failed to read the Device's IDCODE.");
	}			        
}
function I2CREAD_ID 
{
	IDTDI[1] = $IDTDI[1];
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		I2C_STOP;
	}	
	ELSE
	{	
		I2C_STOP;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function JTAGI2CREAD_ID 
{
	datastream DataByte[1][8];
	datastream MaskByte[1][8];
	datastream DataIDMask[1][32];
	DataIDMask[1] = DEVICE_ID_MASK;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	16	TDI (0x10E0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (IDTDI[1]);
		MaskByte[1] = (DataIDMask[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 8);
		MaskByte[1] = (DataIDMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 16);
		MaskByte[1] = (DataIDMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 24);
		MaskByte[1] = (DataIDMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);												
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
	}	
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function SAVE_TRACEID
{
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE"; 
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SIR Instruction_Length	TDI	(LSC_UIDCODE_PUB);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}
function SPISAVE_TRACEID
{
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SDR	32	TDI (0x00000098);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	setpin ISPEN HIGH;
	SavedUID[1] = $SavedUID[1];
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}

function I2CSAVE_TRACEID
{
	datastream SavedUID[1][64];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_UIDCODE_PUB(0x19) instruction;
    SDR 32 	TDI (0x00000098);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	64	TDI (#0^64)
			TDO	(SavedUID);
	I2C_STOP;
	SavedUID[1] = $SavedUID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedUID);
	fclose 	NewFile;
}
function SAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE"; 
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length	TDI	(IDCODE_PUB);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SPISAVE_ID	
{
	datastream SavedID[1][32];
	file	NewFile = "FILE_SAVE";
	setpin ISPEN LOW; 
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
	SDR	32	TDI (#0^ID_Length)
			TDO	(SavedID);
	setpin ISPEN HIGH;
	SavedID[1] = $SavedID[1];					
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function I2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	I2C_STOP;				
	SavedID[1] = $SavedID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function JTAGI2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	16	TDI (0x10E0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;			
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}									
function SRAM_ENABLE {
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SPISRAM_ENABLE {	
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}	
function SPISRAM_ENABLE_NO_REFRESH {
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}									
function I2CSRAM_ENABLE {	
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_ENABLE_NO_REFRESH {
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function SRAM_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0000);
	RUN_TEST 	TCK 2 DELAY 1000;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
					TDO(0x00000000)
					MASK(0x00003100);
}
function SPISRAM_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWE;
}
function I2CSRAM_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00000070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
}
function JTAGI2CSRAM_ERASE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWE;
}
function FLASHA_ERASE 
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@SELECT_CFG0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG0;
		@CFG0_ERASE();
		! Select UFM0 Sector;
		@SELECT_UFM0();	
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM0;	
		@UFM0_ERASE();
	}
}
function SPIFLASHA_ERASE 
{														
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@SPISELECT_CFG0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the CFG0;
		@SPICFG0_ERASE();
		! Select UFM0 Sector;	
		@SPISELECT_UFM0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SPIUFM0_ERASE();	
	}
}
function I2CFLASHA_ERASE 
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@I2CSELECT_CFG0();
		! Check Lock information;	
		@I2CCHECK_ERASE_LOCK();	
		! Erase the CFG0;
		@I2CCFG0_ERASE();	
		! Select UFM0 Sector;
		@I2CSELECT_UFM0();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@I2CUFM0_ERASE();	
	}
}
function JTAGI2CFLASHA_ERASE 
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@JTAGI2CSELECT_CFG0();
		! Check Lock information;	
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the CFG0;
		@JTAGI2CCFG0_ERASE();	
		! Select UFM0 Sector;
		@JTAGI2CSELECT_UFM0();	
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@JTAGI2CUFM0_ERASE();	
	}
}	
function FLASHB_ERASE 
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@SELECT_CFG1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG1;
		@CFG1_ERASE();
		! Select UFM1 Sector;
		@SELECT_UFM1();	
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM1;	
		@UFM1_ERASE();
	}
}
function SPIFLASHB_ERASE 
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@SPISELECT_CFG1();
		! Check Lock information;	
		@SPICHECK_ERASE_LOCK();	
		! Erase the CFG1;
		@SPICFG1_ERASE();	
		! Select UFM1 Sector;
		@SPISELECT_UFM1();	
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SPIUFM1_ERASE();	
	}							
}
function I2CFLASHB_ERASE 
{																								
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@I2CSELECT_CFG1();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the CFG1;
		@I2CCFG1_ERASE();	
		! Select UFM1 Sector;
		@I2CSELECT_UFM1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@I2CUFM1_ERASE();	
	}
}
function JTAGI2CFLASHB_ERASE 
{																								
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@JTAGI2CSELECT_CFG1();	
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the CFG1;
		@JTAGI2CCFG1_ERASE();	
		! Select UFM1 Sector;
		@JTAGI2CSELECT_UFM1();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@JTAGI2CUFM1_ERASE();	
	}
}
function FLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@SELECT_UFM2();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM2;
		@UFM2_ERASE();
		! Select UFM3 Sector;
		@SELECT_UFM3();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM3;
		@UFM3_ERASE();
	}
}
function SPIFLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@SPISELECT_UFM2();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM2;
		@SPIUFM2_ERASE();	
		! Select UFM3 Sector;
		@SPISELECT_UFM3();	
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM3;
		@SPIUFM3_ERASE();	
	}
}
function JTAGI2CFLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@JTAGI2CSELECT_UFM2();	
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM2;
		@JTAGI2CUFM2_ERASE();	
		! Select UFM3 Sector;
		@JTAGI2CSELECT_UFM3();	
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM3;
		@JTAGI2CUFM3_ERASE();	
	}
}
function I2CFLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@I2CSELECT_UFM2();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM2;
		@I2CUFM2_ERASE();	
		! Select UFM3 Sector;
		@I2CSELECT_UFM3();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM3;
		@I2CUFM3_ERASE();	
	}
}
function FLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@SELECT_CFG0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG0;
		@CFG0_ERASE();		
	}
}
function SPIFLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@SPISELECT_CFG0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the CFG0;
		@SPICFG0_ERASE();		
	}
}
function I2CFLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@I2CSELECT_CFG0();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the CFG0;
		@I2CCFG0_ERASE();		
	}
}
function JTAGI2CFLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@JTAGI2CSELECT_CFG0();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();
		! Erase the CFG0;
		@JTAGI2CCFG0_ERASE();		
	}
}
function FLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@SELECT_CFG1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG1;
		@CFG1_ERASE();		
	}
}
function SPIFLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@SPISELECT_CFG1();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the CFG1;
		@SPICFG1_ERASE();		
	}
}
function I2CFLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@I2CSELECT_CFG1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the CFG1;
		@I2CCFG1_ERASE();		
	}
}
function JTAGI2CFLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@JTAGI2CSELECT_CFG1();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();
		! Erase the CFG1;
		@JTAGI2CCFG1_ERASE();		
	}
}
function FLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@SELECT_UFM0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@UFM0_ERASE();	
	}
}
function SPIFLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@SPISELECT_UFM0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SPIUFM0_ERASE();	
	}
}
function I2CFLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@I2CSELECT_UFM0();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@I2CUFM0_ERASE();	
	}
}
function JTAGI2CFLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@JTAGI2CSELECT_UFM0();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@JTAGI2CUFM0_ERASE();	
	}
}
function FLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@SELECT_UFM1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@UFM1_ERASE();	
	}
}
function SPIFLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@SPISELECT_UFM1();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SPIUFM1_ERASE();	
	}
}
function I2CFLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@I2CSELECT_UFM1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@I2CUFM1_ERASE();	
	}
}
function JTAGI2CFLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@JTAGI2CSELECT_UFM1();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@JTAGI2CUFM1_ERASE();	
	}
}
function FLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@SELECT_UFM2();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM2;
		@UFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@SELECT_UFM3();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM3;
		@UFM3_ERASE();
	}
}
function SPIFLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@SPISELECT_UFM2();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the UFM2;
		@SPIUFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@SPISELECT_UFM3();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the UFM3;
		@SPIUFM3_ERASE();
	}
}
function I2CFLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@I2CSELECT_UFM2();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the UFM2;
		@I2CUFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@I2CSELECT_UFM3();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the UFM3;
		@I2CUFM3_ERASE();
	}
}
function JTAGI2CFLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@JTAGI2CSELECT_UFM2();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();
		! Erase the UFM2;
		@JTAGI2CUFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@JTAGI2CSELECT_UFM3();
		! Check Lock information;
		@JTAGI2CCHECK_ERASE_LOCK();
		! Erase the UFM3;
		@JTAGI2CUFM3_ERASE();
	}
}
function FULL_FLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@CFG0_ERASE();
		! Program CFG0;
		@FULL_CFG0_PROGRAM(); 
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@UFM0_ERASE(); 
		! Program the UFM0;
		@FULL_UFM0_PROGRAM(); 
		! Select UFM0;													
		@SELECT_UFM0();	 
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM0;													
		@UFM0_VERIFY();     
		! Select CFG0;     
		@SELECT_CFG0();	
		! Program DONE bit;
		@FLASHA_PROGRAM_DONE_BIT();			
	}
}
function FLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@CFG0_ERASE();
		! Program CFG0;
		@CFG0_PROGRAM(); 
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@UFM0_ERASE(); 
		! Program the UFM0;
		@UFM0_PROGRAM(); 
		! Select UFM0;													
		@SELECT_UFM0();	 
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM0;													
		@UFM0_VERIFY();     
		! Select CFG0;     
		@SELECT_CFG0();	
		! Program DONE bit;
		@FLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_SPIFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SPICFG0_ERASE();
		! Program CFG0;
		@FULL_SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG0;	
		@FULL_SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SPISELECT_UFM0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SPIUFM0_ERASE(); 
		! Program the UFM0;
		@FULL_SPIUFM0_PROGRAM(); 
		! Select UFM0;													
		@SPISELECT_UFM0();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();  
		! Verify the UFM0;													
		@FULL_SPIUFM0_VERIFY();     
		! Select CFG0;     
		@SPISELECT_CFG0();	
		! Program DONE bit;
		@SPIFLASHA_PROGRAM_DONE_BIT();			
	}
}
function SPIFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SPICFG0_ERASE();
		! Program CFG0;
		@SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG0;	
		@SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SPISELECT_UFM0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SPIUFM0_ERASE(); 
		! Program the UFM0;
		@SPIUFM0_PROGRAM(); 
		! Select UFM0;													
		@SPISELECT_UFM0();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();  
		! Verify the UFM0;													
		@SPIUFM0_VERIFY();     
		! Select CFG0;     
		@SPISELECT_CFG0();	
		! Program DONE bit;
		@SPIFLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_I2CFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@I2CCFG0_ERASE();
		! Program CFG0;
		@FULL_I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG0;	
		@FULL_I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@I2CUFM0_ERASE(); 
		! Program the UFM0;
		@FULL_I2CUFM0_PROGRAM();  
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM0;													
		@FULL_I2CUFM0_VERIFY();     
		! Select CFG0;     
		@I2CSELECT_CFG0();	
		! Program DONE bit;
		@I2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function I2CFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@I2CCFG0_ERASE();
		! Program CFG0;
		@I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG0;	
		@I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@I2CUFM0_ERASE(); 
		! Program the UFM0;
		@I2CUFM0_PROGRAM();  
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM0;													
		@I2CUFM0_VERIFY();     
		! Select CFG0;     
		@I2CSELECT_CFG0();	
		! Program DONE bit;
		@I2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function JTAGI2CFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Programming Flash A");
		! Select CFG0;
		@JTAGI2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@JTAGI2CCFG0_ERASE();
		! Program CFG0;
		@JTAGI2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@JTAGI2CCFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@JTAGI2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@JTAGI2CCFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@JTAGI2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@JTAGI2CUFM0_ERASE(); 
		! Program the UFM0;
		@JTAGI2CUFM0_PROGRAM();  
		! Select UFM0;													
		@JTAGI2CSELECT_UFM0();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@JTAGI2CUFM0_VERIFY();     
		! Select CFG0;     
		@JTAGI2CSELECT_CFG0();	
		! Program DONE bit;
		@JTAGI2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_FLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@CFG1_ERASE();	
		! Program CFG1;
		@FULL_CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK();
		! Erase UFM1;												
		@UFM1_ERASE(); 		
		! Program the UFM1;										
		@FULL_UFM1_PROGRAM();  
		! Select UFM1;		
		@SELECT_UFM1();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM1;
		@UFM1_VERIFY();       
		! Select CFG1;   	
		@SELECT_CFG1();	
		! Program DONE bit;
		@FLASHB_PROGRAM_DONE_BIT();	
	}
}
function FLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@CFG1_ERASE();	
		! Program CFG1;
		@CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK();
		! Erase UFM1;												
		@UFM1_ERASE(); 		
		! Program the UFM1;										
		@UFM1_PROGRAM();  
		! Select UFM1;		
		@SELECT_UFM1();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM1;
		@UFM1_VERIFY();       
		! Select CFG1;   	
		@SELECT_CFG1();	
		! Program DONE bit;
		@FLASHB_PROGRAM_DONE_BIT();	
	}
}
function FULL_SPIFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SPICFG1_ERASE();	
		! Program CFG1;
		@FULL_SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG1;	
		@FULL_SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;												
		@SPIUFM1_ERASE(); 		
		! Program the UFM1;										
		@FULL_SPIUFM1_PROGRAM();  
		! Select UFM1;		
		@SPISELECT_UFM1();		
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM1;
		@FULL_SPIUFM1_VERIFY();       
		! Select CFG1;   	
		@SPISELECT_CFG1();	
		! Program DONE bit;
		@SPIFLASHB_PROGRAM_DONE_BIT();	
	}
}
function SPIFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SPICFG1_ERASE();	
		! Program CFG1;
		@SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG1;	
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;												
		@SPIUFM1_ERASE(); 		
		! Program the UFM1;										
		@SPIUFM1_PROGRAM();  
		! Select UFM1;		
		@SPISELECT_UFM1();		
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM1;
		@SPIUFM1_VERIFY();       
		! Select CFG1;   	
		@SPISELECT_CFG1();	
		! Program DONE bit;
		@SPIFLASHB_PROGRAM_DONE_BIT();	
	}
}
function FULL_I2CFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@I2CCFG1_ERASE();	
		! Program CFG1;
		@FULL_I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG1;	
		@FULL_I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;												
		@I2CUFM1_ERASE(); 		
		! Program the UFM1;										
		@FULL_I2CUFM1_PROGRAM();  
		! Select UFM1;		
		@I2CSELECT_UFM1();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM1;
		@FULL_I2CUFM1_VERIFY();       
		! Select CFG1;   	
		@I2CSELECT_CFG1();	
		! Program DONE bit;
		@I2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function I2CFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@I2CCFG1_ERASE();	
		! Program CFG1;
		@I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG1;	
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;												
		@I2CUFM1_ERASE(); 		
		! Program the UFM1;										
		@I2CUFM1_PROGRAM();  
		! Select UFM1;		
		@I2CSELECT_UFM1();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM1;
		@I2CUFM1_VERIFY();       
		! Select CFG1;   	
		@I2CSELECT_CFG1();	
		! Program DONE bit;
		@I2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function JTAGI2CFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Programming Flash B");
		! Select CFG1;				
		@JTAGI2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@JTAGI2CCFG1_ERASE();	
		! Program CFG1;
		@JTAGI2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@JTAGI2CCFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@JTAGI2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@JTAGI2CCFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@JTAGI2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase UFM1;												
		@JTAGI2CUFM1_ERASE(); 		
		! Program the UFM1;										
		@JTAGI2CUFM1_PROGRAM(); 
		! Select UFM1;		
		@JTAGI2CSELECT_UFM1();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK();  
		! Verify the UFM1;
		@JTAGI2CUFM1_VERIFY();       
		! Select CFG1;   	
		@JTAGI2CSELECT_CFG1();	
		! Program DONE bit;
		@JTAGI2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function FULL_FLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@CFG0_ERASE();
		! Program CFG0;
		@FULL_CFG0_PROGRAM();	
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();		
		! Program DONE bit;
		@FLASHA_PROGRAM_DONE_BIT();			
	}
}
function FLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@CFG0_ERASE();
		! Program CFG0;
		@CFG0_PROGRAM();	
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();		
		! Program DONE bit;
		@FLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_SPIFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@SPISELECT_CFG0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG0;
		@SPICFG0_ERASE();
		! Program CFG0;
		@FULL_SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG0;	
		@FULL_SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASHA_PROGRAM_DONE_BIT();			
	}
}
function SPIFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@SPISELECT_CFG0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG0;
		@SPICFG0_ERASE();
		! Program CFG0;
		@SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG0;	
		@SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_I2CFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@I2CCFG0_ERASE();
		! Program CFG0;
		@FULL_I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG0;	
		@FULL_I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function I2CFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@I2CCFG0_ERASE();
		! Program CFG0;
		@I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG0;	
		@I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function JTAGI2CFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		print (0,"Program CFG Flash A");
		! Select CFG0;
		@JTAGI2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@JTAGI2CCFG0_ERASE();
		! Program CFG0;
		@JTAGI2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@JTAGI2CCFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@JTAGI2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@JTAGI2CCFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@JTAGI2CFLASHA_PROGRAM_DONE_BIT();			
	}
}
function FULL_FLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@CFG1_ERASE();	
		! Program CFG1;
		@FULL_CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@FLASHB_PROGRAM_DONE_BIT();	
	}
}
function FLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@CFG1_ERASE();	
		! Program CFG1;
		@CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@FLASHB_PROGRAM_DONE_BIT();	
	}
}
function FULL_SPIFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SPICFG1_ERASE();	
		! Program CFG1;
		@FULL_SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG1;	
		@FULL_SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASHB_PROGRAM_DONE_BIT();	
	}
}
function SPIFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SPICFG1_ERASE();	
		! Program CFG1;
		@SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify CFG1;	
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASHB_PROGRAM_DONE_BIT();	
	}
}
function FULL_I2CFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@I2CCFG1_ERASE();	
		! Program CFG1;
		@FULL_I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG1;	
		@FULL_I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function I2CFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@I2CCFG1_ERASE();	
		! Program CFG1;
		@I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify CFG1;	
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function JTAGI2CFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		print (0,"Program CFG Flash B");
		! Select CFG1;				
		@JTAGI2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@JTAGI2CCFG1_ERASE();	
		! Program CFG1;
		@JTAGI2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@JTAGI2CCFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@JTAGI2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@JTAGI2CCFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@JTAGI2CFLASHB_PROGRAM_DONE_BIT();	
	}
}
function FLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SELECT_CFG0();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify CFG0;
		@CFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@CFG0_VERIFY_USERCODE();		
		! Select UFM0;
		@SELECT_UFM0();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@UFM0_VERIFY();  
		! Select CFG0;
		@SELECT_CFG0();	   
		! Verify Done Bit;										
		@VERIFY_DONE_BIT(); 										
	}
}
function FULL_SPIFLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG0;
		@FULL_SPICFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@SPICFG0_VERIFY_USERCODE();
		! Select UFM0;
		@SPISELECT_UFM0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@FULL_SPIUFM0_VERIFY();
		! Select CFG0;
		@SPISELECT_CFG0();
		! Verify Done Bit;										
		@SPIVERIFY_DONE_BIT(); 		     										
	}
}
function SPIFLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG0;
		@SPICFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@SPICFG0_VERIFY_USERCODE();		
		! Select UFM0;
		@SPISELECT_UFM0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@SPIUFM0_VERIFY();    
		! Select CFG0;
		@SPISELECT_CFG0(); 	
		! Verify Done Bit;										
		@SPIVERIFY_DONE_BIT(); 									
	}
}
function FULL_I2CFLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@FULL_I2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@I2CCFG0_VERIFY_USERCODE();
		! Select UFM0;
		@I2CSELECT_UFM0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@FULL_I2CUFM0_VERIFY(); 
		! Select CFG0;
		@I2CSELECT_CFG0();  
		! Verify Done Bit;										
		@I2CVERIFY_DONE_BIT();   										
	}
}
function I2CFLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@I2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@I2CCFG0_VERIFY_USERCODE();
		! Select UFM0;
		@I2CSELECT_UFM0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@I2CUFM0_VERIFY(); 
		! Select CFG0;
		@I2CSELECT_CFG0();  
		! Verify Done Bit;										
		@I2CVERIFY_DONE_BIT();   										
	}
}
function JTAGI2CFLASHA_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@JTAGI2CSELECT_CFG0();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@JTAGI2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@JTAGI2CCFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@JTAGI2CFLASHA_VERIFY_DONE_BIT(); 
		! Select UFM0;
		@JTAGI2CSELECT_UFM0();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 		
		! Verify the UFM0;							
		@JTAGI2CUFM0_VERIFY();     										
	}
}
function FLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SELECT_CFG1();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify CFG1;
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();  		
		! Select UFM1;
		@SELECT_UFM1();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM1;
		@UFM1_VERIFY();  
		! Select CFG1;
		@SELECT_CFG1();  
		! Verify Done Bit;
		@VERIFY_DONE_BIT();  	
	}
}
function FULL_SPIFLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SPISELECT_CFG1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG1;
		@FULL_SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();  		
		! Select UFM1;
		@SPISELECT_UFM1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;
		@FULL_SPIUFM1_VERIFY();     
		! Select CFG1;
		@SPISELECT_CFG1();
		! Verify Done Bit;
		@SPIVERIFY_DONE_BIT(); 	
	}
}
function SPIFLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SPISELECT_CFG1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG1;
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();  		
		! Select UFM1;
		@SPISELECT_UFM1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;
		@SPIUFM1_VERIFY();     
		! Select CFG1;
		@SPISELECT_CFG1();
		! Verify Done Bit;
		@SPIVERIFY_DONE_BIT(); 	
	}
}
function FULL_I2CFLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@I2CSELECT_CFG1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@FULL_I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();  		
		! Select UFM1;
		@I2CSELECT_UFM1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@FULL_I2CUFM1_VERIFY();    
		! Select CFG1;
		@I2CSELECT_CFG1();	 
		! Verify Done Bit;
		@I2CVERIFY_DONE_BIT(); 	
	}
}
function I2CFLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@I2CSELECT_CFG1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();  		
		! Select UFM1;
		@I2CSELECT_UFM1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@I2CUFM1_VERIFY();    
		! Select CFG1;
		@I2CSELECT_CFG1();	 
		! Verify Done Bit;
		@I2CVERIFY_DONE_BIT(); 	
	}
}
function JTAGI2CFLASHB_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@JTAGI2CSELECT_CFG1();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@JTAGI2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@JTAGI2CCFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@JTAGI2CFLASHB_VERIFY_DONE_BIT(); 
		! Select UFM1;
		@JTAGI2CSELECT_UFM1();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@JTAGI2CUFM1_VERIFY();     	
	}
}
function FLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SELECT_CFG0();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify CFG0;
		@CFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@CFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@VERIFY_DONE_BIT(); 		  										
	}
}
function FULL_SPIFLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG0;
		@FULL_SPICFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@SPICFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@SPIVERIFY_DONE_BIT(); 		  										
	}
}
function SPIFLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG0;
		@SPICFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@SPICFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@SPIVERIFY_DONE_BIT(); 		  										
	}
}
function FULL_I2CFLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@FULL_I2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@I2CCFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@I2CVERIFY_DONE_BIT(); 		  										
	}
}
function I2CFLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@I2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@I2CCFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@I2CVERIFY_DONE_BIT(); 		  										
	}
}
function JTAGI2CFLASHA_CFG_VERIFY
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@JTAGI2CSELECT_CFG0();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify CFG0;
		@JTAGI2CCFG0_VERIFY();	 
		! Verify CFG0 USERCODE;
		@JTAGI2CCFG0_VERIFY_USERCODE();
		! Verify Done Bit;										
		@JTAGI2CFLASHA_VERIFY_DONE_BIT(); 		  										
	}
}
function FLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SELECT_CFG1();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify CFG1;
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@VERIFY_DONE_BIT(); 		 	
	}
}
function FULL_SPIFLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SPISELECT_CFG1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG1;
		@FULL_SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@SPIVERIFY_DONE_BIT(); 		 	
	}
}
function SPIFLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@SPISELECT_CFG1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify CFG1;
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@SPIVERIFY_DONE_BIT(); 		 	
	}
}
function FULL_I2CFLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@I2CSELECT_CFG1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@FULL_I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@I2CVERIFY_DONE_BIT(); 		 	
	}
}
function I2CFLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@I2CSELECT_CFG1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@I2CVERIFY_DONE_BIT(); 		 	
	}
}
function JTAGI2CFLASHB_CFG_VERIFY
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;
		@JTAGI2CSELECT_CFG1();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify CFG1;
		@JTAGI2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@JTAGI2CCFG1_VERIFY_USERCODE();  
		! Verify Done Bit;
		@JTAGI2CFLASHB_VERIFY_DONE_BIT(); 		 	
	}
}
function UFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@SELECT_UFM0();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM0;
		@UFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@SELECT_UFM1();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM1;
		@UFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@SELECT_UFM2();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM2;
		@UFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@SELECT_UFM3();	
		! Check LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM3;
		@UFM3_VERIFY();
	}
}
function FULL_SPIUFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@SPISELECT_UFM0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM0;
		@FULL_SPIUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@SPISELECT_UFM1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;
		@FULL_SPIUFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@SPISELECT_UFM2();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM2;
		@FULL_SPIUFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@SPISELECT_UFM3();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM3;
		@FULL_SPIUFM3_VERIFY();
	}
}
function SPIUFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@SPISELECT_UFM0();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM0;
		@SPIUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@SPISELECT_UFM1();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;
		@SPIUFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@SPISELECT_UFM2();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM2;
		@SPIUFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@SPISELECT_UFM3();	
		! Check LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM3;
		@SPIUFM3_VERIFY();
	}
}
function FULL_I2CUFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@I2CSELECT_UFM0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM0;
		@FULL_I2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@I2CSELECT_UFM1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@FULL_I2CUFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@I2CSELECT_UFM2();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM2;
		@FULL_I2CUFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@I2CSELECT_UFM3();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM3;
		@FULL_I2CUFM3_VERIFY();
	}
}
function I2CUFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@I2CSELECT_UFM0();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM0;
		@I2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@I2CSELECT_UFM1();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@I2CUFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@I2CSELECT_UFM2();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM2;
		@I2CUFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@I2CSELECT_UFM3();	
		! Check LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM3;
		@I2CUFM3_VERIFY();
	}
}
function JTAGI2CUFM_VERIFY_ONLY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;
		@JTAGI2CSELECT_UFM0();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM0;
		@JTAGI2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;
		@JTAGI2CSELECT_UFM1();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM1;
		@JTAGI2CUFM1_VERIFY();
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;
		@JTAGI2CSELECT_UFM2();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM2;
		@JTAGI2CUFM2_VERIFY();
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;
		@JTAGI2CSELECT_UFM3();	
		! Check LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM3;
		@JTAGI2CUFM3_VERIFY();
	}
}
function FULL_UFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@UFM0_ERASE(); 
		! Program the UFM0;
		@FULL_UFM0_PROGRAM();  
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@UFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM1;
		@UFM1_ERASE(); 
		! Program the UFM1;
		@FULL_UFM1_PROGRAM();  
		! Select UFM1;													
		@SELECT_UFM1();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM1;													
		@UFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SELECT_UFM2();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM2;
		@UFM2_ERASE(); 
		! Program the UFM2;
		@FULL_UFM2_PROGRAM();  
		! Select UFM2;													
		@SELECT_UFM2();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM2;													
		@UFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SELECT_UFM3();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM3;
		@UFM3_ERASE(); 
		! Program the UFM3;
		@FULL_UFM3_PROGRAM(); 
		! Select UFM3;													
		@SELECT_UFM3();	 
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM3;													
		@UFM3_VERIFY(); 
	}
}
function UFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@UFM0_ERASE(); 
		! Program the UFM0;
		@UFM0_PROGRAM();  
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@UFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM1;
		@UFM1_ERASE(); 
		! Program the UFM1;
		@UFM1_PROGRAM();  
		! Select UFM1;													
		@SELECT_UFM1();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK();
		! Verify the UFM1;													
		@UFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SELECT_UFM2();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM2;
		@UFM2_ERASE(); 
		! Program the UFM2;
		@UFM2_PROGRAM();  
		! Select UFM2;													
		@SELECT_UFM2();	
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM2;													
		@UFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SELECT_UFM3();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM3;
		@UFM3_ERASE(); 
		! Program the UFM3;
		@UFM3_PROGRAM(); 
		! Select UFM3;													
		@SELECT_UFM3();	 
		! Check Central Read LOCK information;
		@CHECK_READ_LOCK(); 
		! Verify the UFM3;													
		@UFM3_VERIFY(); 
	}
}
function FULL_SPIUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SPISELECT_UFM0();	
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SPIUFM0_ERASE(); 
		! Program the UFM0;
		@FULL_SPIUFM0_PROGRAM();  
		! Select UFM0;													
		@SPISELECT_UFM0();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM0;													
		@FULL_SPIUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;
		@SPIUFM1_ERASE(); 
		! Program the UFM1;
		@FULL_SPIUFM1_PROGRAM(); 
		! Select UFM1;													
		@SPISELECT_UFM1();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;													
		@FULL_SPIUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SPISELECT_UFM2();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM2;
		@SPIUFM2_ERASE(); 
		! Program the UFM2;
		@FULL_SPIUFM2_PROGRAM(); 
		! Select UFM2;													
		@SPISELECT_UFM2();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM2;													
		@FULL_SPIUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SPISELECT_UFM3();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM3;
		@SPIUFM3_ERASE(); 
		! Program the UFM3;
		@FULL_SPIUFM3_PROGRAM();  
		! Select UFM3;													
		@SPISELECT_UFM3();	
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM3;													
		@FULL_SPIUFM3_VERIFY(); 
	}
}
function SPIUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SPISELECT_UFM0();	
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SPIUFM0_ERASE(); 
		! Program the UFM0;
		@SPIUFM0_PROGRAM();  
		! Select UFM0;													
		@SPISELECT_UFM0();
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM0;													
		@SPIUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;
		@SPIUFM1_ERASE(); 
		! Program the UFM1;
		@SPIUFM1_PROGRAM(); 
		! Select UFM1;													
		@SPISELECT_UFM1();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM1;													
		@SPIUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SPISELECT_UFM2();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM2;
		@SPIUFM2_ERASE(); 
		! Program the UFM2;
		@SPIUFM2_PROGRAM(); 
		! Select UFM2;													
		@SPISELECT_UFM2();	 
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK(); 
		! Verify the UFM2;													
		@SPIUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SPISELECT_UFM3();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM3;
		@SPIUFM3_ERASE(); 
		! Program the UFM3;
		@SPIUFM3_PROGRAM();  
		! Select UFM3;													
		@SPISELECT_UFM3();	
		! Check Central Read LOCK information;
		@SPICHECK_READ_LOCK();
		! Verify the UFM3;													
		@SPIUFM3_VERIFY(); 
	}
}
function FULL_I2CUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		print (0,"Programming UFM0");
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@I2CUFM0_ERASE(); 
		! Program the UFM0;
		@FULL_I2CUFM0_PROGRAM();  
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@FULL_I2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		print (0,"Programming UFM1");
		! Select UFM1;													
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;
		@I2CUFM1_ERASE(); 
		! Program the UFM1;
		@FULL_I2CUFM1_PROGRAM();  
		! Select UFM1;													
		@I2CSELECT_UFM1();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;													
		@FULL_I2CUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		print (0,"Programming UFM2");
		! Select UFM2;													
		@I2CSELECT_UFM2();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK();  
		! Erase UFM2;
		@I2CUFM2_ERASE(); 
		! Program the UFM2;
		@FULL_I2CUFM2_PROGRAM();  
		! Select UFM2;													
		@I2CSELECT_UFM2();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM2;													
		@FULL_I2CUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		print (0,"Programming UFM3");
		! Select UFM3;													
		@I2CSELECT_UFM3();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK();  
		! Erase UFM3;
		@I2CUFM3_ERASE(); 
		! Program the UFM3;
		@FULL_I2CUFM3_PROGRAM(); 
		! Select UFM3;													
		@I2CSELECT_UFM3();	 
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM3;													
		@FULL_I2CUFM3_VERIFY(); 
	}
}
function I2CUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		print (0,"Programming UFM0");
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@I2CUFM0_ERASE(); 
		! Program the UFM0;
		@I2CUFM0_PROGRAM();  
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@I2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		print (0,"Programming UFM1");
		! Select UFM1;													
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;
		@I2CUFM1_ERASE(); 
		! Program the UFM1;
		@I2CUFM1_PROGRAM();  
		! Select UFM1;													
		@I2CSELECT_UFM1();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK(); 
		! Verify the UFM1;													
		@I2CUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		print (0,"Programming UFM2");
		! Select UFM2;													
		@I2CSELECT_UFM2();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK();  
		! Erase UFM2;
		@I2CUFM2_ERASE(); 
		! Program the UFM2;
		@I2CUFM2_PROGRAM();  
		! Select UFM2;													
		@I2CSELECT_UFM2();	
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM2;													
		@I2CUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		print (0,"Programming UFM3");
		! Select UFM3;													
		@I2CSELECT_UFM3();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK();  
		! Erase UFM3;
		@I2CUFM3_ERASE(); 
		! Program the UFM3;
		@I2CUFM3_PROGRAM(); 
		! Select UFM3;													
		@I2CSELECT_UFM3();	 
		! Check Central Read LOCK information;
		@I2CCHECK_READ_LOCK();
		! Verify the UFM3;													
		@I2CUFM3_VERIFY(); 
	}
}
function JTAGI2CUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		print (0,"Programming UFM0");
		! Select UFM0;													
		@JTAGI2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@JTAGI2CUFM0_ERASE(); 
		! Program the UFM0;
		@JTAGI2CUFM0_PROGRAM();  
		! Select UFM0;													
		@JTAGI2CSELECT_UFM0();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM0;													
		@JTAGI2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		print (0,"Programming UFM1");
		! Select UFM1;													
		@JTAGI2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK(); 
		! Erase UFM1;
		@JTAGI2CUFM1_ERASE(); 
		! Program the UFM1;
		@JTAGI2CUFM1_PROGRAM();  
		! Select UFM1;													
		@JTAGI2CSELECT_UFM1();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK(); 
		! Verify the UFM1;													
		@JTAGI2CUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		print (0,"Programming UFM2");
		! Select UFM2;													
		@JTAGI2CSELECT_UFM2();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK();  
		! Erase UFM2;
		@JTAGI2CUFM2_ERASE(); 
		! Program the UFM2;
		@JTAGI2CUFM2_PROGRAM(); 
		! Select UFM2;													
		@JTAGI2CSELECT_UFM2();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK();  
		! Verify the UFM2;													
		@JTAGI2CUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		print (0,"Programming UFM3");
		! Select UFM3;													
		@JTAGI2CSELECT_UFM3();	
		! Check Erase LOCK information;
		@JTAGI2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@JTAGI2CCHECK_PROG_LOCK();  
		! Erase UFM3;
		@JTAGI2CUFM3_ERASE(); 
		! Program the UFM3;
		@JTAGI2CUFM3_PROGRAM(); 
		! Select UFM3;													
		@JTAGI2CSELECT_UFM3();	
		! Check Read LOCK information;
		@JTAGI2CCHECK_READ_LOCK();  
		! Verify the UFM3;													
		@JTAGI2CUFM3_VERIFY(); 
	}
}				
function CFG0_ERASE 
{	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0001);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPICFG0_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00800070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CCFG0_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00800070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CCFG0_ERASE 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function CFG1_ERASE 
{	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0002);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPICFG1_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00400070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CCFG1_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00400070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CCFG1_ERASE 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function UFM0_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0004);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM0_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00200070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM0_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00200070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CUFM0_ERASE 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function UFM1_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0008);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM1_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00100070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM1_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00100070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CUFM1_ERASE 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function UFM2_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0010);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM2_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00080070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM2_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00080070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CUFM2_ERASE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1010);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function UFM3_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0020);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM3_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00040070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM3_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00040070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CUFM3_ERASE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1020);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function CSEC_ERASE
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0040);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPICSEC_ERASE
{
	setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00020070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CCSEC_ERASE
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00020070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CCSEC_ERASE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1040);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function USEC_ERASE
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0080);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUSEC_ERASE
{
	setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00010070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUSEC_ERASE
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00010070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function JTAGI2CUSEC_ERASE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	! Shift in ISC ERASE(0x0E) instruction;
    SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1080);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	loop PWE {
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
		
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}										
function CHECK_SRAM_ERASE_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	}
	ELSE
	{		
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;		  
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_ERASE_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Write Lock is set. Cannot continue.");
	}		
}										
function I2CCHECK_SRAM_ERASE_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x02000000)
				  			MASK(0x02000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_ERASE_LOCK{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x10);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function CHECK_SRAM_PROG_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000400)
				  	MASK(0x00000400);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_PROG_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00200000)
				  			MASK(0x00200000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Write Lock is set. Cannot continue.");
	}		
}
function I2CCHECK_SRAM_PROG_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00200000)
				  			MASK(0x00200000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_PROG_LOCK
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function CHECK_SRAM_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(0x00000800)
				  		MASK(0x00000800);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function I2CCHECK_SRAM_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00100000)
				  			MASK(0x00100000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_READ_LOCK
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x08)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function CHECK_ENABLE_PASSWORD 
{	
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  128  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00010000)
					  		MASK(0x00010020);										  
		}
		ELSE
		{	
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
							  	TDO(0x00000000)
							  	MASK(0x00010000);		  			  
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;          
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SPICHECK_ENABLE_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00008000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
	    	SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}	
function I2CCHECK_ENABLE_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;											  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00008000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function JTAGI2CCHECK_ENABLE_PASSWORD{	
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1]));
		RUN_TEST IDLE TCK 2 DELAY PWP;
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x01)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
					  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}
}
function CHECK_UFM_PASSWORD 
{	
	IF (ProtectKey.row = 1)
	{		
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  128  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00010000)
					  		MASK(0x00010020);										  
		}
		ELSE
		{	
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
							  	TDO(0x00000000)
							  	MASK(0x00020000);			  			  
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;          
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SPICHECK_UFM_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00004000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
	    	SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}	
function I2CCHECK_UFM_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;											  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00004000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function JTAGI2CCHECK_UFM_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
					  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}
}		
function CHECK_PASSWORD 
{	
	IF (ProtectKey.row = 1)
	{		
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  128  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00010000)
					  		MASK(0x00010020);										  
		}
		ELSE
		{	
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
							  	TDO(0x00000000)
							  	MASK(0x00008000);		  			  
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SPICHECK_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00010000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in ISC DISABLE(0x26) instruction;
	    	SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}	
function I2CCHECK_PASSWORD
{	
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;											  
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x00010000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function JTAGI2CCHECK_PASSWORD{	
	datastream SaveProtectKey[1][128];
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x20);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
					  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 200; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100; 	 	
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}
}						
function BURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0000);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
			
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SIR Instruction_Length	TDI (LSC_BITSTREAM_BURST);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
	RUN_TEST	IDLE TCK 100 DELAY PWP;
}
function SPIBURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;			
	setpin ISPEN LOW;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);

	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    setpin ISPEN HIGH;
	RUN_TEST DELAY 500;
}	
function I2CBURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;
		
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    I2C_STOP;
	RUN_TEST DELAY 500;
}
function JTAGI2CBURST_PROGRAM {
	datastream DataByte[1][8];
	int32	ByteCount = 1;
	int32	i = 0;
	FuseArray_TDI.row = 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
	SDR	16	TDI (0x107A);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	ByteCount = TotalFuse/8;
	FuseArray_TDI[1] = $FuseArray_TDI[1];
	repeat ByteCount {
		DataByte[1] = (FuseArray_TDI[1] << i);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;	
		i = i + 8;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST	IDLE TCK 100 DELAY 1000;
}
function PROGRAM_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		SavedControl0[1] = $SavedControl0[1];
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL0);
		SDR 32 TDI(SavedControl0[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
	}
}	
function SPIPROGRAM_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
	    SavedControl0[1] = Control_Register_0_TDI[1];
	    SDR 32 TDI(SavedControl0[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL0 
{
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CPROGRAM_CONTROL0 
{
	datastream DataByte[1][8];
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
		SDR	16	TDI (0x1022);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl0[1] = Control_Register_0_TDI[1];
	    DataByte[1] = SavedControl0[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl0[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl0[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function VERIFY_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		SavedControl0[1] = $SavedControl0[1];
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIVERIFY_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl0[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL0 
{
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CVERIFY_CONTROL0 {
	datastream DataByte[1][8];
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl0[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl0[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
function SAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0);
				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function SPISAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0[1]);
	setpin ISPEN HIGH;	  
	SavedControl0[1] = $SavedControl0[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl0);
	I2C_STOP;			
	SavedControl0[1] = $SavedControl0[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SDR	16	TDI (0x1020);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 				
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1] << 32;
		SavedControl1[1] = $SavedControl1[1];
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL1);
		SDR 32 TDI(SavedControl1[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIPROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1] << 32;	    
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];	    
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1] << 32;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CPROGRAM_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl1[1] = Control_Register_1_TDI[1] << 32;
	    DataByte[1] = SavedControl0[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function PROGRAM_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL1);
		SDR 32 TDI(SavedControl1[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIPROGRAM_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];    
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CPROGRAM_CONTROL1_2 
{
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl1[1] = $Control_Register_1_TDI[1];
	    DataByte[1] = SavedControl1[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);							
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function SRAM_PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL1);
		SDR 32 TDI(SavedControl1[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPISRAM_PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];    
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CSRAM_PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(SavedControl1[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CSRAM_PROGRAM_CONTROL1 
{
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl1[1] = Control_Register_1_TDI[1];
	    DataByte[1] = SavedControl1[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);							
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function VERIFY_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIVERIFY_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl1[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CVERIFY_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
function SAVE_CONTROL1
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 	
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);	
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SPISAVE_CONTROL1 
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);
	setpin ISPEN HIGH;	  
	SavedControl1[1] = $SavedControl1[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL1 
{
	datastream SavedControl1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl1[1]);
	I2C_STOP;			
	SavedControl1[1] = $SavedControl1[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL1 
{
	datastream SavedControl1[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 								   
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SAVE_CONTROL1_2
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);
	SavedControl1[1] = $SavedControl1[1];	
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SPISAVE_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);
	setpin ISPEN HIGH;	  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl1[1]);
	I2C_STOP;			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL1_2 
{
	datastream SavedControl1[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	SavedControl1[1] = $SavedControl1[1];	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SELECT_SRAM
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0000);
	RUN_TEST	IDLE TCK 2 DELAY 	1;	
}
function SRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0000);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
		
	! Shift in LSC_PROG_INCR(0x82) instruction;
    SIR Instruction_Length	TDI	(LSC_PROG_INCR);
	repeat Address_Length {
		! Shift Out Data Row = RowCount;
	    SDR	Row_Width	TDI	(FuseArray_TDI);	    
	    RUN_TEST	IDLE TCK 2 DELAY 	PWP;						
		RowCount = RowCount +1;
	}				
}	
function SPISRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;			
    RUN_TEST DELAY 1000;	
    
	repeat Address_Length{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_INCR(0x82) instruction;
    	SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		RowCount = RowCount +1;			
	} 
		
}
function I2CSRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;
	RUN_TEST DELAY 1000;
    
    repeat Address_Length{
		I2C_START;	
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_INCR(0x82) instruction;
	    SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;	
		RowCount = RowCount +1;			
	} 		
}
function JTAGI2CSRAM_PROGRAM 
{
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");	
}
function FULL_CFG0_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0001);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	  
			RowCount = RowCount +1;		
		} 	
	}
}
function CFG0_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 0;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0001);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
				RUN_TEST IDLE TCK 2 ;	
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST IDLE DELAY 1;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}	
			}  
			RowCount = RowCount +1;		
		} 	
	}
}
function FULL_SPICFG0_PROGRAM {
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		setpin ISPEN HIGH;							
		repeat Temp_Row_Count
		{			
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			setpin ISPEN HIGH;										
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;										  					 							
			}	
			setpin ISPEN HIGH;   					 
			RowCount = RowCount +1;		
		} 	
	}
}
function SPICFG0_PROGRAM {
	int32	RowCount = 1;
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		setpin ISPEN HIGH;							
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
				setpin ISPEN HIGH;									
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
					setpin ISPEN HIGH;													
				}	   						
			}  
			setpin ISPEN HIGH;
			RowCount = RowCount +1;		
		} 	
	}
}
function FULL_I2CCFG0_PROGRAM
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		I2C_STOP;		
		repeat Temp_Row_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;
			RowCount = RowCount +1;		
		} 			
	}
}
function I2CCFG0_PROGRAM
{
	int32	RowCount = 1;
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		I2C_STOP;		
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;					
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	
	}
}
function JTAGI2CCFG0_PROGRAM
{
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		@JTAGI2CSELECT_CFG0();	
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{		    	
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{			
				TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI_CFG0[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1021);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}
			RowCount = RowCount +1;
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function FULL_CFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0002);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	  
			RowCount = RowCount +1;		
		} 	
	}
}
function CFG1_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 65536;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0002);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{		
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
				RUN_TEST IDLE TCK 2 ;	
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST IDLE DELAY 1;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}
			}	  
			RowCount = RowCount +1;		
		} 	
	}
}
function FULL_SPICFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		setpin ISPEN HIGH;			
		repeat Temp_Row_Count
		{			
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			setpin ISPEN HIGH;							
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
				setpin ISPEN HIGH;										
			}	   
			setpin ISPEN HIGH;		
			RowCount = RowCount +1;		
		} 	
	}	
}
function SPICFG1_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		setpin ISPEN HIGH;			
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];			
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
				setpin ISPEN HIGH;									
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
					setpin ISPEN HIGH;													
				}	   						
			}  
			setpin ISPEN HIGH;
			RowCount = RowCount +1;		
		} 	
	}	
}
function FULL_I2CCFG1_PROGRAM
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		I2C_STOP;					
		repeat Temp_Row_Count
		{
			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;	
			RowCount = RowCount +1;		
		} 	
	}
}
function I2CCFG1_PROGRAM
{
	int32	RowCount = 1;
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	IF (FuseArray_TDI_CFG1.row = 1){
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		I2C_STOP;					
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	
	}
}
function JTAGI2CCFG1_PROGRAM 
{
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		@JTAGI2CSELECT_CFG1();	
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = FuseArray_TDI_CFG1[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}		
			RowCount = RowCount +1;				
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function FULL_UFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0004);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 			   
	}
}
function UFM0_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 16384;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0004);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
			{		
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
		    	! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
				RUN_TEST IDLE TCK 2 ;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST DELAY PWV;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function FULL_SPIUFM0_PROGRAM 
{
	int32	RowCount = 1;	
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x002000E2);
		setpin ISPEN HIGH;				
		repeat Temp_UFM_Count
		{				
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			setpin ISPEN HIGH;								
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
				setpin ISPEN HIGH;											
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		   
	}
}
function SPIUFM0_PROGRAM 
{
	int32	RowCount = 1;	
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x002000E2);
		setpin ISPEN HIGH;				
		repeat Temp_UFM_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;				
			}
			ELSE
			{
				setpin ISPEN LOW;	
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
				setpin ISPEN HIGH;										
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);
					setpin ISPEN HIGH;															
				}					 
			}	
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		} 		   
	}
}
function FULL_I2CUFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x002000E2);
		I2C_STOP;			
		repeat Temp_UFM_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			loop PWP {
				I2C_STOP;							
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);				
			}
			I2C_STOP;
			RowCount = RowCount +1;		
		} 	   
	}
}
function I2CUFM0_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x002000E2);
		I2C_STOP;			
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	   
	}
}
function JTAGI2CUFM0_PROGRAM 
{
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		@JTAGI2CSELECT_UFM0();	
		RUN_TEST DELAY 1000;
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = EFuseArray_TDI_UFM0[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1021);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}
			RowCount = RowCount +1;				
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function FULL_UFM1_PROGRAM
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0008);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM_Count{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 			   
	}
}
function UFM1_PROGRAM
{
	int32	RowCount = 1;
	int32   Adrr = 81920;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0008);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
			{		
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
		    	! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
				RUN_TEST IDLE TCK 2 ;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST DELAY PWV;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}
			}	
			RowCount = RowCount +1;
		} 			   
	}
}
function FULL_SPIUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x001000E2);
		setpin ISPEN HIGH;						
		repeat Temp_UFM_Count
		{				
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			setpin ISPEN HIGH;								
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;												
			}	
			setpin ISPEN HIGH; 	
			RowCount = RowCount +1;
		} 		      
	}
}
function SPIUFM1_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x001000E2);
		setpin ISPEN HIGH;						
		repeat Temp_UFM_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];
				setpin ISPEN LOW;	
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;				
			}
			ELSE
			{
				setpin ISPEN LOW;	
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
				setpin ISPEN HIGH;										
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);
					setpin ISPEN HIGH;										
				}	 
			}	
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		} 		      
	}
}
function FULL_I2CUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x001000E2);
		I2C_STOP;		
		repeat Temp_UFM_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;	 
			RowCount = RowCount +1;		
		} 	     
	}
}
function I2CUFM1_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x001000E2);
		I2C_STOP;		
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;					
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	     
	}
}
function JTAGI2CUFM1_PROGRAM
{
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		@JTAGI2CSELECT_UFM1();
		RUN_TEST DELAY 1000;
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = EFuseArray_TDI_UFM1[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1021);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}
			RowCount = RowCount +1;				
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function UFM2_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 131072;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0010);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM2_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
			{		
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
		    	! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
				RUN_TEST IDLE TCK 2 ;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST DELAY PWV;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function FULL_UFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0010);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		repeat Temp_UFM2_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 		   
	}
}
function FULL_SPIUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000800E2);
		setpin ISPEN HIGH;		
		repeat Temp_UFM2_Count
		{				
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			setpin ISPEN HIGH;								
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
				setpin ISPEN HIGH;											
			}	
			setpin ISPEN HIGH; 	
			RowCount = RowCount +1;
		} 		   
	}
}
function SPIUFM2_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000800E2);
		setpin ISPEN HIGH;		
		repeat Temp_UFM2_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;	
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
				setpin ISPEN HIGH;										
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);
					setpin ISPEN HIGH;										
				}					
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		   
	}
}
function FULL_I2CUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000800E2);
		I2C_STOP;		
		repeat Temp_UFM2_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;	
			RowCount = RowCount +1;		
		} 	    
	}
}
function I2CUFM2_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000800E2);
		I2C_STOP;		
		repeat Temp_UFM2_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	    
	}
}
function JTAGI2CUFM2_PROGRAM 
{
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		@JTAGI2CSELECT_UFM2();
		RUN_TEST DELAY 1000;
		repeat Temp_UFM2_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = EFuseArray_TDI_UFM2[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}
			RowCount = RowCount +1;				
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function UFM3_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 147456;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0020);
		RUN_TEST	IDLE TCK 2 DELAY 	1;			
		repeat Temp_UFM3_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
			{		
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SIR Instruction_Length	TDI (LSC_WRITE_ADDRESS); 
		    	SDR 32 TDI(Adrr); 
		    	RUN_TEST	IDLE TCK 2 ;
			}
			ELSE
			{
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
		    	! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
				RUN_TEST IDLE TCK 2 ;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
				loop PWP {
					RUN_TEST DELAY PWV;
					SDR_VERIFY 1 TDI(#0) TDO(#0);
				}
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function FULL_UFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0020);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		repeat Temp_UFM3_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 			   
	}
}
function FULL_SPIUFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000400E2);
		setpin ISPEN HIGH;			
		repeat Temp_UFM3_Count
		{				
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			setpin ISPEN HIGH;					
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);		
				setpin ISPEN HIGH;							
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		 
	}
}
function SPIUFM3_PROGRAM 
{
	int32	RowCount = 1;
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000400E2);
		setpin ISPEN HIGH;			
		repeat Temp_UFM3_Count
		{	
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];
				setpin ISPEN LOW;	
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN LOW;	
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
				setpin ISPEN HIGH;										
				loop PWP {
					RUN_TEST DELAY PWV;
					setpin ISPEN LOW;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					SDR_VERIFY 1 TDI(#0) TDO(#0);
					setpin ISPEN HIGH;										
				}					 
			}	
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		} 		 
	}
}
function FULL_I2CUFM3_PROGRAM {
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000400E2);
		I2C_STOP;
		repeat Temp_UFM3_Count
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;	
			RowCount = RowCount +1;		
		} 	 	   
	}
}
function I2CUFM3_PROGRAM {
	int32	RowCount = 1;
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];
	IF (EFuseArray_TDI_UFM3.row = 1)
	{	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
		SDR 32	TDI (0x000400E2);
		I2C_STOP;
		repeat Temp_UFM3_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
				SDR 32	TDI (0x0000000E);    
				! Shift in Data Row = RowCount; 			
				SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
				loop PWP {
					I2C_STOP;
					RUN_TEST DELAY PWV;
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR 32 TDI (0x0000000F);
					I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);
					SDR_VERIFY 1 TDI(#0) TDO(#0);	
				}
				I2C_STOP;	
			}  
			RowCount = RowCount +1;		
		} 	 	   
	}
}
function JTAGI2CUFM3_PROGRAM 
{
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CProgramDataArray[1][128];
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		@JTAGI2CSELECT_UFM3();
		RUN_TEST DELAY 1000;
		repeat Temp_UFM3_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				TmpJTAGI2CProgramDataArray[1] = EFuseArray_TDI_UFM3[RowCount]; 
		    	TmpJTAGI2CProgramDataArray[1] = $TmpJTAGI2CProgramDataArray[1];
		    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_INCR_NV(0x70) instruction;
		    	SDR	16	TDI (0x1070);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
		    	! Shift in Data Row = RowCount; 	
		    	DataByte[1] = TmpJTAGI2CProgramDataArray[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 32);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 40);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 48);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 56);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 64);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 72);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 80);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 88);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 96);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 104);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 112);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CProgramDataArray[1] << 120);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				
				loop PWP {
					RUN_TEST IDLE TCK 2 DELAY 1;
					! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
					SIR	8	TDI  (0x9D);
					SDR	16	TDI  (0x5000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + WR;
					SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
					RUN_TEST IDLE TCK 1000 ;
					! Shift in LSC_CHECK_BUSY(0xF0) instruction;
					SDR	16	TDI (0x10F0);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x1000);
					RUN_TEST IDLE TCK 1000 ;
					! Shift in Slave Address + RD;
					SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
					RUN_TEST IDLE TCK 1000 ;
					SDR	16	TDI  (0x2000);
					RUN_TEST IDLE TCK 1000 ;
					SIR	8	TDI  (0x9E);
					SDR_VERIFY	8	TDI  (0x00)
									TDO  (0x00)
									MASK (0x80);
				}
			}
			RowCount = RowCount +1;				
		} 	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function SRAM_PROGRAM_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}	
function SPISRAM_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
		setpin ISPEN LOW;
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
		SDR 32	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;
		RUN_TEST IDLE DELAY PWP;
	}
}
function I2CSRAM_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
		I2C_START;	
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
		SDR 32	TDI	(SavedUsercode[1]);
		I2C_STOP;
		RUN_TEST IDLE DELAY PWP;
	}
}
function JTAGI2CPROGRAM_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
	}
}
function SRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0000);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		! Shift in LSC_READ_INCR(0x6A) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR);
		repeat Address_Length {
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function SPISRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		setpin ISPEN HIGH;				
		RUN_TEST DELAY 1000;
		
    	setpin ISPEN LOW;
		! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    SDR 32	TDI	(0xFFFF0856);
	    SDR	Row_Width	TDI	(#0^Row_Width);
		repeat Address_Length {
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			RowCount = RowCount +1;
		}
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function I2CSRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		I2C_STOP;
		RUN_TEST DELAY 1000;
		repeat Address_Length
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
		    SDR 32	TDI	(0x00008456);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI[RowCount])
									MASK(FuseArray_MASK);
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	SDR 32	TDI	(#0^32);						
			I2C_STOP;						
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CSRAM_VERIFY 
{
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");	
}
function SRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0000);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
	
	! Shift in LSC_READ_INCR(0x6A) instruction;
	SIR Instruction_Length	TDI	(LSC_READ_INCR);
	repeat Address_Length {
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#0^Row_Width)
						TDO	(SavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SPISRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY 1000;	

	setpin ISPEN LOW;
	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	SDR 32	TDI	(0xFFFF0856);
	SDR	Row_Width	TDI	(#0^Row_Width);
	repeat Address_Length {
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#0^Row_Width)
								TDO	(SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;
	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function I2CSRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;
	RUN_TEST DELAY 1000;
	
	repeat Address_Length {
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_VERIFY_INCR_RTI(0x6A) instruction;
	    SDR 32	TDI	(0x00008456);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		! Shift out Data Row = RowCount; 			
		SDR	Row_Width	TDI	(#1^Row_Width)
						TDO	(SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;
	}		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function JTAGI2CSRAM_SAVE_ARRAY 
{
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");	
}
function CFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0001);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
				
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
		repeat Temp_Row_Count
		{
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift out Data Row = RowCount; 
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);	
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function CFG0_VERIFY /see log file for more details/ ");
	}					
}
function FULL_SPICFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		setpin ISPEN HIGH;	
		repeat Temp_Row_Count
		{	
	    	setpin ISPEN LOW;
    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000008CE);	    
	    	! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG0_VERIFY /see log file for more details/ ");
	}	
}
function SPICFG0_VERIFY 
{
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;				
    	repeat Temp_Row_Count
    	{	
    		Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;					
			}
			ELSE
			{
	    		setpin ISPEN LOW;
	    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);	    
		    	! Shift out Data Row = RowCount; 			
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(FuseArray_TDI_CFG0[RowCount]);
				setpin ISPEN HIGH;
			}							
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG0_VERIFY /see log file for more details/ ");
	}	
}
function FULL_I2CCFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	I2C_STOP;
	RUN_TEST DELAY 1000;	
	TRY 1 {		     			
		repeat Temp_Row_Count 
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000008CE);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);
			I2C_STOP;														
			RowCount = RowCount +1;
		}
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in NO-OP(0xFF) instruction;
	    SDR	32 	TDI (0xFFFFFFFF);
	    I2C_STOP;		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG0_VERIFY /see log file for more details/ ");
	}				
}
function I2CCFG0_VERIFY 
{
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	I2C_STOP;
	RUN_TEST DELAY 1000;	
	TRY 1 {		     			
		repeat Temp_Row_Count 
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;					
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(FuseArray_TDI_CFG0[RowCount]);
				I2C_STOP;
			}														
			RowCount = RowCount +1;
		}
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in NO-OP(0xFF) instruction;
	    SDR	32 	TDI (0xFFFFFFFF);
	    I2C_STOP;		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG0_VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CCFG0_VERIFY 
{
	int32   Adrr = 0;
	datastream FuseMapAddr[1][32];	
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_CFG0();
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1021);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI_CFG0[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;	
			}	
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;	
		print (1, "Failed in Function CFG0_VERIFY /see log file for more details/ ");
	}
}
function CFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0002);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
			
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
		repeat Temp_Row_Count
		{	
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift out Data Row = RowCount; 
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function CFG1_VERIFY /see log file for more details/ ");
	}					
}
function FULL_SPICFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;	   		
    	repeat Temp_Row_Count
    	{	    		
    		setpin ISPEN LOW;
    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000008CE);	    
	    	! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			setpin ISPEN HIGH;							
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG1_VERIFY /see log file for more details/ ");
	}	
}
function SPICFG1_VERIFY 
{
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;	   		
    	repeat Temp_Row_Count
    	{	
    		Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				setpin ISPEN LOW;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				setpin ISPEN HIGH;		
			}
			ELSE
			{
	    		setpin ISPEN LOW;
	    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);	    
		    	! Shift out Data Row = RowCount; 			
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(FuseArray_TDI_CFG1[RowCount]);
				setpin ISPEN HIGH;	
			}							
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG1_VERIFY /see log file for more details/ ");
	}	
}
function FULL_I2CCFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00400062);
	I2C_STOP;
	RUN_TEST DELAY 1000;	
	TRY 1 {		     			
		repeat Temp_Row_Count 
		{			
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000008CE);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			I2C_STOP;																
			RowCount = RowCount +1;
		}		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in NO-OP(0xFF) instruction;
	    SDR	32 	TDI (0xFFFFFFFF);
	    I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG1_VERIFY /see log file for more details/ ");
	}				
}
function I2CCFG1_VERIFY 
{
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00400062);
	I2C_STOP;
	RUN_TEST DELAY 1000;	
	TRY 1 {		     			
		repeat Temp_Row_Count 
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				FuseMapAddr[1] = $FuseMapAddr[1];	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
		    	SDR 32	TDI (0x0000002D); 
		    	SDR 32 TDI(FuseMapAddr[1]); 
				I2C_STOP;	
			}
			ELSE
			{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				! Shift out Data Row = RowCount; 			
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(FuseArray_TDI_CFG1[RowCount]);
				I2C_STOP;
			}																	
			RowCount = RowCount +1;
		}		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in NO-OP(0xFF) instruction;
	    SDR	32 	TDI (0xFFFFFFFF);
	    I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG1_VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CCFG1_VERIFY 
{
	int32   Adrr = 65536;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_CFG1();
		repeat Temp_Row_Count
		{
			Adrr = Adrr + 1;
			IF (FuseArray_TDI_CFG1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;								
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FC);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FF);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = FuseArray_TDI_CFG1[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			}		
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function CFG1_VERIFY /see log file for more details/ ");
	}
}
function UFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 16 TDI (0x0004);
			RUN_TEST	IDLE TCK 2 DELAY 	1;
						
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM_Count
			{					
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				RowCount = RowCount +1;
			}
			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM0_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_SPIUFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x002000E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;
			repeat Temp_UFM_Count {		    		
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				RowCount = RowCount +1;	
				setpin ISPEN HIGH;									
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM0_VERIFY /see log file for more details/ ");
		}
	}
					
}
function SPIUFM0_VERIFY 
{
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x002000E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM_Count
	    	{	
	    		Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					setpin ISPEN LOW;
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					setpin ISPEN HIGH;		
				}
				ELSE
				{
		    		setpin ISPEN LOW;      	
					! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);		    				
			    	! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM0[RowCount]);
					setpin ISPEN HIGH;
				}					
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM0_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_I2CUFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x002000E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM_Count
			{					
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				I2C_STOP;														
				RowCount = RowCount +1;		
			}		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM0_VERIFY /see log file for more details/ ");
		}
	}		
}
function I2CUFM0_VERIFY 
{
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x002000E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM_Count
			{	
				Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					I2C_STOP;		
				}
				ELSE
				{
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);
				    I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);	
					! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM0[RowCount]);
					I2C_STOP;	
				}													
				RowCount = RowCount +1;		
			}		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM0_VERIFY /see log file for more details/ ");
		}
	}		
}
function JTAGI2CUFM0_VERIFY 
{
	int32   Adrr = 16384;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	EFuseArray_TDI_UFM0.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_UFM0();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM0[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = EFuseArray_TDI_UFM0[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			}		
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function UFM0_VERIFY /see log file for more details/ ");
	}
}
function UFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 16 TDI(0x0008);
			RUN_TEST	IDLE TCK 2 DELAY 	1;
				    	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM_Count{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM1_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_SPIUFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x001000E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM_Count
	    	{		    		
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				setpin ISPEN HIGH;					
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM1_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM1_VERIFY 
{
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x001000E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM_Count
	    	{	
	    		Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					setpin ISPEN LOW;
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					setpin ISPEN HIGH;		
				}
				ELSE
				{
		    		setpin ISPEN LOW;      	
					! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);		    				
			    	! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM1[RowCount]);
					setpin ISPEN HIGH;
				}					
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM1_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_I2CUFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x001000E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM_Count
			{					
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				I2C_STOP;																			
				RowCount = RowCount +1;		
			}		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM1_VERIFY /see log file for more details/ ");
		}
	}		
}
function I2CUFM1_VERIFY 
{
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x001000E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM_Count
			{	
				Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					I2C_STOP;		
				}
				ELSE
				{
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);
				    I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);	
					! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM1[RowCount]);
					I2C_STOP;	
				}																		
				RowCount = RowCount +1;		
			}		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;	
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM1_VERIFY /see log file for more details/ ");
		}
	}		
}
function JTAGI2CUFM1_VERIFY 
{
	int32   Adrr = 81920;
	datastream FuseMapAddr[1][32];	
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	EFuseArray_TDI_UFM1.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_UFM1();
		repeat Temp_UFM_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM1[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FC);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FF);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = EFuseArray_TDI_UFM1[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;	
			}	
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		STATE RESET;		
		STATE IDLE;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function UFM1_VERIFY /see log file for more details/ ");
	}
}
function UFM2_VERIFY {
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 16 TDI(0x0010);
			RUN_TEST	IDLE TCK 2 DELAY 	1;
				  	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM2_Count
			{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM2_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_SPIUFM2_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000800E2);
			setpin ISPEN HIGH;
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM2_Count
	    	{		    		
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				setpin ISPEN HIGH;				
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM2_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM2_VERIFY 
{
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000800E2);
			setpin ISPEN HIGH;
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM2_Count
	    	{	
	    		Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					setpin ISPEN LOW;
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					setpin ISPEN HIGH;		
				}
				ELSE
				{
		    		setpin ISPEN LOW;      	
					! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);		    				
			    	! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM2[RowCount]);
					setpin ISPEN HIGH;
				}					
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM2_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_I2CUFM2_VERIFY 
{
	int32	RowCount = 1;    	
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000800E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM2_Count
			{					
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				I2C_STOP;														
				RowCount = RowCount +1;		
			}	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;		
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM2_VERIFY /see log file for more details/ ");
		}
	}		
}
function I2CUFM2_VERIFY 
{
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;    	
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000800E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM2_Count
			{	
				Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					I2C_STOP;		
				}
				ELSE
				{
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);
				    I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);	
					! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM2[RowCount]);
					I2C_STOP;
				}															
				RowCount = RowCount +1;		
			}	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;		
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM2_VERIFY /see log file for more details/ ");
		}
	}		
}
function JTAGI2CUFM2_VERIFY 
{
	int32   Adrr = 131072;
	datastream FuseMapAddr[1][32];	
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	EFuseArray_TDI_UFM2.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_UFM2();
		repeat Temp_UFM2_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM2[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;								
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FC);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FF);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = EFuseArray_TDI_UFM2[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			}						
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function UFM2_VERIFY /see log file for more details/ ");
	}
}
function UFM3_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 16 TDI(0x0020);
			RUN_TEST	IDLE TCK 2 DELAY 	1;
					   	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM3_Count
			{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM3_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_SPIUFM3_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000400E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM3_Count
	    	{		    		
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				setpin ISPEN HIGH;				
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM3_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM3_VERIFY 
{
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000400E2);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY 1000;			
	    	repeat Temp_UFM3_Count
	    	{	
	    		Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					setpin ISPEN LOW;
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					setpin ISPEN HIGH;		
				}
				ELSE
				{
		    		setpin ISPEN LOW;      	
					! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);		    				
			    	! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM3[RowCount]);
					setpin ISPEN HIGH;
				}					
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM3_VERIFY /see log file for more details/ ");
		}
	}					
}
function FULL_I2CUFM3_VERIFY 
{
	int32	RowCount = 1;   	
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000400E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM3_Count
			{					
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000008CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				I2C_STOP;														
				RowCount = RowCount +1;		
			}	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;		
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM3_VERIFY /see log file for more details/ ");
		}
	}		
}
function I2CUFM3_VERIFY 
{
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];	
	int32	RowCount = 1;   	
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000400E2);
			I2C_STOP;
			RUN_TEST DELAY 1000;			
			repeat Temp_UFM3_Count
			{	
				Adrr = Adrr + 1;
				IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
				{	
					FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
					FuseMapAddr[1] = $FuseMapAddr[1];	
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
					! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
			    	SDR 32	TDI (0x0000002D); 
			    	SDR 32 TDI(FuseMapAddr[1]); 
					I2C_STOP;		
				}
				ELSE
				{
					I2C_START;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
			    	SDR 32	TDI	(0x000008CE);
				    I2C_RESTART;
					! Shift in Slave Address;
					SDR	8	TDI (SLAVE_ADDRESS_READ);	
					! Shift out Data Row = RowCount; 
					SDR_VERIFY	128	TDI	(#0^128)
									TDO	(EFuseArray_TDI_UFM3[RowCount]);
					I2C_STOP;
				}														
				RowCount = RowCount +1;		
			}	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in NO-OP(0xFF) instruction;
		    SDR	32 	TDI (0xFFFFFFFF);
		    I2C_STOP;		
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM3_VERIFY /see log file for more details/ ");
		}
	}		
}
function JTAGI2CUFM3_VERIFY 
{
	int32   Adrr = 147456;
	datastream FuseMapAddr[1][32];
	datastream DataByte[1][8];
	datastream TmpJTAGI2CVerifyDataArray[1][128];
	int32	RowCount = 1;
	EFuseArray_TDI_UFM3.row = 1;
	TRY 1 {
		@JTAGI2CSELECT_UFM3();
		repeat Temp_UFM3_Count
		{
			Adrr = Adrr + 1;
			IF (EFuseArray_TDI_UFM3[RowCount] == 0x00000000000000000000000000000000)
			{	
				FuseMapAddr[1] = Adrr & 0xFFFFFFFF;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_WRITE_ADDRESS(0xB4) instruction;
				SDR	16	TDI (0x10B4); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI (0x1000); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = FuseMapAddr[1];
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 8);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (FuseMapAddr[1] << 16);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;		
				DataByte[1] = (FuseMapAddr[1] << 24);
				SDR	16	TDI ((0x10) @ (DataByte[1])); 
				RUN_TEST IDLE TCK 1000 ;	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;							
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR	16	TDI (0x1073);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FC);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x10FF);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				TmpJTAGI2CVerifyDataArray[1] = EFuseArray_TDI_UFM3[RowCount];
				TmpJTAGI2CVerifyDataArray[1] = $TmpJTAGI2CVerifyDataArray[1];
				! Shift out Data Row = RowCount; 	
		    	DataByte[1] = (TmpJTAGI2CVerifyDataArray[1]);
		    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 8);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 16);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 24);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;	
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 32);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 40);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 48);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 56);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 64);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 72);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 80);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 88);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 96);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 104);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 112);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);
				RUN_TEST IDLE TCK 1000 ;
				DataByte[1] = (TmpJTAGI2CVerifyDataArray[1] << 120);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (DataByte[1]);	
				
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);	
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
			}		
			RowCount = RowCount +1;			
		}
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		STATE RESET;		
		STATE IDLE;		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;			
		print (1, "Failed in Function UFM3_VERIFY /see log file for more details/ ");
	}
}
function FLASHA_SAVE
{
	IF (ISFLASHA == 1)
	{
		@SELECT_CFG0();
		@WARNING_READ_LOCK();
		@CFG0_SAVE_ARRAY();
		@CFG0_SAVE_USERCODE();
		@SELECT_UFM0();
		@WARNING_READ_LOCK();
		@UFM0_SAVE_ARRAY();
	}
}
function SPIFLASHA_SAVE
{
	IF (ISFLASHA == 1)
	{
		@SPISELECT_CFG0();
		@SPIWARNING_READ_LOCK();
		@SPICFG0_SAVE_ARRAY();
		@SPICFG0_SAVE_USERCODE();
		@SPISELECT_UFM0();
		@SPIWARNING_READ_LOCK();
		@SPIUFM0_SAVE_ARRAY();
	}
}
function I2CFLASHA_SAVE
{
	IF (ISFLASHA == 1)
	{
		@I2CSELECT_CFG0();
		@I2CWARNING_READ_LOCK();
		@I2CCFG0_SAVE_ARRAY();
		@I2CCFG0_SAVE_USERCODE();
		@I2CSELECT_UFM0();
		@I2CWARNING_READ_LOCK();
		@I2CUFM0_SAVE_ARRAY();
	}
}
function JTAGI2CFLASHA_SAVE
{
	IF (ISFLASHA == 1)
	{
		@JTAGI2CSELECT_CFG0();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CCFG0_SAVE_ARRAY();
		@JTAGI2CCFG0_SAVE_USERCODE();
		@JTAGI2CSELECT_UFM0();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CUFM0_SAVE_ARRAY();
	}
}
function FLASHB_SAVE
{	
	IF (ISFLASHB == 1)
	{							 
		@SELECT_CFG1();
		@WARNING_READ_LOCK();
		@CFG1_SAVE_ARRAY();							 
		@CFG1_SAVE_USERCODE();
		@SELECT_UFM1();
		@WARNING_READ_LOCK();
		@UFM1_SAVE_ARRAY();
	}
}
function SPIFLASHB_SAVE
{	
	IF (ISFLASHB == 1)
	{							 
		@SPISELECT_CFG1();
		@SPIWARNING_READ_LOCK();
		@SPICFG1_SAVE_ARRAY();							 
		@SPICFG1_SAVE_USERCODE();
		@SPISELECT_UFM1();
		@SPIWARNING_READ_LOCK();
		@SPIUFM1_SAVE_ARRAY();
	}
}
function I2CFLASHB_SAVE
{	
	IF (ISFLASHB == 1)
	{							 
		@I2CSELECT_CFG1();
		@I2CWARNING_READ_LOCK();
		@I2CCFG1_SAVE_ARRAY();							 
		@I2CCFG1_SAVE_USERCODE();
		@I2CSELECT_UFM1();
		@I2CWARNING_READ_LOCK();
		@I2CUFM1_SAVE_ARRAY();
	}
}
function JTAGI2CFLASHB_SAVE
{	
	IF (ISFLASHB == 1)
	{							 
		@JTAGI2CSELECT_CFG1();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CCFG1_SAVE_ARRAY();							 
		@JTAGI2CCFG1_SAVE_USERCODE();
		@JTAGI2CSELECT_UFM1();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CUFM1_SAVE_ARRAY();
	}
}
function FLASHC_SAVE
{	
	IF (ISFLASHC_UFM2 == 1)
	{							 
		@SELECT_UFM2();
		@WARNING_READ_LOCK();
		@UFM2_SAVE_ARRAY();							 
	}
	IF (ISFLASHC_UFM3 == 1)
	{							 
		@SELECT_UFM3();
		@WARNING_READ_LOCK();
		@UFM3_SAVE_ARRAY();							 
	}
}
function SPIFLASHC_SAVE
{	
	IF (ISFLASHC_UFM2 == 1)
	{							 
		@SPISELECT_UFM2();
		@SPIWARNING_READ_LOCK();
		@SPIUFM2_SAVE_ARRAY();							 
	}
	IF (ISFLASHC_UFM3 == 1)
	{							 
		@SPISELECT_UFM3();
		@SPIWARNING_READ_LOCK();
		@SPIUFM3_SAVE_ARRAY();							 
	}
}
function I2CFLASHC_SAVE
{	
	IF (ISFLASHC_UFM2 == 1)
	{							 
		@I2CSELECT_UFM2();
		@I2CWARNING_READ_LOCK();
		@I2CUFM2_SAVE_ARRAY();							 
	}
	IF (ISFLASHC_UFM3 == 1)
	{							 
		@I2CSELECT_UFM3();
		@I2CWARNING_READ_LOCK();
		@I2CUFM3_SAVE_ARRAY();							 
	}
}
function JTAGI2CFLASHC_SAVE
{	
	IF (ISFLASHC_UFM2 == 1)
	{							 
		@JTAGI2CSELECT_UFM2();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CUFM2_SAVE_ARRAY();							 
	}
	IF (ISFLASHC_UFM3 == 1)
	{							 
		@JTAGI2CSELECT_UFM3();
		@JTAGI2CWARNING_READ_LOCK();
		@JTAGI2CUFM3_SAVE_ARRAY();							 
	}
}
function SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPISAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CSAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}

function SRAM_DISPLAY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	print (0,"SRAM USERCODE is:");
	print (0,SavedUsercode);
}
function SPISRAM_DISPLAY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"SRAM USERCODE is:");
	print (0,SavedUsercode);
}
function I2CSRAM_DISPLAY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"SRAM USERCODE is:");
	print (0,SavedUsercode);
}


function DISPLAY_CFG0_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	print (0,"CFG0 USERCODE is");
	print (0,SavedUsercode);
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPIDISPLAY_CFG0__USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"CFG0 USERCODE is");
	print (0,SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CDISPLAY_CFG0__USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	print (0,"CFG0 USERCODE is");
	print (0,SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CDISPLAY_CFG0_USERCODE 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	print (0,"CFG0 USERCODE is");
	print (0,SavedUsercode);
	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function DISPLAY_CFG1_USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(TmpSavedUsercode);
	// Write To file 
	print (0,"CFG1 USERCODE is");
	print (0,TmpSavedUsercode);
}
function SPIDISPLAY_CFG1__USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(TmpSavedUsercode);
	setpin ISPEN HIGH;
	TmpSavedUsercode[1] = $TmpSavedUsercode[1];
	print (0,"CFG1 USERCODE is");
	print (0,TmpSavedUsercode);
}
function I2CDISPLAY_CFG1__USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(TmpSavedUsercode);
	I2C_STOP;
	TmpSavedUsercode[1] = $TmpSavedUsercode[1];
	print (0,"CFG1 USERCODE is");
	print (0,TmpSavedUsercode);
}
function JTAGI2CDISPLAY_CFG1_USERCODE 
{
	datastream DataByte[1][8];
	datastream TmpSavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	print (0,"CFG1 USERCODE is");
	print (0,TmpSavedUsercode);
	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, TmpSavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CSAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}

function CFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SELECT_CFG0();
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function SPICFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SPISELECT_CFG0();
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	SavedUsercode[1] = $SavedUsercode[1];
	setpin ISPEN HIGH;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function I2CCFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@I2CSELECT_CFG0();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	SavedUsercode[1] = $SavedUsercode[1];
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CCFG0_SAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@JTAGI2CSELECT_CFG0();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}

function CFG1_SAVE_USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SELECT_CFG1();
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(TmpSavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, TmpSavedUsercode);
	fclose 	NewFile;
}
function SPICFG1_SAVE_USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@SPISELECT_CFG1();
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(TmpSavedUsercode);
	TmpSavedUsercode[1] = $TmpSavedUsercode[1];
	setpin ISPEN HIGH;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, TmpSavedUsercode);
	fclose 	NewFile;
}
function I2CCFG1_SAVE_USERCODE 
{
	datastream TmpSavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@I2CSELECT_CFG1();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(TmpSavedUsercode);
	TmpSavedUsercode[1] = $TmpSavedUsercode[1];
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, TmpSavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CCFG1_SAVE_USERCODE {
	datastream DataByte[1][8];
	datastream TmpSavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	@JTAGI2CSELECT_CFG1();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpSavedUsercode[1] = ((TmpSavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, TmpSavedUsercode);
	fclose 	NewFile;
}
function SAVE_STATUS 
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS0);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
			
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS1);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SPISAVE_STATUS	
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
	setpin ISPEN HIGH;			
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	setpin ISPEN HIGH;		
	SavedSTATUS0[1] = $SavedSTATUS0[1];
	SavedSTATUS1[1] = $SavedSTATUS1[1];
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function I2CSAVE_STATUS	
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
	I2C_STOP;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	I2C_STOP;
	SavedSTATUS0[1] = $SavedSTATUS0[1];
	SavedSTATUS1[1] = $SavedSTATUS1[1];
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function JTAGI2CSAVE_STATUS	{
	datastream DataByte[1][8];
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS0[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000C00);
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	RUN_TEST IDLE TCK 2 DELAY PWP;
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00000800);
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                ! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
					  				TDO(0x00000800)
					  				MASK(0x00000800);
			}
			ELSE
			{
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	RUN_TEST IDLE TCK 2 DELAY PWP;
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00000000)
					  		MASK(0x00000400);
		}
		ELSE
		{
			TRY 1 {
                ! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
					  				TDO(0x00000400)
					  				MASK(0x00000400);
			}
			ELSE
			{
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function SRAM_SECURE_SVF
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000800);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000400);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000C00);
	}
}
function SPISRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00300000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	setpin ISPEN HIGH;
	    	RUN_TEST DELAY PWP;
	    	setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00100000);
			setpin ISPEN HIGH;
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                setpin ISPEN LOW;
		    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00100000)
						  	MASK(0x00100000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	setpin ISPEN HIGH;
	    	RUN_TEST DELAY PWP;
	    	setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00200000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
                setpin ISPEN LOW;
		    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00200000)
						  	MASK(0x00200000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function SPISRAM_SECURE_SVF
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00100000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00200000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00300000);
		setpin ISPEN HIGH;
	}
}
function I2CSRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00300000);
		I2C_STOP;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00100000);
			I2C_STOP;
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00100000)
						  	MASK(0x00100000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x00200000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00200000)
						  	MASK(0x00200000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function I2CSRAM_SECURE_SVF
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00100000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00200000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00300000);
		I2C_STOP;
	}
}
function JTAGI2CSRAM_SECURE
{
	datastream DataByte[1][8];
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;

    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x0C);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = LockBitsArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;			
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x08);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
	    }
	    ELSE
	    {
	    	TRY 1 {
                ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);			
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x08)
								MASK (0x08);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ; 
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ; 
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}

	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;		
			DataByte[1] = LockBitsArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x04);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
		}
		ELSE
		{
			TRY 1 {
                ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);			
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR	16	TDI (0x103C);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x04);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ; 
			}
			ELSE
			{
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ; 
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}	
}
function PROGRAM_AUTH_DONE_A
{
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SIR	Instruction_Length 	TDI (LSC_PROGRAM_AUTH_DONE);
	RUN_TEST	IDLE TCK 2 DELAY 1000;				
	//print (0,"Verify the Flash AUTH_DONE_CFG0...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG0 (bit10) of the Status Register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000400)
						MASK(0x00000400);
		print (0,"Flash A Authentication Passed.");												  		  		    
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (0,"Flash A Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
	
}
function SPIPROGRAM_AUTH_DONE_A
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SDR	32 	TDI (0x00000033);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 1000;
	//print (0,"Verify the Flash AUTH_DONE_CFG0...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG0 (bit10) of the Status Register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00200000)
						MASK(0x00200000);
		setpin ISPEN HIGH;
		print (0,"Flash A Authentication Passed.");				  		  		    
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (0,"Flash A Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}
function I2CPROGRAM_AUTH_DONE_A
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SDR	32 	TDI (0x00000033);
	I2C_STOP;
	RUN_TEST DELAY 1000; 
	//print (0,"Verify the Flash AUTH_DONE_CFG0...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG0 (bit10) of the Status Register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00200000)
						MASK(0x00200000);
		I2C_STOP;	
		print (0,"Flash A Authentication Passed.");			  		  		    
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (0,"Flash A Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}
function JTAGI2CPROGRAM_AUTH_DONE_A
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
	SDR	16	TDI (0x10CC);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
   	RUN_TEST	IDLE TCK 2 DELAY 1000;				
	//print (0,"Verify the Flash AUTH_DONE_CFG0...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG0 (bit10) of the Status Register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x04);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (0,"Flash A Authentication Passed.");												  		  		    
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (0,"Flash A Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}
function PROGRAM_AUTH_DONE_B
{
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SIR	Instruction_Length 	TDI (LSC_PROGRAM_AUTH_DONE);
	RUN_TEST	IDLE TCK 2 DELAY 1000;				
	//print (0,"Verify the Flash AUTH_DONE_CFG1...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG1 (bit11) of the Status Register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000800)
						MASK(0x00000800);	
		print (0,"Flash B Authentication Passed.");											  		  		    
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (0,"Flash B Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
	
}
function SPIPROGRAM_AUTH_DONE_B
{
	setpin ISPEN LOW;
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SDR	32 	TDI (0x00000033);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 1000;
	//print (0,"Verify the Flash AUTH_DONE_CFG1...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG1 (bit11) of the Status Register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00100000)
						MASK(0x00100000);
		setpin ISPEN HIGH;			
		print (0,"Flash B Authentication Passed.");	  		  		    
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (0,"Flash B Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}
function I2CPROGRAM_AUTH_DONE_B
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
    SDR	32 	TDI (0x00000033);
	I2C_STOP;
	RUN_TEST DELAY 1000; 
	//print (0,"Verify the Flash AUTH_DONE_CFG1...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG1 (bit11) of the Status Register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00100000)
						MASK(0x00100000);
		I2C_STOP;	
		print (0,"Flash B Authentication Passed.");		  		  		    
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (0,"Flash B Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}
function JTAGI2CPROGRAM_AUTH_DONE_B
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC_PROGRAM_AUTH_DONE(0xCC) instruction;
	SDR	16	TDI (0x10CC);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
   	RUN_TEST	IDLE TCK 2 DELAY 1000;				
	//print (0,"Verify the Flash AUTH_DONE_CFG1...");
	TRY 1 {
		// check bit Flash AUTH_DONE_CFG1 (bit11) of the Status Register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x08)
						MASK (0x08);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
		print (0,"Flash B Authentication Passed.");											  		  		    
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (0,"Flash B Authentication Failed.");
		print (1,"Version Rollback Protection feature might be enabled?");
	}
}	
function PROGRAM_DONE_BIT 
{
	TRY 1 {
		! Shift in ISC PROGRAM DONE(0x5E) instruction;
		SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
		RUN_TEST	IDLE TCK 2 DELAY 1000;
					
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00002100);
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program SRAM Done Bit.");	
	}
}
function SPISRAMPROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00800000)
			  		MASK(0x00840000);	
	setpin ISPEN HIGH;
}

function I2CSRAMPROGRAM_DONE_BIT 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR 32 TDI (0x0000007A);
	I2C_STOP
	RUN_TEST DELAY PWP; 
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);	
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00800000)
			  		MASK(0x00840000);			
	I2C_STOP;	
}
function JTAGI2CSRAMPROGRAM_DONE_BIT 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;										
}	
function DISABLE 
{
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 100 DELAY 100;
}
function SPIDISABLE 
{
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	24 	TDI (0x000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
    setpin ISPEN LOW;
	! Shift in NO-OP(0xFF) instruction;
    SDR	32 	TDI (0xFFFFFFFF);
    setpin ISPEN HIGH;
}
function I2CDISABLE	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function I2CDISABLE_DEFAULT	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (0x01);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function I2CFEATUREDISABLE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function JTAGI2CDISABLE	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	        	    	
}	
function JTAGI2CFEATUREDISABLE
{
	datastream JTAGI2CN_WRITE[1][8];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	        	    	
}
function JTAGI2CDISABLE_REFRESH	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;  
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;		
}																	
function REFRESH_FUNCTION 
{
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
    RUN_TEST IDLE TCK 2 DELAY 1000; 

	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 5000;
}				
function SPIREFRESH_FUNCTION 
{
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 5000;
}
function I2CREFRESH_FUNCTION 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    RUN_TEST DELAY 5000;	
}
function JTAGI2CREFRESH_FUNCTION 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 5000;		
}																								
function SRAM_TRANSPARENT_READ_ENABLE 
{
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SPISRAM_TRANSPARENT_READ_ENABLE 
{
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_ENABLE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_ENABLE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function SRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
	RUN_TEST	IDLE	TCK 2 ;

	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY PWP;
}
function SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function VERIFY_STATUS {
	TRY 1 {
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
	    SDR_VERIFY	32	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00002100);
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x02000000)
						MASK(0x02000000);
			print (1, "The Authentication has failed/see log file for more details/ ");						
		}
		ELSE
		{
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function SPIVERIFY_STATUS {
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x00840000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x00000040)
						MASK(0x00000040);
			setpin ISPEN HIGH;
			print (1, "The Authentication has failed/see log file for more details/ ");						
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function I2CVERIFY_STATUS {
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x00840000);
		I2C_STOP;	
	}
	ELSE
	{
		TRY 1 {
			I2C_STOP;
			I2C_START;		
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x00000040)
						MASK(0x00000040);
			I2C_STOP;
			print (1, "The Authentication has failed /see log file for more details/ ");						
		}
		ELSE
		{
			I2C_STOP;
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function JTAGI2CVERIFY_STATUS {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x21);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;					
	}
	ELSE
	{
		print (1, "Failed to Verify DONE bit /see log file for more details/ ");
	}
}
function FLASH_ENABLE
{
	@SRAM_ENABLE();
	@SRAM_ERASE();
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;

}
function FLASH_ENABLE_READ_ID
{
	@FLASH_ENABLE();		
    TRY 1{
		! Shift in IDCODE_PUB(0xE0) instruction;
    	SIR Instruction_Length 	TDI (IDCODE_PUB);
		SDR_VERIFY	ID_Length	TDI (#0^ID_Length)
					        TDO	(IDTDI[1])
					        MASK (DEVICE_ID_MASK);
	}	
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 100 DELAY 100;
		print (1,"Failed to read the Device's IDCODE.");
	}
}
function SPIFLASH_ENABLE 
{
	@SPISRAM_ENABLE();
	@SPISRAM_ERASE();
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    setpin ISPEN HIGH;	
    RUN_TEST DELAY PWV;
}
function SPIFLASH_ENABLE_READ_ID
{
	IDTDI[1] = $IDTDI[1];
	@SPIFLASH_ENABLE();		
    TRY 1{
		setpin ISPEN LOW;
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);		
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		setpin ISPEN HIGH;	
	}	
	ELSE
	{	
		setpin ISPEN HIGH;			
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
	    RUN_TEST DELAY 200;   
		print (1,"Failed to read the Device's IDCODE.");
	}
}
function I2CFLASH_ENABLE 
{
	@I2CSRAM_ENABLE();
	@I2CSRAM_ERASE();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    I2C_STOP;	
    RUN_TEST DELAY PWV;
}
function I2CFLASH_ENABLE_READ_ID
{
	IDTDI[1] = $IDTDI[1];
	@I2CFLASH_ENABLE();		
    TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		I2C_STOP;
	}	
	ELSE
	{	
		I2C_STOP;		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
	    RUN_TEST DELAY 200;   
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}
}
function JTAGI2CFLASH_ENABLE 
{	
	@JTAGI2CSRAM_ENABLE();
	@JTAGI2CSRAM_ERASE();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);					
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function FLASH_TRANSPARENT_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SPIFLASH_TRANSPARENT_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
}
function I2CFLASH_TRANSPARENT_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}	
function JTAGI2CFLASH_TRANSPARENT_ENABLE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function SELECT_TRIM{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0800);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_TRIM{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00001062);
	setpin ISPEN HIGH;				
}
function I2CSELECT_TRIM{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00001062);
	I2C_STOP;		
}
function JTAGI2CSELECT_TRIM
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function SELECT_AESKEY{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0200);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_AESKEY{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00004062);
	setpin ISPEN HIGH;			
}
function I2CSELECT_AESKEY
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00004062);
	I2C_STOP;			
}
function JTAGI2CSELECT_AESKEY
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;		
}	
function SELECT_FEA{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0400);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_FEA{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00002062);
	setpin ISPEN HIGH;				
}
function I2CSELECT_FEA{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00002062);
	I2C_STOP;		
}
function JTAGI2CSELECT_FEA
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function SELECT_PUBKEY{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0100);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_PUBKEY{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00008062);
	setpin ISPEN HIGH;				
}
function I2CSELECT_PUBKEY{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00008062);
	I2C_STOP;		
}
function JTAGI2CSELECT_PUBKEY
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}		
function SELECT_CFG0
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0001);
	RUN_TEST	IDLE TCK 2 DELAY 	1;	
}
function SPISELECT_CFG0
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	setpin ISPEN HIGH;			
}
function I2CSELECT_CFG0
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	I2C_STOP;		
}
function JTAGI2CSELECT_CFG0
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function SELECT_CFG1
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0002);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_CFG1
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00400062);
	setpin ISPEN HIGH;		
}
function I2CSELECT_CFG1
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00400062);
	I2C_STOP;		
}
function JTAGI2CSELECT_CFG1
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function SELECT_UFM0
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0004);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_UFM0
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00200062);
	setpin ISPEN HIGH;		
}
function I2CSELECT_UFM0
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00200062);
	I2C_STOP;		
}
function JTAGI2CSELECT_UFM0
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}		
function SELECT_UFM1
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0008);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_UFM1
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00100062);
	setpin ISPEN HIGH;		
}
function I2CSELECT_UFM1
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00100062);
	I2C_STOP;		
}						
function JTAGI2CSELECT_UFM1
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1008);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function SELECT_UFM2{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0010);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_UFM2{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00080062);
	setpin ISPEN HIGH;			
}
function I2CSELECT_UFM2{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00080062);
	I2C_STOP;		
}
function JTAGI2CSELECT_UFM2
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1010);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}	
function SELECT_UFM3{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0020);
	RUN_TEST	IDLE TCK 2 DELAY 	1;	
}
function SPISELECT_UFM3{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00040062);
	setpin ISPEN HIGH;		
}
function I2CSELECT_UFM3{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00040062);
	I2C_STOP;		
}	
function JTAGI2CSELECT_UFM3
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1020);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function SELECT_CSEC
{	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0040);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_CSEC
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00020062);
	setpin ISPEN HIGH;				
}
function I2CSELECT_CSEC
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00020062);
	I2C_STOP;		
}
function JTAGI2CSELECT_CSEC
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1040);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}		
function SELECT_USEC
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 16 TDI(0x0080);
	RUN_TEST	IDLE TCK 2 DELAY 	1;		
}
function SPISELECT_USEC
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00010062);
	setpin ISPEN HIGH;			
}
function I2CSELECT_USEC
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00010062);
	I2C_STOP;		
}					
function JTAGI2CSELECT_USEC
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1080);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
}
function FEATURE_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0400);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIFEATURE_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    setpin ISPEN HIGH;
	loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CFEATURE_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    I2C_STOP;
    RUN_TEST DELAY PWP;       
}				
function JTAGI2CFEATURE_ERASE
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1004);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 2000;   
}
function AESKEY_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0200);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIAESKEY_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    setpin ISPEN HIGH;
	loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CAESKEY_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}	
    I2C_STOP;    
}	
function JTAGI2CAESKEY_ERASE
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1002);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 2000;
} 
function PUBKEY_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0100);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIPUBKEY_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CPUBKEY_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}	
    I2C_STOP;   
}
function JTAGI2CPUBKEY_ERASE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 2000;
}  	
function FEATURE_PROGRAM {
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 32;
		FeatureArray[1] = $FeatureArray[1];
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 128 TDI((#0^32) @ FeatureArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
	    RUN_TEST IDLE TCK 2 ;  
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    SDR_VERIFY 128   TDI(#0^128)
	    				TDO((#0^32) @ FeatureArray[1] )
						MASK(0x00000000FFFFFFFFFFFFFFFFFFFFFFFF);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 32 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0001FFFF);
	    
	}
}
function SPIFEATURE_PROGRAM{
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 32;
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 128 TDI(FeatureArray[1] @ (#0^32));
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    SDR_VERIFY 128   TDI(#0^128)
	    				TDO(FeatureArray[1] @ (#0^32))
						MASK(0xFFFFFFFFFFFFFFFFFFFFFFFF00000000);
	    setpin ISPEN HIGH;	
	    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    setpin ISPEN LOW; 
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 32 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0001FFFF);
	    setpin ISPEN HIGH;			
	}
}
function I2CFEATURE_PROGRAM
{
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{	
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 32 TDI(FeatureBitsArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (0x81);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFF8000);
	    I2C_STOP;	 
	    FeatureArray[1] = ArchArray_TDI[1] << 32;
	    //print (0,FeatureArray);
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 128 TDI(FeatureArray[1] @ (#0^32));
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_READ );
	    SDR_VERIFY 128   TDI(#0^128)
	    				TDO(FeatureArray[1] @ (#0^32))
						MASK(0xFFFFFFFFFFFFFFFFFFFFFFFF00000000);
	    I2C_STOP;			    
	}
}
function JTAGI2CFEATURE_PROGRAM
{
	datastream DataByte[1][8];
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	datastream JTAGI2CSLAVEADDRWRITE[1][8];
	datastream JTAGI2CSLAVEADDRREAD[1][8];
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	
	JTAGI2CSLAVEADDRWRITE[1] = (DEFAULT_ADDR_WRITE) ;
	JTAGI2CSLAVEADDRWRITE[1] = $JTAGI2CSLAVEADDRWRITE[1];
	JTAGI2CSLAVEADDRREAD[1] = (DEFAULT_ADDR_READ) ;
	JTAGI2CSLAVEADDRREAD[1] = $JTAGI2CSLAVEADDRREAD[1];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	IF (ArchArray_TDI.row = 1)
	{
		TRY 1
		{
			FeatureArray[1] = ArchArray_TDI[1] << 32;
			FeatureArray[1] = $FeatureArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_FEATURE( 0xE4) instruction;		
			SDR	16	TDI (0x10E4);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 32);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 40);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST	IDLE TCK 2 DELAY 1;
			DataByte[1] = (FeatureArray[1] << 48);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 56);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 64);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 72);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 80);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureArray[1] << 88);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1; 		
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR	16	TDI (0x10E7);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_READ[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureArray[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (FeatureArray[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 64);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 72);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);	
			DataByte[1] = (FeatureArray[1] << 80);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureArray[1] << 88);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);											
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			FeatureBitsArray[1] = ArchArray_TDI[1];
			FeatureBitsArray[1] = $FeatureBitsArray[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
			SDR	16	TDI (0x10F8);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureBitsArray[1];
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureBitsArray[1] << 8);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureBitsArray[1] << 16);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (FeatureBitsArray[1] << 24);
			SDR	16	TDI ((0x10) @ (DataByte[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1])); 
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in in LSC_READ_FEABITS(0xFB) instruction;
			SDR	16	TDI (0x10FB);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			! Shift in Slave Address + RD;
			SDR	16	TDI ((0x90) @ (JTAGI2CN_READ[1])); 
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = FeatureBitsArray[1];
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureBitsArray[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureBitsArray[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (FeatureBitsArray[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0x00);					
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				 
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;		
			print (1,"Programming Feature Row Failed. Cannot continue.");			
		}
	}
}
function CHECK_ERASE_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000010);
	}
	ELSE
	{		
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;		  
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}
function SPICHECK_ERASE_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}		
}	
function I2CCHECK_ERASE_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}	

function JTAGI2CCHECK_ERASE_LOCK
{
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x10);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;						  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}	
function CHECK_PROG_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"Current Sector Program Lock is set. Cannot continue. Please do erase first.");
	}
}
function SPICHECK_PROG_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Current Sector Program Lock is set. Cannot continue. Please do erase first");
	}		
}
function I2CCHECK_PROG_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"Current Sector Program Lock is set. Cannot continue. Please do erase first");
	}
}
function JTAGI2CCHECK_PROG_LOCK
{
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;					  
		print (1,"Current Sector Program Lock is set. Cannot continue. Please do erase first.");
	}
}	
function CHECK_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function SPICHECK_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"Current Sector Lock is set. Cannot continue.");
	}
}
function I2CCHECK_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_READ_LOCK
{
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;					  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function WARNING_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 1.");
	}
}
function SPIWARNING_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 1.");
	}
}
function I2CWARNING_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 1.");
	}
}
function JTAGI2CWARNING_READ_LOCK
{	
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ; 
	}
	ELSE
	{
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 1.");
	}
}
function PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	RUN_TEST IDLE TCK 2 DELAY PWP;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000040)
					  	MASK(0x00000040);
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                ! Shift in LSC_READ_STATUS1(0x3D) instruction;
                SIR Instruction_Length TDI (LSC_READ_STATUS1);
                RUN_TEST IDLE TCK 2 DELAY PWV; 
                SDR_TRY_VERIFY  32       TDI(#0^32)
                                         TDO(0x00000000)
                                         MASK(0x00000040);
			}
			ELSE
			{
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}

	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	RUN_TEST IDLE TCK 2 DELAY PWP;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000020)
					  	MASK(0x00000020);
		}
		ELSE
		{
			TRY 1 {
                ! Shift in LSC_READ_STATUS1(0x3D) instruction;
                SIR Instruction_Length TDI (LSC_READ_STATUS1);
                RUN_TEST IDLE TCK 2 DELAY PWV; 
                SDR_TRY_VERIFY  32       TDI(#0^32)
                                         TDO(0x00000000)
                                         MASK(0x00000020);
			}
			ELSE
			{
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}	
}
function SVF_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIPROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	setpin ISPEN HIGH;
	    	RUN_TEST DELAY PWP;
	    	setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x02000000)
					  	MASK(0x02000000);
			setpin ISPEN HIGH;		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                setpin ISPEN LOW;
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
						  			TDO(0x00000000)
						  			MASK(0x02000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	setpin ISPEN HIGH;
	    	RUN_TEST DELAY PWP;
	    	setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x04000000)
					  	MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
                setpin ISPEN LOW;
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
						  			TDO(0x00000000)
						  			MASK(0x04000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function SPISVF_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CPROGRAM_NEW_ADDRESS_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x02000000)
					  	MASK(0x02000000);
			I2C_STOP;
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (NEW_I2C_ADDR_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00000000)
						  	MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (NEW_I2C_ADDR_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x04000000)
					  	MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (NEW_I2C_ADDR_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00000000)
						  	MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function I2CSVF_PROGRAM_NEW_ADDRESS_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (NEW_I2C_ADDR_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function I2CPROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x02000000)
					  	MASK(0x02000000);
			I2C_STOP;
		    
	    }
	    ELSE
	    {
	    	TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00000000)
						  	MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector read lock is set. Erase the sector to un-lock");
			}
	    }
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
	    	SDR 32	TDI (0x00000073);
	    	SDR 8 TDI(LockBitsArray[1]);
	    	I2C_STOP;
	    	RUN_TEST DELAY PWP;
	    	I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x04000000)
					  	MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
                I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  	TDO(0x00000000)
						  	MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current sector program lock is set. Erase the sector to un-lock");
			}
		}
	}
}
function I2CSVF_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function JTAGI2CPROGRAM_LOCK
{
	datastream DataByte[1][8];
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1006);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;

    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;		
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR	16	TDI (0x103D);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x40)
							MASK (0x40);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
	    }	    
	    // Lock SEC_PROG_L
		IF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1002);
			RUN_TEST IDLE TCK 1000 ;		
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR	16	TDI (0x103D);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x20)
							MASK (0x20);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
		}		
	}	
}
function JTAGI2CSVF_PROGRAM_LOCK
{
	datastream DataByte[1][8];
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L SEC_PROG_L
	IF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1006);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		// Lock SEC_READ_L
		IF (ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;		
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR	16	TDI (0x103D);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x40)
							MASK (0x40);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
	    }
	    // Lock SEC_PROG_L
		ELSEIF (ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
			SDR	16	TDI (0x10CE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1002);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;		
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 2 DELAY 1;
			
	    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR	16	TDI (0x103D);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x20)
							MASK (0x20);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ; 
		}
	}	
}	
function CSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000010)
				  	MASK(0x00000010);
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000050)
				  	MASK(0x00000050);
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000030)
				  	MASK(0x00000030);
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (CSEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000C0)
				  	MASK(0x000000C0);
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000A0)
				  	MASK(0x000000A0);
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000090)
				  	MASK(0x00000090);
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000E0)
				  	MASK(0x000000E0);
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000D0)
				  	MASK(0x000000D0);
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000B0)
				  	MASK(0x000000B0);
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000F0)
				  	MASK(0x000000F0);
	}	
}
function SPICSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x08000000)
				  	MASK(0x08000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0A000000)
				  	MASK(0x0A000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0C000000)
				  	MASK(0x0C000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (CSEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x03000000)
				  	MASK(0x03000000);
		setpin ISPEN HIGH;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x05000000)
				  	MASK(0x05000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x09000000)
				  	MASK(0x09000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x07000000)
				  	MASK(0x07000000);
		setpin ISPEN HIGH;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0B000000)
				  	MASK(0x0B000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0D000000)
				  	MASK(0x0D000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0F000000)
				  	MASK(0x0F000000);
		setpin ISPEN HIGH;
	}
}
function I2CCSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x08000000)
				  	MASK(0x08000000);
		I2C_STOP;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0A000000)
				  	MASK(0x0A000000);
		I2C_STOP;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0C000000)
				  	MASK(0x0C000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (CSEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x03000000)
				  	MASK(0x03000000);
		I2C_STOP;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x05000000)
				  	MASK(0x05000000);
		I2C_STOP;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x09000000)
				  	MASK(0x09000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x07000000)
				  	MASK(0x07000000);
		I2C_STOP;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0B000000)
				  	MASK(0x0B000000);
		I2C_STOP;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0D000000)
				  	MASK(0x0D000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0F000000)
				  	MASK(0x0F000000);
		I2C_STOP;
	}	
}
function JTAGI2CCSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x10)
						MASK (0x10);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x50)
						MASK (0x50);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x30)
						MASK (0x30);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (CSEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xC0)
						MASK (0xC0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xA0)
						MASK (0xA0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x90)
						MASK (0x90);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xE0)
						MASK (0xE0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xD0)
						MASK (0xD0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xB0)
						MASK (0xB0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (CSEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xF0)
						MASK (0xF0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}	
function USEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000010)
				  	MASK(0x00000010);
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000050)
				  	MASK(0x00000050);
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000030)
				  	MASK(0x00000030);
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (USEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000C0)
				  	MASK(0x000000C0);
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000A0)
				  	MASK(0x000000A0);
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000090)
				  	MASK(0x00000090);
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000E0)
				  	MASK(0x000000E0);
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000D0)
				  	MASK(0x000000D0);
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000B0)
				  	MASK(0x000000B0);
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x000000F0)
				  	MASK(0x000000F0);
	}	
}
function SPIUSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x08000000)
				  	MASK(0x08000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0A000000)
				  	MASK(0x0A000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0C000000)
				  	MASK(0x0C000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (USEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x03000000)
				  	MASK(0x03000000);
		setpin ISPEN HIGH;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x05000000)
				  	MASK(0x05000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x09000000)
				  	MASK(0x09000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x07000000)
				  	MASK(0x07000000);
		setpin ISPEN HIGH;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0B000000)
				  	MASK(0x0B000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0D000000)
				  	MASK(0x0D000000);
		setpin ISPEN HIGH;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0F000000)
				  	MASK(0x0F000000);
		setpin ISPEN HIGH;
	}
}
function I2CUSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x08000000)
				  	MASK(0x08000000);
		I2C_STOP;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0A000000)
				  	MASK(0x0A000000);
		I2C_STOP;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0C000000)
				  	MASK(0x0C000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (USEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x03000000)
				  	MASK(0x03000000);
		I2C_STOP;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x05000000)
				  	MASK(0x05000000);
		I2C_STOP;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x09000000)
				  	MASK(0x09000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x07000000)
				  	MASK(0x07000000);
		I2C_STOP;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0B000000)
				  	MASK(0x0B000000);
		I2C_STOP;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0D000000)
				  	MASK(0x0D000000);
		I2C_STOP;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x0F000000)
				  	MASK(0x0F000000);
		I2C_STOP;
	}
}
function JTAGI2CUSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000001;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x10)
						MASK (0x10);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 4)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
    // Lock SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 5)
	{
		LockBitsArray[1] = #00000101;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x50)
						MASK (0x50);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 6)
	{
		LockBitsArray[1] = #00000011;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x30)
						MASK (0x30);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L
	ELSEIF (USEC_ISSECURED == 7)
	{
		LockBitsArray[1] = #00001100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xC0)
						MASK (0xC0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
    // Lock SEC_HLOCK SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 8)
	{
		LockBitsArray[1] = #00001010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xA0)
						MASK (0xA0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_HLOCK SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 9)
	{
		LockBitsArray[1] = #00001001;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x90)
						MASK (0x90);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 10)
	{
		LockBitsArray[1] = #00001110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xE0)
						MASK (0xE0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
    // Lock SEC_HLOCK SEC_READ_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 11)
	{
		LockBitsArray[1] = #00001101;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xD0)
						MASK (0xD0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_HLOCK SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 12)
	{
		LockBitsArray[1] = #00001011;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xB0)
						MASK (0xB0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	// Lock SEC_HLOCK SEC_READ_L SEC_PROG_L SEC_ERASE_L
	ELSEIF (USEC_ISSECURED == 13)
	{
		LockBitsArray[1] = #00001111;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0xF0)
						MASK (0xF0);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function CFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    ELSE
    {
    	TRY 1 {
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00000040);
		}
		ELSE
		{
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00000020);
		}
		ELSE
		{
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPICFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    ELSE
    {
    	TRY 1 {
			setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x02000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}

}
function I2CCFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    ELSE
    {
    	TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x02000000);
			I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function JTAGI2CCFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function CFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    ELSE
    {
    	TRY 1 {
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00000040);
		}
		ELSE
		{
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x00000020);
		}
		ELSE
		{
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY 100;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPICFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    ELSE
    {
    	TRY 1 {
			setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x02000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CCFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    ELSE
    {
    	TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x02000000);
			I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
		}
    }
    // Lock SEC_PROG_L
	IF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
		}
	}
	// Lock SEC_READ_L SEC_PROG_L
	IF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function JTAGI2CCFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function UFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L	
	IF (EFuseArray_TDI_UFM0.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM0_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000040)
						MASK(0x00000040);
			
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000040);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM0_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000020)
						MASK(0x00000020);
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000020);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM0_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000060)
						MASK(0x00000060);
		}
	}		
}
function SPIUFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM0.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM0_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			setpin ISPEN HIGH;
			
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM0_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM0_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			setpin ISPEN HIGH;
		}
	}
}
function I2CUFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM0.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM0_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			I2C_STOP;	    
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM0_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM0_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			I2C_STOP;
		}
	}
}
function JTAGI2CUFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function UFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM1.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM1_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000040)
						MASK(0x00000040);
			
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000040);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM1_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000020)
						MASK(0x00000020);
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000020);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM1_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000060)
						MASK(0x00000060);
		}
	}		
}
function SPIUFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM1.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM1_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			setpin ISPEN HIGH;
			
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM1_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM1_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			setpin ISPEN HIGH;
		}
	}
}
function I2CUFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM1.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM1_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			I2C_STOP;	    
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM1_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM1_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			I2C_STOP;
		}
	}
}
function JTAGI2CUFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function UFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM2_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000040)
						MASK(0x00000040);
			
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000040);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM2_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000020)
						MASK(0x00000020);
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000020);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM2_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000060)
						MASK(0x00000060);
		}
	}		
}
function SPIUFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM2_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			setpin ISPEN HIGH;
			
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM2_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM2_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			setpin ISPEN HIGH;
		}
	}
}
function I2CUFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM2.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM2_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			I2C_STOP;	    
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM2_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM2_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			I2C_STOP;
		}
	}
}
function JTAGI2CUFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM2_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function UFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM3.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM3_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000040)
						MASK(0x00000040);
			
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000040);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM3_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000020)
						MASK(0x00000020);
		}
		ELSE
		{
			TRY 1 {
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000000)
								MASK(0x00000020);
			}
			ELSE
			{
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM3_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
			SDR 8 TDI(LockBitsArray[1]);
			RUN_TEST IDLE TCK 2 DELAY 100;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000060)
						MASK(0x00000060);
		}
	}		
}
function SPIUFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM3.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM3_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			setpin ISPEN HIGH;
			
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM3_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			setpin ISPEN HIGH;
		}
		ELSE
		{
			TRY 1 {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				setpin ISPEN HIGH;
			}
			ELSE
			{
				setpin ISPEN HIGH;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM3_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			setpin ISPEN LOW;
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			setpin ISPEN HIGH;
		}
	}
}
function I2CUFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	IF (EFuseArray_TDI_UFM3.row = 1)
	{	
		// Lock SEC_READ_L
		IF (UFM3_ISSECURED == 1)
		{
			LockBitsArray[1] = #00000100;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x02000000)
						MASK(0x02000000);
			I2C_STOP;	    
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x02000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Read Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_PROG_L
		IF (UFM3_ISSECURED == 2)
		{
			LockBitsArray[1] = #00000010;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x04000000)
						MASK(0x04000000);
			I2C_STOP;
		}
		ELSE
		{
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
							TDO(0x00000000)
							MASK(0x04000000);
				I2C_STOP;
			}
			ELSE
			{
				I2C_STOP;
				print (0,"Warning: Current Sector Program Lock is set. Please erase the sector to un-lock.");
			}
		}
		// Lock SEC_READ_L SEC_PROG_L
		IF (UFM3_ISSECURED == 3)
		{
			LockBitsArray[1] = #00000110;
			LockBitsArray[1] = $LockBitsArray[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
			SDR 32	TDI (0x00000073);
			SDR 8 TDI(LockBitsArray[1]);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x06000000)
						MASK(0x06000000);
			I2C_STOP;
		}
	}
}
function JTAGI2CUFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM3_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x40)
						MASK (0x40);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM SECURITY(0xCE) instruction;
		SDR	16	TDI (0x10CE);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = LockBitsArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
    	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x60)
						MASK (0x60);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
}
function SAVE_CONTROLNV1
{
	datastream TempNV1[1][128];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length TDI (LSC_READ_FEATURE);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 TDI(#0^128)
			TDO(TempNV1[1]);
	SavedControlNV1[1] = TempNV1[1] << 32;
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function SPISAVE_CONTROLNV1{
	datastream TempNV1[1][128];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR  128 TDI(#0^128)
			TDO(TempNV1[1]);
	setpin ISPEN HIGH;	
	TempNV1[1] = $TempNV1[1];		
	SavedControlNV1[1] = TempNV1[1] << 32;	
	//SavedControlNV1[1] = $SavedControlNV1[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROLNV1{
	datastream TempNV1[1][128];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  128 TDI(#0^128)
			TDO(TempNV1[1]);
	I2C_STOP;	
	TempNV1[1] = $TempNV1[1];	
	SavedControlNV1[1] = TempNV1[1] << 32;	
	//SavedControlNV1[1] = $SavedControlNV1[1];			  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROLNV1
{
	datastream DataByte[1][8];
	datastream TempNV1[1][128];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TempNV1[1] = ((TempNV1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	SavedControlNV1[1] = TempNV1[1] << 32;
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function PROGRAM_CONTROL_NV1{
	datastream PasswordArray[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureBitsArray[1][32];
	datastream TempNV[1][32];
	datastream TmpReserve[1][32];
	datastream TmpFeature[1][64];
	@SELECT_FEA();
	
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SIR Instruction_Length TDI (LSC_READ_PASSWORD);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR 128  TDI(#0^128)
			TDO(PasswordArray[1]);
			
	@SELECT_FEA();
	
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 128  TDI(#0^128)
    		 TDO(FeatureArray[1]);
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 32  TDI(#0^32)
    		TDO(FeatureBitsArray[1]); 
	
	@SELECT_FEA();
	@FEATURE_ERASE();

	@SELECT_FEA();
	
	IF (Control_Register_1_TDI.row = 1)
	{
		TempNV[1] = Control_Register_1_TDI[1];
		TmpReserve[1] =  FeatureArray[1];
		TmpFeature[1] =  FeatureArray[1] << 64;
		FeatureArray[1] = ((TmpReserve[1]) @ TempNV[1] @ (TmpFeature[1]));		
	}

	! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	SDR 128 TDI(FeatureArray[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}	
	RUN_TEST IDLE TCK 2 ;  
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	SDR_VERIFY 128   TDI(#0^128)
					TDO(FeatureArray[1] )
					MASK(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
			
	
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	SDR 32 TDI(FeatureBitsArray[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	SDR_VERIFY 32   TDI(#0^32)
					TDO(FeatureBitsArray[1])
					MASK(0xFFFFFFFF);
					
	@SELECT_FEA();
	! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
	SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
	! Shift in Data; 
	SDR 128 TDI(PasswordArray[1]);
	RUN_TEST	IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}		
	TRY 1 {
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SIR Instruction_Length TDI (LSC_READ_PASSWORD);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  128 	TDI(#0^128)
							TDO (PasswordArray[1]);
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to program the Password Key.");
	}	

}
function SPIPROGRAM_CONTROL_NV1{
	datastream PasswordArray[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureBitsArray[1][32];
	datastream TempNV[1][32];
	datastream TmpReserve[1][32];
	datastream TmpFeature[1][64];
	@SPISELECT_FEA();
	setpin ISPEN LOW; 
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);
	setpin ISPEN HIGH;			

	@SPISELECT_FEA();
	
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR	128	TDI (#0^128)
			TDO	(FeatureArray[1]);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	SDR	32	TDI (#0^32)
			TDO	(FeatureBitsArray[1]);
	setpin ISPEN HIGH;	
	
	@SPISELECT_FEA();
	@SPIFEATURE_ERASE();
	
	IF (Control_Register_1_TDI.row = 1)
	{
		TempNV[1] = Control_Register_1_TDI[1];
		FeatureArray[1] = $FeatureArray[1];
		TmpReserve[1] =  FeatureArray[1];
		TmpFeature[1] =  FeatureArray[1] << 64;
		FeatureArray[1] = ((TmpReserve[1]) @ TempNV[1] @ (TmpFeature[1]));	
		FeatureArray[1] = $FeatureArray[1];							
	}
	@SPISELECT_FEA();
	setpin ISPEN LOW;
	! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	SDR 32	TDI (0x00000027);
	SDR 128 TDI(FeatureArray[1]);
	setpin ISPEN HIGH;	
	loop PWP {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}	 
	setpin ISPEN HIGH;	
	setpin ISPEN LOW; 
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR_VERIFY 128   TDI(#0^128)
					TDO(FeatureArray[1])
					MASK(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
	setpin ISPEN HIGH;	
	setpin ISPEN LOW; 
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	SDR 32	TDI (0x0000001F);	    
	SDR 32 TDI(FeatureBitsArray[1]);
	setpin ISPEN HIGH;	
	loop PWP {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}	 
	setpin ISPEN HIGH;	
	setpin ISPEN LOW;  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	SDR_VERIFY 32   TDI(#0^32)
					TDO(FeatureBitsArray[1])
					MASK(0xFFFFFFFF);
	setpin ISPEN HIGH;			
	setpin ISPEN LOW;
	! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
	SDR 32	TDI (0x0000008F);
	! Shift in Data; 
	SDR 128 TDI(PasswordArray[1]);
	setpin ISPEN HIGH;
	loop PWP {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}	 
	setpin ISPEN HIGH;
	// Verify the Password Key;
	TRY 1 {
		setpin ISPEN LOW; 
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR 32 TDI (0x0000004F);
		SDR_VERIFY  128 TDI(#0^128)
					   TDO(PasswordArray[1]);
		setpin ISPEN HIGH;						  	   					  		  		    
	}
	ELSE {		  
		setpin ISPEN HIGH;		
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Failed to program the Password Key.");
	}						
}
function I2CPROGRAM_CONTROL_NV1{
	datastream PasswordArray[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureBitsArray[1][32];
	datastream TempNV[1][32];
	datastream TmpReserve[1][32];
	datastream TmpFeature[1][64];
	@I2CSELECT_FEA();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);	
	I2C_STOP;	
	@I2CSELECT_FEA();
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	128	TDI (#0^128)
			TDO	(FeatureArray[1]);
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI (#0^32)
			TDO	(FeatureBitsArray[1]);
	I2C_STOP;
	
	@I2CSELECT_FEA();
	@I2CFEATURE_ERASE();	
	
	IF (Control_Register_1_TDI.row = 1)
	{
		TempNV[1] = Control_Register_1_TDI[1];
		FeatureArray[1] = $FeatureArray[1];
		TmpReserve[1] =  FeatureArray[1];
		TmpFeature[1] =  FeatureArray[1] << 64;
		FeatureArray[1] = ((TmpReserve[1]) @ TempNV[1] @ (TmpFeature[1]));	
		FeatureArray[1] = $FeatureArray[1];							
	}	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (0x01);
	! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	SDR 32	TDI (0x00000027);
	SDR 128 TDI(FeatureArray[1]);
	RUN_TEST DELAY 1000;
	I2C_STOP;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI ( NEW_I2C_ADDR_READ );
	SDR_VERIFY 128   TDI(#0^128)
					TDO(FeatureArray[1])
					MASK(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
	I2C_STOP;		
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (0x01);
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	SDR 32	TDI (0x0000001F);	    
	SDR 32 TDI(FeatureBitsArray[1]);
	RUN_TEST DELAY 1000;
	I2C_STOP;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (0x01);
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (0x81);
	SDR_VERIFY 32   TDI(#0^32)
					TDO(FeatureBitsArray[1])
					MASK(0xFFFFFFFF);
	I2C_STOP;		

	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
	SDR 32	TDI (0x0000008F);
	! Shift in Data; 
	SDR 128 TDI(PasswordArray[1]);
	I2C_STOP;
	RUN_TEST DELAY PWP;	
	// Verify the Password Key;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR 32 TDI (0x0000004F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  128 TDI(#0^128)
					   TDO(PasswordArray[1]);	
		I2C_STOP;					  	   				  		  		    
	}
	ELSE {		  
		I2C_STOP;		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	24 	TDI (0x000064);
		I2C_STOP;
		RUN_TEST DELAY 200;	 
		print (1,"Failed to program the Password Key.");
	}
}
function JTAGI2CPROGRAM_CONTROL_NV1
{
	datastream DataByte[1][8];
	datastream PasswordArray[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureBitsArray[1][32];
	datastream TempNV[1][32];
	datastream TmpReserve[1][32];
	datastream TmpFeature[1][64];
	
	@JTAGI2CSELECT_FEA();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR	16	TDI (0x10F2);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 	
	@JTAGI2CSELECT_FEA();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
    SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR	16	TDI (0x10FB);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
    
	@JTAGI2CSELECT_FEA();
	@JTAGI2CFEATURE_ERASE();
	@JTAGI2CSELECT_FEA();
		
	IF (Control_Register_1_TDI.row = 1)
	{
		TempNV[1] = Control_Register_1_TDI[1];
		TmpReserve[1] =  FeatureArray[1];
		TmpFeature[1] =  FeatureArray[1] << 64;
		FeatureArray[1] = ((TmpReserve[1]) @ TempNV[1] @ (TmpFeature[1]));	
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	SDR	16	TDI (0x10E4);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = FeatureArray[1];
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 8);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 16);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 24);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 32);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 40);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 48);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 56);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 64);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 72);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 80);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 88);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 96);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 104);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 112);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 120);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;    
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1]);
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 8);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 16);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 24);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 32);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 40);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 48);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 56);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 64);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 72);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 80);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 88);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 96);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 104);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 112);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureArray[1] << 120);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;	
	SDR	16	TDI (0x10F8);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	DataByte[1] = FeatureBitsArray[1];
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 8);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 16);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 24);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 			  
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	SDR	16	TDI (0x10FB);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1]);
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 8);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 16);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (FeatureBitsArray[1] << 24);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
						
	@JTAGI2CSELECT_FEA();
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);		
	! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
	SDR	16	TDI (0x10F1);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	DataByte[1] = PasswordArray[1];
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 8);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 16);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 24);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 32);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 40);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 48);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 56);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 64);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 72);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 80);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 88);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 96);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 104);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 112);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	DataByte[1] = (PasswordArray[1] << 120);
	SDR	16	TDI ((0x10) @ (DataByte[1])); 
	RUN_TEST IDLE TCK 1000 ;
	RUN_TEST IDLE TCK 2 DELAY 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;    
		
	TRY 1 {
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 8);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 16);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 24);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 32);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 40);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 48);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 56);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 64);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 72);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 80);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 88);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 96);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 104);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 112);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (PasswordArray[1] << 120);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;			
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to program the Password Key.");
	}	
}
function READ_PASSWORD
{
	datastream PasswordArray[1][128];
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SIR Instruction_Length TDI (LSC_READ_PASSWORD);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR 128  TDI(#0^128)
			TDO(PasswordArray[1]);
	print (0,"The password is");
	print (0,PasswordArray);		 		  			  	
}
function SPIREAD_PASSWORD
{
	datastream PasswordArray[1][128];
	setpin ISPEN LOW; 
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);
	setpin ISPEN HIGH;	
	PasswordArray[1] = $PasswordArray[1];				
	print (0,"The password is");
	print (0,PasswordArray);		 		  			  	
}
function I2CREAD_PASSWORD
{
	datastream PasswordArray[1][128];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR 32 TDI (0x0000004F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  128 TDI(#0^128)
			 TDO(PasswordArray[1]);	
	I2C_STOP;
	PasswordArray[1] = $PasswordArray[1];
	print (0,"The password is");
	print (0,PasswordArray);		 		  			  	
}
function JTAGI2CREAD_PASSWORD
{
	datastream DataByte[1][8];
	datastream PasswordArray[1][128];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_PASSWORD(0xF2) instruction;
	SDR	16	TDI (0x10F2);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);	
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	RUN_TEST IDLE TCK 1000 ;
	PasswordArray[1] = ((PasswordArray[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);	
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	print (0,"The password is");
	print (0,PasswordArray);		 		  			  	
}
function PROGRAM_PASSWORD
{
	datastream TmpFeatureBits[1][32];
	datastream TmpStatusRegister0[1][32];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		
		print (0,"Programming the Password Key...");
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
		! Shift in Data; 
		SDR 128 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
		
		print (0,"Verify the Password Key...");
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (ProtectKey[1]);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Password Key.");
		}
		//Set bits all 0
		TmpFeatureBits[1] = TmpFeatureBits[1] & 0x00000000;
		TmpStatusRegister0[1] = TmpStatusRegister0[1] & 0x00000000;
		//Enable PWD_EN bits
		TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000004;	
		TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00010000;	
		IF (PWD_UFM == 1)
		{
			//Enable PWD_UFM bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000002;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00020000;	
		}
		IF (PWD_ALL == 1)
		{
			//Enable PWD_ALL bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000008;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00008000;	
		}
		
		//Programming Password Protect Policies
		print (0, "Programming the Password Protect Policies...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
		! Shift in Data; 
		SDR 32 TDI(TmpFeatureBits[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop 1000 {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
		print (0,"Verify the Password Protect Policies...");
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(TmpStatusRegister0[1])
							MASK(0x00038000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the Password Protect Policies...");
		}

	}	
}
function SPIPROGRAM_PASSWORD
{
	datastream TmpFeatureBits[1][32];
	datastream TmpStatusRegister0[1][32];
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to program the Password Key.");
		}
		//Set bits all 0
		TmpFeatureBits[1] = TmpFeatureBits[1] & 0x00000000;
		TmpStatusRegister0[1] = TmpStatusRegister0[1] & 0x00000000;
		//Enable PWD_EN bits
		TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000004;	
		TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00010000;	
		IF (PWD_UFM == 1)
		{
			//Enable PWD_UFM bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000002;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00020000;	
		}
		IF (PWD_ALL == 1)
		{
			//Enable PWD_ALL bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000008;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00008000;	
		}	

		TmpFeatureBits[1] = $TmpFeatureBits[1];
		TmpStatusRegister0[1] = $TmpStatusRegister0[1];
	
		print (0, "Programming the Password Protect Policies...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
		SDR 32	TDI (0x0000001F);
		! Shift in Data; 
		SDR 32 TDI(TmpFeatureBits[1]);
		setpin ISPEN HIGH;
		RUN_TEST	DELAY PWP;
		print (0,"Verify the Password Protect Policies...");
		TRY 1 {
			// check the Password Protect Policies
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(TmpStatusRegister0[1])
							MASK(0x0001C000);
			setpin ISPEN HIGH;						  						  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed to Program the Password Protect Policies...");
		}
			

	}
}
function I2CPROGRAM_PASSWORD
{
	datastream TmpFeatureBits[1][32];
	datastream TmpStatusRegister0[1][32];
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x000C8000);
			I2C_STOP;						  		  		    
		}
		ELSE {	
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	  
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		print (0,"Programming the Password Key...");
		SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];	
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			I2C_START;
	    	! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);	
			I2C_STOP;					  	   				  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to program the Password Key.");
		}
		
		//Set bits all 0
		TmpFeatureBits[1] = TmpFeatureBits[1] & 0x00000000;
		TmpStatusRegister0[1] = TmpStatusRegister0[1] & 0x00000000;
		//Enable PWD_EN bits
		TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000004;	
		TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00010000;	
		IF (PWD_UFM == 1)
		{
			//Enable PWD_UFM bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000002;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00020000;	
		}
		IF (PWD_ALL == 1)
		{
			//Enable PWD_ALL bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000008;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00008000;	
		}
		TmpFeatureBits[1] = $TmpFeatureBits[1];
		TmpStatusRegister0[1] = $TmpStatusRegister0[1];		
		
		print (0, "Programming the Password Protect Policies...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
		SDR 32	TDI (0x0000001F);
		! Shift in Data; 
		SDR 32 TDI(TmpFeatureBits[1]);
		I2C_STOP;
		RUN_TEST	DELAY PWP;
		print (0,"Verify the Password Protect Policies...");
		TRY 1 {
			// check the Password Protect Policies
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(TmpStatusRegister0[1])
							MASK(0x0001C000);
			I2C_STOP;						  						  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"Failed to Program the Password Protect Policies...");
		}
	}
}
function JTAGI2CPROGRAM_PASSWORD
{
	datastream DataByte[1][8];
	datastream TmpFeatureBits[1][32];
	datastream TmpStatusRegister0[1][32];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x30);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		
		print (0,"Programming the Password Key...");
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);						
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR	16	TDI (0x10F1);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = ProtectKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		
		print (0,"Verify the Password Key...");
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_PASSWORD(0xF2) instruction;
		SDR	16	TDI (0x10F2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			DataByte[1] = ProtectKey[1];
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
		    DataByte[1] = (ProtectKey[1] << 24);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 32);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 40);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);				
			DataByte[1] = (ProtectKey[1] << 48);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 56);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 64);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 72);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 80);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);	
			DataByte[1] = (ProtectKey[1] << 88);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 96);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 104);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);
			DataByte[1] = (ProtectKey[1] << 112);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);		
			DataByte[1] = (ProtectKey[1] << 120);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0xFF);																																							
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to program the Password Key.");
		}	

		//Set bits all 0
		TmpFeatureBits[1] = TmpFeatureBits[1] & 0x00000000;
		TmpStatusRegister0[1] = TmpStatusRegister0[1] & 0x00000000;
		//Enable PWD_EN bits
		TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000004;	
		TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00010000;	
		IF (PWD_UFM == 1)
		{
			//Enable PWD_UFM bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000002;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00020000;	
		}
		IF (PWD_ALL == 1)
		{
			//Enable PWD_ALL bits
			TmpFeatureBits[1] = TmpFeatureBits[1] | 0x00000008;
			TmpStatusRegister0[1] = TmpStatusRegister0[1] | 0x00008000;	
		}	
		
		print (0, "Programming the Password Protect Policies...");
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
		SDR	16	TDI (0x10F8);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Data; 
		DataByte[1] = TmpFeatureBits[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpFeatureBits[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpFeatureBits[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpFeatureBits[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}
		print (0,"Verify the Password Protect Policies...");
		TRY 1 {
			// check the Password Protect Policies
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);			
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR	16	TDI (0x103C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			DataByte[1] = TmpStatusRegister0[1];
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0x00);
			DataByte[1] = (TmpStatusRegister0[1] << 8);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0x03);
			DataByte[1] = (TmpStatusRegister0[1] << 16);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1])
							MASK (0x80);				
		    DataByte[1] = (TmpStatusRegister0[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;							  		  		    
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				 
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to Program the Password Protect Policies...");
		}
	}	
}
function READ_AESKEY
{
	datastream AESArray[1][256];
	datastream tmpSecurityKey1[1][128];
	datastream tmpSecurityKey2[1][128];
	! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
	SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey1[1]);
						
	! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
	SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey2[1]);
	AESArray[1] = (tmpSecurityKey2[1] @ tmpSecurityKey1[1]);
	print (0,"The Encryption key is");
	print (0,AESArray);		
}
function SPIREAD_AESKEY
{
	datastream AESArray[1][256];
	datastream tmpSecurityKey1[1][128];
	datastream tmpSecurityKey2[1][128];
	setpin ISPEN LOW;
	! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
	SDR 32 TDI (0x0000002F);			
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey1[1]);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
	SDR 32 TDI (0x0000007F);			
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey2[1]);
	setpin ISPEN HIGH;	
	AESArray[1] = (tmpSecurityKey1[1] @ tmpSecurityKey2[1]);
	AESArray[1] = $AESArray[1];
	print (0,"The Encryption key is");
	print (0,AESArray);	
}
function I2CREAD_AESKEY
{
	datastream AESArray[1][256];
	datastream tmpSecurityKey1[1][128];
	datastream tmpSecurityKey2[1][128];
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
	SDR 32 TDI (0x0000002F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);			
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey1[1]);
	I2C_STOP;				
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
	SDR 32 TDI (0x0000007F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);			
	SDR  128 	TDI(#0^128)
				TDO (tmpSecurityKey2[1]);
	I2C_STOP;
	AESArray[1] = (tmpSecurityKey1[1] @ tmpSecurityKey2[1]);
	AESArray[1] = $AESArray[1];
	print (0,"The Encryption key is");
	print (0,AESArray);	
}
function JTAGI2CREAD_AESKEY
{
	datastream DataByte[1][8];
	datastream AESArray[1][256];
	datastream tmpSecurityKey1[1][128];
	datastream tmpSecurityKey2[1][128];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
    SDR	16	TDI (0x10F4);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey1[1] = ((tmpSecurityKey1[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
    SDR	16	TDI (0x10FE);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	tmpSecurityKey2[1] = ((tmpSecurityKey2[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	AESArray[1] = (tmpSecurityKey2[1] @ tmpSecurityKey1[1]);
	print (0,"The Encryption key is");
	print (0,AESArray);		
}
function PROGRAM_AESKEY
{
	datastream tmpSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");
		tmpSecurityKey[1] = SecurityKey[1] << 128;
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CIPHER_KEY0);
		! Shift in Data; 
		SDR 128 TDI(tmpSecurityKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		tmpSecurityKey[1] = SecurityKey[1];
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CIPHER_KEY1);
		! Shift in Data; 
		SDR 128 TDI(tmpSecurityKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			tmpSecurityKey[1] = SecurityKey[1] << 128;
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (tmpSecurityKey[1]);
								
			tmpSecurityKey[1] = SecurityKey[1];
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (tmpSecurityKey[1]);								
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			TRY 1 {
				print (0,"Programming and Verify the Encrypted Bitstream Only Fuses...");
				repeat PWP {
					@SELECT_AESKEY();
					//Bit[0] of OPRAND1 = DEC_ONLY
					! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
					SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
					! Shift in Data; 
					SDR 8 TDI(0x01);
					RUN_TEST	IDLE TCK 2 DELAY PWP;
				}
				loop PWP {
					@SELECT_AESKEY();
					// check bit Dec Only (bit0) of the AES Register
					! Shift in LSC_READ_AES_FEA(0xFA) instruction;
					SIR Instruction_Length TDI (LSC_READ_AES_FEA);
					RUN_TEST IDLE TCK 2 DELAY PWV; 
					SDR_VERIFY  8 	TDI(#0^8)
									TDO(0x01)
									MASK(0x01);	
				}
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			TRY 1 {
				print (0,"Programming and Verify the Random AES Fuses...");
				repeat PWP {
					@SELECT_AESKEY();
					//Bit[1] of OPRAND1 = RAND_AES
					! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
					SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
					! Shift in Data; 
					SDR 8 TDI(0x02);
					RUN_TEST	IDLE TCK 2 DELAY PWP;
				}
				loop PWP {
					@SELECT_AESKEY();
					// check bit RAND_AES (bit1) of the AES Register
					! Shift in LSC_READ_AES_FEA(0xFA) instruction;
					SIR Instruction_Length TDI (LSC_READ_AES_FEA);
					RUN_TEST IDLE TCK 2 DELAY PWV; 
					SDR_VERIFY  8 	TDI(#0^8)
									TDO(0x02)
									MASK(0x02);	
				}
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			TRY 1 {
				print (0,"Programming and Verify the Random Noise Fuses...");
				repeat PWP {
					@SELECT_AESKEY();
					//Bit[2] of OPRAND1 = RAND_NOISE
					! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
					SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
					! Shift in Data; 
					SDR 8 TDI(0x04);
					RUN_TEST	IDLE TCK 2 DELAY PWP;
				}
				loop PWP {
					@SELECT_AESKEY();
					print (0,"Verify the Random Noise fuses...");
					// check bit RAND_NOISE (bit2) of the AES Register
					! Shift in LSC_READ_AES_FEA(0xFA) instruction;
					SIR Instruction_Length TDI (LSC_READ_AES_FEA);
					RUN_TEST IDLE TCK 2 DELAY PWV; 
					SDR_VERIFY  8 	TDI(#0^8)
									TDO(0x04)
									MASK(0x04);	
				}
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function SPIPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");			
		SaveSecurityKey[1] = SecurityKey[1] << 128;
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;		
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SDR 32	TDI (0x000000BF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			SaveSecurityKey[1] = SecurityKey[1] << 128;
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			setpin ISPEN LOW;
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SDR 32 TDI (0x0000002F);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			setpin ISPEN HIGH;
			SaveSecurityKey[1] = SecurityKey[1];
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			setpin ISPEN LOW;
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SDR 32 TDI (0x0000007F);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			setpin ISPEN HIGH;								
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000809F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit Dec Only (Bit0) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x80)
						  		MASK(0x80);	
				setpin ISPEN HIGH;						  					  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000409F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x40)
						  		MASK(0x40);		
				setpin ISPEN HIGH;		  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000209F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x20)
						  		MASK(0x20);
				setpin ISPEN HIGH;						  						  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function I2CPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");			
		SaveSecurityKey[1] = SecurityKey[1] << 128;
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;		
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SDR 32	TDI (0x000000BF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			SaveSecurityKey[1] = SecurityKey[1] << 128;
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SDR 32 TDI (0x0000002F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			I2C_STOP;				
			SaveSecurityKey[1] = SecurityKey[1];
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SDR 32 TDI (0x0000007F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			I2C_STOP;							
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000809F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit Dec Only (bit0) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x80)
						  		MASK(0x80);	
				I2C_STOP;						  					  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000409F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x40)
						  		MASK(0x40);		
				I2C_STOP;		  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000209F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x20)
						  		MASK(0x20);
				I2C_STOP;						  						  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}
}
function JTAGI2CPROGRAM_AESKEY
{
	datastream DataByte[1][8];
	datastream tmpSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");
		tmpSecurityKey[1] = SecurityKey[1] << 128;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
    	SDR	16	TDI (0x10F3);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = tmpSecurityKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (tmpSecurityKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);		
		
		tmpSecurityKey[1] = SecurityKey[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
    	SDR	16	TDI (0x10FD);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = tmpSecurityKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (tmpSecurityKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (tmpSecurityKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;		
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			tmpSecurityKey[1] = SecurityKey[1] << 128;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
	    	SDR	16	TDI (0x10F4);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;			 	
	    	DataByte[1] = (tmpSecurityKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (tmpSecurityKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			
			tmpSecurityKey[1] = SecurityKey[1];
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
	    	SDR	16	TDI (0x10FE);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;			 	
	    	DataByte[1] = (tmpSecurityKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (tmpSecurityKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (tmpSecurityKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;													
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;			
    		SDR	16	TDI (0x10F9);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI (0x1001);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI(0x5000);
			RUN_TEST IDLE TCK 1000 ;
			RUN_TEST IDLE TCK 2 DELAY 1;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				// check bit Dec Only (bit0) of the AES Register
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
		    	SDR	16	TDI (0x10FA);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x01)
								MASK (0x01);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);	
				RUN_TEST IDLE TCK 1000 ;					  		  		    
			}
			ELSE {		  
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ; 
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				     
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;			
    		SDR	16	TDI (0x10F9);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1002);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;     		
			RUN_TEST	IDLE TCK 2 DELAY PWP;
						
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
		    	SDR	16	TDI (0x10FA);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x02)
								MASK (0x02);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;												  		  		    
			}
			ELSE {		  
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ; 
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				     
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;			
    		SDR	16	TDI (0x10F9);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1004);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;     		
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
		    	SDR	16	TDI (0x10FA);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);	
		    	SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x04);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;												  		  		    
			}
			ELSE {		  
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in ISC DISABLE(0x26) instruction;
				SDR	16	TDI (0x1026);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ; 
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY 1000;     
				     
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY 100;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function READ_PUBKEY
{
	datastream SavePubKey[1][512];
	datastream TmpPublicKey1[1][128];
	datastream TmpPublicKey2[1][128];
	datastream TmpPublicKey3[1][128];
	datastream TmpPublicKey4[1][128];
	
	! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
	SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (TmpPublicKey1[1]);
	
	! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
	SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (TmpPublicKey2[1]);
	! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
	SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY2);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (TmpPublicKey3[1]);	
	! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
	SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY3);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  128 	TDI(#0^128)
				TDO (TmpPublicKey4[1]);	
	SavePubKey[1] = ((TmpPublicKey4[1] @ TmpPublicKey3[1]) @ (TmpPublicKey2[1] @ TmpPublicKey1[1]));
	print (0,"The Public key is");
	print (0,SavePubKey);	
}
function SPIREAD_PUBKEY
{
	datastream SavePubKey[1][512];
	datastream TmpPublicKey1[1][128];
	datastream TmpPublicKey2[1][128];
	datastream TmpPublicKey3[1][128];
	datastream TmpPublicKey4[1][128];
	setpin ISPEN LOW;
    ! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
	SDR 32	TDI (0x0000005A);
	SDR 128  TDI(#0^128)
			 TDO(TmpPublicKey1[1]);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
    ! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
	SDR 32	TDI (0x0000003A);
	SDR 128  TDI(#0^128)
			TDO(TmpPublicKey2[1]);
	setpin ISPEN HIGH;	
	setpin ISPEN LOW;
    ! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
	SDR 32	TDI (0x00000046);
	SDR 128  TDI(#0^128)
			TDO(TmpPublicKey3[1]);
	setpin ISPEN HIGH;		
	setpin ISPEN LOW;
    ! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
	SDR 32	TDI (0x00000026);
	SDR 128  TDI(#0^128)
			TDO(TmpPublicKey4[1]);
	setpin ISPEN HIGH;	
	TmpPublicKey1[1] = $TmpPublicKey1[1];
	TmpPublicKey2[1] = $TmpPublicKey2[1];
	TmpPublicKey3[1] = $TmpPublicKey3[1];
	TmpPublicKey4[1] = $TmpPublicKey4[1];
	SavePubKey[1] = ((TmpPublicKey4[1] @ TmpPublicKey3[1]) @ (TmpPublicKey2[1] @ TmpPublicKey1[1]));
	print (0,"The Public key is");
	print (0,SavePubKey);	
}
function I2CREAD_PUBKEY
{
	datastream SavePubKey[1][512];
	datastream TmpPublicKey1[1][128];
	datastream TmpPublicKey2[1][128];
	datastream TmpPublicKey3[1][128];
	datastream TmpPublicKey4[1][128];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
	SDR 32	TDI (0x0000005A);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);		
	SDR 128  TDI(#0^128)
			TDO(TmpPublicKey1[1]);
	I2C_STOP;				
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
	SDR 32	TDI (0x0000003A);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);		
	SDR 128  TDI(#0^128)
			TDO(TmpPublicKey2[1]);
	I2C_STOP;
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
	SDR 32	TDI (0x00000046);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);		
	SDR 128  TDI(#0^128)
			 TDO(TmpPublicKey3[1]);
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
	SDR 32	TDI (0x00000026);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);		
	SDR 128  TDI(#0^128)
					TDO(TmpPublicKey4[1]);
	I2C_STOP;
	
	TmpPublicKey1[1] = $TmpPublicKey1[1];
	TmpPublicKey2[1] = $TmpPublicKey2[1];
	TmpPublicKey3[1] = $TmpPublicKey3[1];
	TmpPublicKey4[1] = $TmpPublicKey4[1];
	SavePubKey[1] = ((TmpPublicKey4[1] @ TmpPublicKey3[1]) @ (TmpPublicKey2[1] @ TmpPublicKey1[1]));
	print (0,"The Public key is");
	print (0,SavePubKey);	
}
function JTAGI2CREAD_PUBKEY
{
	datastream DataByte[1][8];
	datastream SavePubKey[1][512];
	datastream TmpPublicKey1[1][128];
	datastream TmpPublicKey2[1][128];
	datastream TmpPublicKey3[1][128];
	datastream TmpPublicKey4[1][128];
				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
    SDR	16	TDI (0x105A);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey1[1] = ((TmpPublicKey1[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
    SDR	16	TDI (0x105C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey2[1] = ((TmpPublicKey2[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
    SDR	16	TDI (0x1062);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey3[1] = ((TmpPublicKey3[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
    SDR	16	TDI (0x1064);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	TmpPublicKey4[1] = ((TmpPublicKey4[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
					
	SavePubKey[1] = ((TmpPublicKey4[1] @ TmpPublicKey3[1]) @ (TmpPublicKey2[1] @ TmpPublicKey1[1]));
	print (0,"The Public key is");
	print (0,SavePubKey);	
}
function PROGRAM_PUBKEY
{
	datastream TmpPublicKey[1][128];
	IF (PublicKey.row = 1)
	{		
		print (0,"Programming the Public Keys...");	
		TmpPublicKey[1] = PublicKey[1] << 384;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY0);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		TmpPublicKey[1] = PublicKey[1] << 256;
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY1);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		TmpPublicKey[1] = PublicKey[1] << 128;
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY2);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		TmpPublicKey[1] = PublicKey[1];
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x63) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY3);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		
		print (0,"Verify the Public Keys...");
		TRY 1 {
			TmpPublicKey[1] = PublicKey[1] << 384;
			! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);
			
			TmpPublicKey[1] = PublicKey[1] << 256;
			! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);
			
			TmpPublicKey[1] = PublicKey[1] << 128;
			! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY2);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);	
								
			TmpPublicKey[1] = PublicKey[1];
			! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY3);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);																									
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Public Keys.");
		}
		TRY 1 {
			print (0,"Programming and Verify the AUTH_EN2 and AUTH_EN1 Fuses...");
			repeat PWP{
				@SELECT_PUBKEY();
				// HMAC Authentication will not supported for Sentry
				// Always program the AUTH_EN2 AUTH_EN1 for ECDSA by default
				//Bit[1] of OPRAND1 = AUTH_EN2
				//Bit[0] of OPRAND1 = AUTH_EN1
				! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
				SIR Instruction_Length	TDI (LSC_PROG_AUTH_MODE);
				! Shift in Data; 
				SDR 8 TDI(0x03);
				RUN_TEST	IDLE TCK 2 DELAY PWP;
			}	
			loop PWP {
				// check bit AUTH_EN2(9) and AUTH_EN1 (8) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00000300)
								MASK(0x00000300);
			}
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}
}
function SPIPROGRAM_PUBKEY{
	datastream SavePublicKey[1][128];
	IF (PublicKey.row = 1)
	{
		print (0,"Programming the Public Keys...");		
		SavePublicKey[1]= PublicKey[1] << 384;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1] << 256;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SDR 32	TDI (0x000000DA);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1] << 128;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SDR 32	TDI (0x00000086);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1];
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY3(0x63) instruction;
		SDR 32	TDI (0x000000C6);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}
		setpin ISPEN HIGH;
		print (0,"Verify the Public Keys...");
		TRY 1 {
			SavePublicKey[1]= PublicKey[1] << 384;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
			SDR 32	TDI (0x0000005A);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;
			SavePublicKey[1]= PublicKey[1] << 256;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
			SDR 32	TDI (0x0000003A);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;	
			SavePublicKey[1]= PublicKey[1] << 128;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
			SDR 32	TDI (0x00000046);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;		
			SavePublicKey[1]= PublicKey[1];
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
			SDR 32	TDI (0x00000026);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;					
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN2 and AUTH_EN1 for ECDSA by default
		//Bit[1] of OPRAND1 = AUTH_EN2
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
		repeat PWP {
			@SPISELECT_PUBKEY();
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
			SDR 32	TDI (0x0000C023);
			setpin ISPEN HIGH;
		}		
		print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN2 (9) and AUTH_EN1 (8) of the status register1
			loop PWP {
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00C00000)
								MASK(0x00C00000);
				setpin ISPEN HIGH;	
			}
			setpin ISPEN HIGH;				
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}
function I2CPROGRAM_PUBKEY{
	datastream SavePublicKey[1][128];
	IF (PublicKey.row = 1)
	{
		print (0,"Programming the Public Keys...");		
		SavePublicKey[1]= PublicKey[1] << 384;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 128 TDI(SavePublicKey[1]);	
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;		
		SavePublicKey[1]= PublicKey[1] << 256;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SDR 32	TDI (0x000000DA);
		SDR 128 TDI(SavePublicKey[1]);	
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;
		SavePublicKey[1]= PublicKey[1] << 128;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SDR 32	TDI (0x00000086);
		SDR 128 TDI(SavePublicKey[1]);	
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;
		SavePublicKey[1]= PublicKey[1];
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY3(0x63) instruction;
		SDR 32	TDI (0x000000C6);
		SDR 128 TDI(SavePublicKey[1]);	
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;
		print (0,"Verify the Public Keys...");
		TRY 1 {
				SavePublicKey[1]= PublicKey[1] << 384;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
				SDR 32	TDI (0x0000005A);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;				
				SavePublicKey[1]= PublicKey[1] << 256;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
				SDR 32	TDI (0x0000003A);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
				SavePublicKey[1]= PublicKey[1] << 128;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
				SDR 32	TDI (0x00000046);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
				SavePublicKey[1]= PublicKey[1];
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
				SDR 32	TDI (0x00000026);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN2 and AUTH_EN1 for ECDSA by default
		//Bit[1] of OPRAND1 = AUTH_EN2
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
		repeat PWP {
			@I2CSELECT_PUBKEY();
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
			SDR 32	TDI (0x0000C023);
			I2C_STOP;
			RUN_TEST DELAY PWP;
		}
		print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN2 (9) and AUTH_EN1 (8) of the status register1
			loop PWP{
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00C00000)
								MASK(0x00C00000);
				I2C_STOP;	
			}
			I2C_STOP;			
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}
function JTAGI2CPROGRAM_PUBKEY
{
	datastream DataByte[1][8];
	datastream TmpPublicKey[1][128];
	IF (PublicKey.row = 1)
	{		
		print (0,"Programming the Public Keys...");	
		TmpPublicKey[1] = PublicKey[1] << 384;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
    	SDR	16	TDI (0x1059);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = TmpPublicKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpPublicKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		
		TmpPublicKey[1] = PublicKey[1] << 256;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
    	SDR	16	TDI (0x105B);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = TmpPublicKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpPublicKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		
		TmpPublicKey[1] = PublicKey[1] << 128;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
    	SDR	16	TDI (0x1061);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = TmpPublicKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpPublicKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		
		TmpPublicKey[1] = PublicKey[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x63) instruction;
    	SDR	16	TDI (0x1063);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = TmpPublicKey[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (TmpPublicKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (TmpPublicKey[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
		
		print (0,"Verify the Public Keys...");
		TRY 1 {
			TmpPublicKey[1] = PublicKey[1] << 384;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
	    	SDR	16	TDI (0x105A);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpPublicKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			TmpPublicKey[1] = PublicKey[1] << 256;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
	    	SDR	16	TDI (0x105C);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpPublicKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			
			TmpPublicKey[1] = PublicKey[1] << 128;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
	    	SDR	16	TDI (0x1062);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpPublicKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
														
			TmpPublicKey[1] = PublicKey[1];
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
	    	SDR	16	TDI (0x1064);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1]);
	    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);	
	    	SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 8);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 16);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 24);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;	
			DataByte[1] = (TmpPublicKey[1] << 32);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 40);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 48);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 56);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 64);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 72);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 80);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 88);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 96);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 104);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 112);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);
			RUN_TEST IDLE TCK 1000 ;
			DataByte[1] = (TmpPublicKey[1] << 120);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (DataByte[1]);	
			
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);	
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;																									
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to program the Public Keys.");
		}
		TRY 1 {
			print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
			repeat PWP {
				@JTAGI2CSELECT_PUBKEY();
				// HMAC Authentication will not supported for Sentry
				// Always program the AUTH_EN2 AUTH_EN1 for ECDSA by default
				//Bit[1] of OPRAND1 = AUTH_EN2
				//Bit[0] of OPRAND1 = AUTH_EN1
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
				SDR	16	TDI (0x10C4);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1003);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5000);
				RUN_TEST	IDLE  TCK 2 DELAY 100;
			}
			print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
			loop PWP {
				@JTAGI2CSELECT_PUBKEY();
				// check bit AUTH_EN2(9) and AUTH_EN1 (8) of the status register1
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);			
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR	16	TDI (0x103D);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x03)
								MASK (0x03);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST	IDLE  TCK 2 DELAY 100;
			}			
		}
		ELSE {		  
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
			RUN_TEST IDLE TCK 1000 ;
			! Check ACK;
			! Shift in LSC_I2C_SR_RD(0x9F) instruction;
			SIR	8	TDI  (0x9F);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x04)
							MASK (0x24);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	16	TDI (0x1026);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			     
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 100;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}
function PROGRAM_TRACEID{
	datastream FeatureArray[1][128];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = (#0^88) @ Config_Register_TDI[1] @ (#0^32);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 128 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK PWP ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
		TRY 1{
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SIR Instruction_Length	TDI (LSC_READ_FEATURE);
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			SDR_VERIFY 128   TDI(#0^128)
							TDO(FeatureArray[1])
							MASK(0x0000000000000000000000FF00000000);
		}
		ELSE{
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program TraceID.");
		}
	} 	
}
function SPIPROGRAM_TRACEID{
	datastream FeatureArray[1][128];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = (#0^88) @ Config_Register_TDI[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1];	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 128 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		TRY 1 {
			setpin ISPEN LOW;
			setpin ISPEN LOW; 
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			SDR_VERIFY 128   TDI(#0^128)
							TDO(FeatureArray[1])
							MASK(0x00000000FF0000000000000000000000);					  						  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed to Program TraceID.");
		}
	    setpin ISPEN HIGH;	
	}
}
function I2CPROGRAM_TRACEID{
	datastream FeatureArray[1][128];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = (#0^88) @ Config_Register_TDI[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 128 TDI(FeatureArray[1]);
	    I2C_STOP;
		loop PWP {
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
		}	 	
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 128   TDI(#0^128)
							TDO(FeatureArray[1])
							MASK(0x00000000FF0000000000000000000000);	
			I2C_STOP;							
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"Failed to Program TraceID.");
		}
	}
}
function JTAGI2CPROGRAM_TRACEID
{
	datastream DataByte[1][8];
	datastream FeatureArray[1][128];
	IF (Config_Register_TDI.row = 1)
	{
		FeatureArray[1] = (#0^88) @ Config_Register_TDI[1] @ (#0^32);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
    	SDR	16	TDI (0x10E4);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
    	DataByte[1] = FeatureArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (FeatureArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 64);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 72);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 80);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 88);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 96);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 104);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 112);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (FeatureArray[1] << 120);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		
		loop PWP {
			RUN_TEST IDLE TCK 2 DELAY 1;
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + WR;
			SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
			RUN_TEST IDLE TCK 1000 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR	16	TDI (0x10F0);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x1000);
			RUN_TEST IDLE TCK 1000 ;
			! Shift in Slave Address + RD;
			SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
			RUN_TEST IDLE TCK 1000 ;
			SDR	16	TDI  (0x2000);
			RUN_TEST IDLE TCK 1000 ;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x80);
		}				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);		
	} 	
}
function PROGRAM_FEABITS {
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 32 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);   
	}
}

function SPIPROGRAM_FEABITS {
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureBitsArray[1] = ArchArray_TDI[1];
		FeatureBitsArray[1] = $FeatureBitsArray[1];
	    //print (0,FeatureBitsArray);
		setpin ISPEN Low;
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);
	    SDR 32 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_READ_FEABITS (0xFB) instruction;
		SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);   
	    setpin ISPEN HIGH;
	}
}

function I2CPROGRAM_FEABITS{
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureBitsArray[1] = ArchArray_TDI[1];
		FeatureBitsArray[1] = $FeatureBitsArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 32 TDI(FeatureBitsArray[1]);
	    I2C_STOP;	
	    RUN_TEST DELAY 1000;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);
	    I2C_STOP;		
	}
}
function PROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN2 and  AUTH_EN1 for ECDSA by default
	//Bit[1] of OPRAND1 = AUTH_EN2
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN2 and  AUTH_EN1 Fuses...");
	! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
	SIR Instruction_Length	TDI (LSC_PROG_AUTH_MODE);
	! Shift in Data; 
	SDR 8 TDI(0x03);
	RUN_TEST	IDLE TCK 2 DELAY PWP;
	print (0,"Verify the AUTH_EN2 and  AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN2 (9) and  AUTH_EN1 (8) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000300)
						MASK(0x00000300);				  		  		    
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}

function SPIPROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN2 and  AUTH_EN1 for ECDSA by default
	//Bit[1] of OPRAND1 = AUTH_EN2
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN2 and  AUTH_EN1 Fuses...");
	setpin ISPEN LOW;
	! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
	SDR 32	TDI (0x0000C023);
	setpin ISPEN HIGH;	
	print (0,"Verify the AUTH_EN2 and  AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN2 (9) and  AUTH_EN1 (8) of the status register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00C00000)
						MASK(0x00C00000);
		setpin ISPEN HIGH;			  		  		    
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}

function I2CPROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN2 and  AUTH_EN1 for ECDSA by default
	//Bit[1] of OPRAND1 = AUTH_EN2
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN2 and  AUTH_EN1 Fuses...");
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
	SDR 32	TDI (0x0000C023);
	I2C_STOP;
	RUN_TEST DELAY PWP;
	print (0,"Verify the AUTH_EN2 and  AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN2 (9) and  AUTH_EN1 (8) of the status register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00C00000)
						MASK(0x00C00000);
		I2C_STOP;			  		  		    
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}
function JTAGI2CPROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN2 and  AUTH_EN1 for ECDSA by default
	//Bit[1] of OPRAND1 = AUTH_EN2
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN2 and  AUTH_EN1 Fuses...");
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
	SDR	16	TDI (0x10C4);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1003);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST	IDLE TCK 2 DELAY PWP;
	print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN2(9) and AUTH_EN1 (8) of the status register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x03)
						MASK (0x03);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  		  		    
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
	}
}
function FEATURE_ROW_READ{
	datastream FeatureRow[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureRowArray[1][96];
	datastream FeatureBitsArray[1][32];
	file	NewFile = "FILE_SAVE"; 	
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 128  TDI(#0^128)
    		 TDO(FeatureArray[1]);
	FeatureRowArray[1] = FeatureArray[1] << 32;
	FeatureRowArray[1] = $FeatureRowArray[1];
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 32  TDI(#0^32)
    		TDO(FeatureBitsArray[1]); 
	FeatureBitsArray[1] = $FeatureBitsArray[1];
	print (0,FeatureBitsArray);
    FeatureRow[1] = (FeatureBitsArray[1] @ FeatureRowArray[1]);
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureRow);
	fclose 	NewFile;
}

function SPIFEATURE_ROW_READ
{
	datastream FeatureRow[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureRowArray[1][96];
	datastream FeatureBitsArray[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR	128	TDI (#0^128)
			TDO	(FeatureArray[1]);
	setpin ISPEN HIGH;
	FeatureArray[1] = $FeatureArray[1];
	FeatureRowArray[1] = FeatureArray[1] << 32;
	FeatureRowArray[1] = $FeatureRowArray[1];
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	SDR	32	TDI (#0^32)
			TDO	(FeatureBitsArray[1]);
	setpin ISPEN HIGH;
    FeatureRow[1] = (FeatureBitsArray[1] @ FeatureRowArray[1]); 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureRow);
	fclose 	NewFile;   	
}

function I2CFEATURE_ROW_READ{
	datastream FeatureRow[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureRowArray[1][96];
	datastream FeatureBitsArray[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	128	TDI (#0^128)
			TDO	(FeatureArray[1]);
	I2C_STOP;
	FeatureArray[1] = $FeatureArray[1];
	FeatureRowArray[1] = FeatureArray[1] << 32;
	FeatureRowArray[1] = $FeatureRowArray[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI (#0^32)
			TDO	(FeatureBitsArray[1]);
	I2C_STOP;
    FeatureRow[1] = (FeatureBitsArray[1] @ FeatureRowArray[1]); 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureRow);
	fclose 	NewFile;   	
}
function JTAGI2CFEATURE_ROW_READ
{
	datastream DataByte[1][8];
	datastream FeatureRow[1][128];
	datastream FeatureArray[1][128];
	datastream FeatureRowArray[1][96];
	datastream FeatureBitsArray[1][32];
	file	NewFile = "FILE_SAVE"; 	
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SDR	16	TDI (0x10E7);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;	
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	FeatureArray[1] = ((FeatureArray[1]) @ (DataByte[1])) << 8;			
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	FeatureRowArray[1] = FeatureArray[1] << 32;
	FeatureRowArray[1] = $FeatureRowArray[1];
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SDR	16	TDI (0x10FB);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	FeatureBitsArray[1] = ((FeatureBitsArray[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	FeatureBitsArray[1] = $FeatureBitsArray[1];
	print (0,FeatureBitsArray);
    FeatureRow[1] = (FeatureBitsArray[1] @ FeatureRowArray[1]);
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureRow);
	fclose 	NewFile;
}
function CFG0_PROGRAM_USERCODE
{
	@SELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI_CFG0[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function SPICFG0_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	@SPISELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}
function I2CCFG0_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@I2CSELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function JTAGI2CCFG0_PROGRAM_USERCODE
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	@JTAGI2CSELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 
	}
}
function CFG1_PROGRAM_USERCODE 
{
	@SELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI_CFG1[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function SPICFG1_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@SPISELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}
function I2CCFG1_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@I2CSELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function JTAGI2CCFG1_PROGRAM_USERCODE 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	@JTAGI2CSELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1;
	}
}
function PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}

function SPIPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}

function I2CPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function CFG0_VERIFY_USERCODE 
{
	@SELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI_CFG0)
									MASK(0xFFFFFFFF);
	}
}
function SPICFG0_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@SPISELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CCFG0_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@I2CSELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CCFG0_VERIFY_USERCODE 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	@JTAGI2CSELECT_CFG0();
	IF (Usercode_TDI_CFG0.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
	}
}
function CFG1_VERIFY_USERCODE 
{
	@SELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI_CFG1)
									MASK(0xFFFFFFFF);
	}
}
function SPICFG1_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@SPISELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CCFG1_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	@I2CSELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CCFG1_VERIFY_USERCODE 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	@JTAGI2CSELECT_CFG1();
	IF (Usercode_TDI_CFG1.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
	}
}
function SRAM_VERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
	}
}
function VERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI)
									MASK(0xFFFFFFFF);
	}
}
function SPISRAM_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = $Usercode_TDI[1];
		SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function SPIVERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(Usercode_TDI[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CSRAM_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = $Usercode_TDI[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function I2CVERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	   	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CSRAM_VERIFY_USERCODE 
{
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
	}
}
function JTAGI2CVERIFY_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 									
	}
}
function VERIFY_SRAM_DONE_BIT {
	datastream SavedRegister[1][32];
	TRY 1 {
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00002100);	  		  		    
	}
	ELSE {		  
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR  32 	TDI(#0^32)
					TDO(SavedRegister[1]);
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x02800000)
		{
			print (0,"Authentication failed. Bitstream does not match required format.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (0,"Authentication failed. Signature does not match.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02400000)
		{
			print (0,"Authentication failed. HSE is not available.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x00400000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x00C00000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			TRY 1 {
				// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00000300)
								MASK(0x00000300);
				print (1,"The Authentication Feature is set. The bitstream might not match required format?");
			}
			print (1,"Cannot Continue.");
		}
	}
}
function SVF_VERIFY_SRAM_DONE_BIT {
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
					TDO(0x00000100)
					MASK(0x00002100);	  		  		    	
}
function SPIVERIFY_SRAM_DONE_BIT {
	datastream SavedRegister[1][32];
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x00840000);
		setpin ISPEN HIGH; 		  		    
	}
	ELSE {		
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR  32 	TDI(#0^32)
				  	TDO(SavedRegister[1]);
		setpin ISPEN HIGH; 		
		SavedRegister[1] = $SavedRegister[1];
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x02800000)
		{
			print (0,"Authentication failed. Bitstream does not match required format.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (0,"Authentication failed. Signature does not match.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02400000)
		{
			print (0,"Authentication failed. HSE is not available.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x00400000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x00C00000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			TRY 1 {
				// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(0x00C00000)
								MASK(0x00C00000);
				setpin ISPEN HIGH;	
				print (1,"The Authentication Feature is set. The bitstream might not match required format?");
			}
			print (1,"Cannot Continue.");
		}
	}
}
function SVF_SPIVERIFY_SRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00800000)
			  	MASK(0x00840000);
	setpin ISPEN HIGH; 		  		    
}
function I2CVERIFY_SRAM_DONE_BIT {
	datastream SavedRegister[1][32];
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x00840000);
		I2C_STOP;		  		    
	}
	ELSE {		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR  32 	TDI(#0^32)
				  	TDO(SavedRegister[1]);
		I2C_STOP;	
		SavedRegister[1] = $SavedRegister[1];
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x02800000)
		{
			print (0,"Authentication failed. Bitstream does not match required format.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (0,"Authentication failed. Signature does not match.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02400000)
		{
			print (0,"Authentication failed. HSE is not available.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x00400000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x00C00000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			TRY 1 {
				// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
								TDO(0x00C00000)
								MASK(0x00C00000);
				I2C_STOP;	
				print (1,"The Authentication Feature is set. The bitstream might not match required format?");
			}
			print (1,"Cannot Continue.");
		}
	}
}
function SVF_I2CVERIFY_SRAM_DONE_BIT 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00800000)
			  		MASK(0x00840000);
	I2C_STOP;		  		    
}
function JTAGI2CVERIFY_SRAM_DONE_BIT 
{
	datastream DataByte[1][8];
	datastream SavedRegister[1][32];
	RUN_TEST	IDLE  TCK 100 DELAY 1000;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	TRY 1 {		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x21);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;			  		  		    
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 	
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 	
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);			
		SavedRegister[1] = ((SavedRegister[1]) @ (DataByte[1])) << 8;				
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		SavedRegister[1] = SavedRegister[1] & 0x03C00000;
		IF (SavedRegister[1] == 0x02800000)
		{
			print (0,"Authentication failed. Bitstream does not match required format.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02000000)
		{
			print (0,"Authentication failed. Signature does not match.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x02400000)
		{
			print (0,"Authentication failed. HSE is not available.");
			print (1,"Failed to program SRAM Done.");
		}
		ELSEIF (SavedRegister[1] == 0x00400000)
		{
			print (1,"Failed to program SRAM Done. Mismatch to the device ID code.");
		}
		ELSEIF (SavedRegister[1] == 0x00800000)
		{
			print (1,"Failed to program SRAM Done. Illegal command detected.");
		}
		ELSEIF (SavedRegister[1] == 0x00C00000)
		{
			print (1,"Failed to program SRAM Done. CRC checksum error.");
		}
		ELSE
		{
			print (0,"Failed to program SRAM Done.");
			TRY 1 {
				// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				! Shift in Slave Address + WR;
				SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
				RUN_TEST IDLE TCK 1000 ;
				! Check ACK;
				! Shift in LSC_I2C_SR_RD(0x9F) instruction;
				SIR	8	TDI  (0x9F);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x04)
								MASK (0x24);
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);			
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR	16	TDI (0x103D);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x1000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in Slave Address + RD;
				SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
				RUN_TEST IDLE TCK 1000 ;
				SDR	16	TDI  (0x2000);
				RUN_TEST IDLE TCK 1000 ;
				! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
				SIR	8	TDI  (0x9E);
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x03)
								MASK (0x03);
				RUN_TEST IDLE TCK 1000 ;
				SDR_VERIFY	8	TDI  (0x00)
								TDO  (0x00)
								MASK (0x00);	
				! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
				SIR	8	TDI  (0x9D);
				SDR	16	TDI  (0x5800);
				RUN_TEST IDLE TCK 1000 ;
				print (1,"The Authentication Feature is set. The bitstream might not match required format?");
			}
			print (1,"Cannot Continue.");
		}
	}
}
function DISABLE_REFRESH {	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;   
	
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100;
}

function SPIDISABLE_REFRESH {
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
    setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
}

function I2CDISABLE_REFRESH {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
}
function FLASHA_PROGRAM_DONE_BIT 
{
	TRY 1 {
		loop PWP {
			! Shift in ISC PROGRAM DONE(0x5E) instruction;
			SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
			RUN_TEST	IDLE TCK 2 DELAY PWP;		
			// check bit Flash CFG0_DONE bit(12) of the status register1
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00001000)
							MASK(0x00001000);
		}
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Flash A Done bit.");
	}
}
function SPIFLASHA_PROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY PWP;		
	TRY 1 {
		setpin ISPEN LOW;
		// check bit Flash CFG0_DONE bit(12) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00080000)
				  	MASK(0x00080000);
		setpin ISPEN HIGH;
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (1,"Failed to Program the Flash A DONE bit.");
	}
}

function I2CFLASHA_PROGRAM_DONE_BIT 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00080000)
				  	MASK(0x00080000);
		I2C_STOP;
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (1,"Failed to Program the Flash A DONE bit.");
	}
}
function JTAGI2CFLASHA_PROGRAM_DONE_BIT 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
    RUN_TEST	IDLE TCK 2 DELAY PWP;		
	TRY 1 {
		// check bit Flash CFG0_DONE bit(12) of the status register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x10)
						MASK (0x10);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (1,"Failed to Program the Flash A Done bit.");
	}
}
function FLASHB_PROGRAM_DONE_BIT 
{
	TRY 1 {
		loop PWP {
			! Shift in ISC PROGRAM DONE(0x5E) instruction;
			SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
			RUN_TEST	IDLE TCK 2 DELAY PWP;	
			// check bit Flash CFG1_DONE bit(13) of the status register1
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00002000)
							MASK(0x00002000);
		}
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Flash B Done bit.");
	}
}
function SPIFLASHB_PROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY PWP;		
	TRY 1 {
		setpin ISPEN LOW;
		// check bit Flash CFG1_DONE bit(13) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00040000)
				  	MASK(0x00040000);
		setpin ISPEN HIGH;
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (1,"Failed to Program the Flash B DONE bit.");
	}
}

function I2CFLASHB_PROGRAM_DONE_BIT 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00040000)
				  	MASK(0x00040000);
		I2C_STOP;
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (1,"Failed to Program the Flash B DONE bit.");
	}
}
function JTAGI2CFLASHB_PROGRAM_DONE_BIT 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;	
	RUN_TEST	IDLE TCK 2 DELAY PWP;		
	TRY 1 {
		// check bit Flash CFG1_DONE bit(13) of the status register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x20)
						MASK (0x20);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;		
	}
	ELSE {		  
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE);
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;
		print (1,"Failed to Program the Flash B Done bit.");
	}
}
function FLASH_PROGRAM_DONE_BIT 
{
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST	IDLE TCK 2 DELAY PWP;		
	TRY 1 {
		! Shift in BYPASS(0xFF) instruction;
    	SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
										TDO(0x04)
										MASK(0xC4);
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Done bit.");
	}
}
function SPIFLASH_PROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY PWP;		
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x008C0000);
		setpin ISPEN HIGH;
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (1,"Failed to Program the DONE bit.");
	}
}

function I2CFLASH_PROGRAM_DONE_BIT 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x008C0000);
		I2C_STOP;
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (1,"Failed to Program the DONE bit.");
	}
}
function VERIFY_DONE_BIT {	
	RUN_TEST	IDLE  TCK 100 DELAY 5000;
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0x84);	   	      	
}

function SPIVERIFY_DONE_BIT {	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	setpin ISPEN HIGH;  	      	
}

function I2CVERIFY_DONE_BIT {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	I2C_STOP;  	      	
}
function CHECK_STATUS {
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI(LSC_READ_STATUS0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x00003000);
}

function SPICHECK_STATUS {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000000)
			  		MASK(0x000C0000);
	setpin ISPEN HIGH;
}

function I2CCHECK_STATUS {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x000C0000);
	I2C_STOP;
}
function JTAGI2CCHECK_STATUS {
	TRY 1
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			 
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed in Function JTAGI2CCHECK_STATUS. Cannot continue.");	
	}
}
function JTAGI2CFEATURECHECK_STATUS {
	datastream JTAGI2CN_WRITE[1][8];
	datastream JTAGI2CN_READ[1][8];
	
	JTAGI2CN_READ[1] = (NEW_I2C_ADDR_READ) ;
	JTAGI2CN_READ[1] = $JTAGI2CN_READ[1];
	JTAGI2CN_WRITE[1] = (NEW_I2C_ADDR_WRITE ) ;
	JTAGI2CN_WRITE[1] = $JTAGI2CN_WRITE[1];
	
	TRY 1
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		print (0,$NEW_I2C_ADDR_WRITE);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ (JTAGI2CN_WRITE[1]));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ (JTAGI2CN_READ[1]));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x30);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;	
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
			 
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed in Function JTAGI2CFEATURECHECK_STATUS. Cannot continue.");	
	}
}
function CFG0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap0[RowCount]);	
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function SPICFG0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY 1000;	
	repeat Temp_Row_Count
    {	
    	setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000008CE);	    
    	! Shift out Data Row = RowCount; 			
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap0[RowCount]);
		setpin ISPEN HIGH;		
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function I2CCFG0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	I2C_STOP;
	RUN_TEST DELAY 1000;
		
	repeat Temp_Row_Count
    {	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000008CE);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	    
    	! Shift out Data Row = RowCount; 			
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap0[RowCount]);
		I2C_STOP;		
		RowCount = RowCount +1;	
	}		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function JTAGI2CCFG0_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap);
	fclose 	NewFile;
}
function CFG1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap1[RowCount]);	
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap1);
	fclose 	NewFile;
}
function SPICFG1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
    {	
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap1[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap1);
	fclose 	NewFile;
}
function I2CCFG1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00800062);
	I2C_STOP;
	RUN_TEST DELAY 1000;	
	repeat Temp_Row_Count
    {	
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR 32	TDI	(0x000008CE);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	    
    	! Shift out Data Row = RowCount; 			
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap1[RowCount]);
		I2C_STOP;		
		RowCount = RowCount +1;	
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap1);
	fclose 	NewFile;
}
function JTAGI2CCFG1_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap);
	fclose 	NewFile;
}
function UFM0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CUFM0_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, SavedFuseMap);
	fclose 	NewFile;			
}
function UFM1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CUFM1_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		SavedFuseMap[RowCount] = $SavedFuseMap[RowCount];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, SavedFuseMap);
	fclose 	NewFile;
}
function UFM2_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM2_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM2_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM2_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM2_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM2_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CUFM2_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM2_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, SavedFuseMap);
	fclose 	NewFile;
}
function UFM3_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM3_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM3_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM3_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM3_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM3_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function JTAGI2CUFM3_SAVE_ARRAY 
{
	datastream DataByte[1][8];
	int32	RowCount = 1;
	datastream SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM3_Count
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
    	SDR	16	TDI (0x1073);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1021);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift out Data Row = RowCount; 	
    	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);	
    	SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;		
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;				
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;	
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		RUN_TEST IDLE TCK 1000 ;
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		SavedFuseMap[RowCount] = ((SavedFuseMap[RowCount]) @ (DataByte[1])) << 8;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);	
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;		
		RowCount = RowCount +1;		
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, SavedFuseMap);
	fclose 	NewFile;
}
function CSEC_PROGRAM_CENTRAL_LOCK
{
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SIR Instruction_Length TDI (LSC_READ_CSEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		TRY 1 {
			SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(#0^32);
		}
		ELSE
		{					
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CSEC);
		SDR 32 TDI(CSEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SIR Instruction_Length TDI (LSC_READ_CSEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(CSEC_Array_TDI[1])
				  		MASK(CSEC_Array_TDI[1]);
	}
}
function CSEC_PROGRAM_CENTRAL_LOCK_SVF
{
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
				
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CSEC);
		SDR 32 TDI(CSEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SIR Instruction_Length TDI (LSC_READ_CSEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(CSEC_Array_TDI[1])
				  		MASK(CSEC_Array_TDI[1]);
	}
}
function SPICSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);						
		TRY 1 {
			SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(#0^32);
			setpin ISPEN HIGH;								
		}
		ELSE
		{					
			setpin ISPEN HIGH;
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		setpin ISPEN HIGH;
	}
}
function SPICSEC_PROGRAM_CENTRAL_LOCK_SVF
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		setpin ISPEN HIGH;
	}
}
function I2CCSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);				
		TRY 1 {
			SDR_TRY_VERIFY  32 	TDI(#0^32)
								TDO(#0^32);
			I2C_STOP;								
		}
		ELSE
		{					
			I2C_STOP;
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		I2C_STOP;
	}
}
function I2CCSEC_PROGRAM_CENTRAL_LOCK_SVF
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		I2C_STOP;
	}
}
function JTAGI2CCSEC_PROGRAM_CENTRAL_LOCK
{
	datastream DataByte[1][8];
	datastream SavedArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		// Bit15 SEC_ERASE_C_SRAM
		// Bit16 SEC_PROG_C_SRAM
		// Bit17 SEC_READ_C_SRAM
		// Bit18 SEC_HLOCK_C_SRAM
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR	16	TDI (0x1054);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedArray[1] = CSEC_Array_TDI[1];
	    DataByte[1] = SavedArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 100; 
		
		SavedArray[1] = CSEC_Array_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CSEC(0x55) instruction;
	    SDR	16	TDI (0x1055);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedArray[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);
		DataByte[1] = (SavedArray[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);	
		DataByte[1] = (SavedArray[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);
		DataByte[1] = (SavedArray[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 		
	}
}
function CFG_READ_CENTRAL_LOCK
{
	datastream CSECSavedFuseMap[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_CSEC(0x55) instruction;
	SIR Instruction_Length TDI (LSC_READ_CSEC);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 	TDI(#0^32)
				TDO(CSECSavedFuseMap);				
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS1);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);				
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;	
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;					 
}
function SPICFG_READ_CENTRAL_LOCK
{
	datastream CSECSavedFuseMap[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_CSEC(0x55) instruction;
	SDR 32 TDI (0x000000AA);						
	SDR  32 	TDI(#0^32)
				TDO(CSECSavedFuseMap[1]);
	setpin ISPEN HIGH;		
	CSECSavedFuseMap[1] = $CSECSavedFuseMap[1];	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);	
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;	
}
function I2CCFG_READ_CENTRAL_LOCK
{
	datastream CSECSavedFuseMap[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_CSEC(0x55) instruction;
	SDR 32 TDI (0x000000AA);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  32 	TDI(#0^32)
			  	TDO(CSECSavedFuseMap[1]);
	I2C_STOP;
	CSECSavedFuseMap[1] = $CSECSavedFuseMap[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);	
	I2C_STOP;		
	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;		
}
function JTAGI2CCFG_READ_CENTRAL_LOCK
{
	datastream DataByte[1][8];
	datastream CSECSavedFuseMap[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CSEC(0x55) instruction;
    SDR	16	TDI (0x1055);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	CSECSavedFuseMap[1] = ((CSECSavedFuseMap[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	CSECSavedFuseMap[1] = ((CSECSavedFuseMap[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	CSECSavedFuseMap[1] = ((CSECSavedFuseMap[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	CSECSavedFuseMap[1] = ((CSECSavedFuseMap[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
				
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, CSECSavedFuseMap);
	fclose 	NewFile;
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;	
}
function USEC_PROGRAM_CENTRAL_LOCK
{
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
		
		! Shift in LSC_READ_USEC(0x57) instruction;
		SIR Instruction_Length TDI (LSC_READ_USEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		TRY 1 {
			SDR_TRY_VERIFY  16 	TDI(#0^16)
								TDO(#0^16);
		}
		ELSE
		{					
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_USEC);
		SDR 16 TDI(USEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_READ_USEC(0x57) instruction;
		SIR Instruction_Length TDI (LSC_READ_USEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(USEC_Array_TDI[1])
				  		MASK(USEC_Array_TDI[1]);
	}
}
function USEC_PROGRAM_CENTRAL_LOCK_SVF
{
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
				
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_USEC);
		SDR 16 TDI(USEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY 100;
		! Shift in LSC_READ_USEC(0x57) instruction;
		SIR Instruction_Length TDI (LSC_READ_USEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(USEC_Array_TDI[1])
				  		MASK(USEC_Array_TDI[1]);
	}
}
function SPIUSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][16];
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
		
		setpin ISPEN LOW;
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 32 TDI (0x000000EA);						
		TRY 1 {
			SDR_TRY_VERIFY  16 	TDI(#0^16)
								TDO(#0^16);
			setpin ISPEN HIGH;								
		}
		ELSE
		{					
			setpin ISPEN HIGH;
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		LockBitsArray[1] = USEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SDR 32	TDI (0x0000006A);
		SDR 16 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 16 TDI (0x000000EA);
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		setpin ISPEN HIGH;
	}
}
function SPIUSEC_PROGRAM_CENTRAL_LOCK_SVF
{
	datastream LockBitsArray[1][16];
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
				
		LockBitsArray[1] = USEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SDR 32	TDI (0x0000006A);
		SDR 16 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 16 TDI (0x000000EA);
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		setpin ISPEN HIGH;
	}
}
function I2CUSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][16];
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 32 TDI (0x000000EA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);				
		TRY 1 {
			SDR_TRY_VERIFY  16 	TDI(#0^16)
								TDO(#0^16);
			I2C_STOP;								
		}
		ELSE
		{					
			I2C_STOP;
			print (0,"Warning: some sectors lock is already set. Central locks cannot be un-set");
		}
		
		LockBitsArray[1] = USEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SDR 32	TDI (0x0000006A);
		SDR 16 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 32 TDI (0x000000EA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		I2C_STOP;
	}
}
function I2CUSEC_PROGRAM_CENTRAL_LOCK_SVF
{
	datastream LockBitsArray[1][16];
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3				
		
		LockBitsArray[1] = USEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SDR 32	TDI (0x0000006A);
		SDR 16 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_USEC(0x57) instruction;
		SDR 32 TDI (0x000000EA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  16 	TDI(#0^16)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		I2C_STOP;
	}
}
function JTAGI2CUSEC_PROGRAM_CENTRAL_LOCK
{
	datastream DataByte[1][8];
	datastream SavedUSECArray[1][16];
	IF (USEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_UFM0
		// Bit1 SEC_READ_C_UFM0
		// Bit2 SEC_HLOCK_C_UFM0
		// Bit3 SEC_ERASE_C_UFM1
		// Bit4 SEC_READ_C_UFM1
		// Bit5 SEC_HLOCK_C_UFM1
		// Bit6 SEC_ERASE_C_UFM2
		// Bit7 SEC_READ_C_UFM2
		// Bit8 SEC_HLOCK_C_UFM2
		// Bit9 SEC_ERASE_C_UFM3
		// Bit10 SEC_READ_C_UFM3
		// Bit11 SEC_HLOCK_C_UFM3
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_USEC(0x56) instruction;
		SDR	16	TDI (0x1056);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUSECArray[1] = USEC_Array_TDI[1];
	    DataByte[1] = SavedUSECArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUSECArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 100;
		
		SavedUSECArray[1] = USEC_Array_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_USEC(0x57) instruction;
	    SDR	16	TDI (0x1057);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUSECArray[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);
		DataByte[1] = (SavedUSECArray[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (DataByte[1]);	
		RUN_TEST IDLE TCK 1000 ;											
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				
	}
}
function UFM_READ_CENTRAL_LOCK
{
	datastream SavedSTATUS1[1][32];
	datastream USECSavedFuseMap[1][16];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_USEC(0x57) instruction;
	SIR Instruction_Length TDI (LSC_READ_USEC);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  16 	TDI(#0^16)
				TDO(USECSavedFuseMap[1]);
	
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS1);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);							
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, USECSavedFuseMap);
	fclose 	NewFile;	
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;
		
}
function SPIUFM_READ_CENTRAL_LOCK
{
	datastream USECSavedFuseMap[1][16];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_USEC(0x57) instruction;
	SDR 32 TDI (0x000000EA);						
	SDR  16 	TDI(#0^16)
				TDO(USECSavedFuseMap[1]);
	setpin ISPEN HIGH;		
	USECSavedFuseMap[1] = $USECSavedFuseMap[1];	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);	
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, USECSavedFuseMap);
	fclose 	NewFile;
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;	
}
function I2CUFM_READ_CENTRAL_LOCK
{
	datastream USECSavedFuseMap[1][16];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_USEC(0x57) instruction;
	SDR 32 TDI (0x000000EA);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  16 	TDI(#0^16)
			  	TDO(USECSavedFuseMap[1]);
	I2C_STOP;
	USECSavedFuseMap[1] = $USECSavedFuseMap[1];	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);	
	I2C_STOP;		
		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, USECSavedFuseMap);
	fclose 	NewFile;	
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;	
}
function JTAGI2CUFM_READ_CENTRAL_LOCK
{
	datastream DataByte[1][8];
	datastream USECSavedFuseMap[1][16];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_USEC(0x57) instruction;
    SDR	16	TDI (0x1057);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	USECSavedFuseMap[1] = ((USECSavedFuseMap[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	USECSavedFuseMap[1] = ((USECSavedFuseMap[1]) @ (DataByte[1])) << 8;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
		
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS1[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
						
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, USECSavedFuseMap);
	fclose 	NewFile;
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedSTATUS1);
	fclose 	NewFile;
}
function CSEC_PROGRAM_PORTS_LOCK
{
	IF (CSEC_Array_TDI.row = 1)
	{		
		// Bit19 SEC_JTAG_0
		// Bit20 SEC_JTAG_1
		// Bit21 SEC_HLOCK_JTAG
		// Bit22 SEC_SPIS_0
		// Bit23 SEC_SPIS_1
		// Bit24 SEC_HLOCK_SPIS
		// Bit25 SEC_I2CS_0
		// Bit26 SEC_I2CS_1
		// Bit27 SEC_HLOCK_I2CS
		// Bit28 SEC_SPIB
		// Bit29 SEC_HLOCK_SPIB
		// Bit30 SEC_I2CB
		// Bit31 SEC_HLOCK_I2CB
		
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CSEC);
		SDR 32 TDI(CSEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY 100;		
	}
}
function SPICSEC_PROGRAM_PORTS_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit19 SEC_JTAG_0
		// Bit20 SEC_JTAG_1
		// Bit21 SEC_HLOCK_JTAG
		// Bit22 SEC_SPIS_0
		// Bit23 SEC_SPIS_1
		// Bit24 SEC_HLOCK_SPIS
		// Bit25 SEC_I2CS_0
		// Bit26 SEC_I2CS_1
		// Bit27 SEC_HLOCK_I2CS
		// Bit28 SEC_SPIB
		// Bit29 SEC_HLOCK_SPIB
		// Bit30 SEC_I2CB
		// Bit31 SEC_HLOCK_I2CB
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;		
	}
}
function I2CCSEC_PROGRAM_PORTS_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit19 SEC_JTAG_0
		// Bit20 SEC_JTAG_1
		// Bit21 SEC_HLOCK_JTAG
		// Bit22 SEC_SPIS_0
		// Bit23 SEC_SPIS_1
		// Bit24 SEC_HLOCK_SPIS
		// Bit25 SEC_I2CS_0
		// Bit26 SEC_I2CS_1
		// Bit27 SEC_HLOCK_I2CS
		// Bit28 SEC_SPIB
		// Bit29 SEC_HLOCK_SPIB
		// Bit30 SEC_I2CB
		// Bit31 SEC_HLOCK_I2CB
		
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;		
	}
}
function JTAGI2CCSEC_PROGRAM_PORTS_LOCK
{
	datastream DataByte[1][8];
	datastream SavedArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{		
		// Bit19 SEC_JTAG_0
		// Bit20 SEC_JTAG_1
		// Bit21 SEC_HLOCK_JTAG
		// Bit22 SEC_SPIS_0
		// Bit23 SEC_SPIS_1
		// Bit24 SEC_HLOCK_SPIS
		// Bit25 SEC_I2CS_0
		// Bit26 SEC_I2CS_1
		// Bit27 SEC_HLOCK_I2CS
		// Bit28 SEC_SPIB
		// Bit29 SEC_HLOCK_SPIB
		// Bit30 SEC_I2CB
		// Bit31 SEC_HLOCK_I2CB
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR	16	TDI (0x1054);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedArray[1] = CSEC_Array_TDI[1];
	    DataByte[1] = SavedArray[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedArray[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 100; 						
	}
}
function FLASH_SUDO_TRANSPARENT_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x0A);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function PSUEDO_FLASH_ERASE
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0400);
	RUN_TEST 	TCK 2 DELAY 1000;
}
function ENABLE_CPOL_BIT
{
	datastream SavedControl1[1][32];
	! Shift in LSC_READ_CTRL1(0x21) instruction;
	SIR Instruction_Length TDI (LSC_READ_CTRL1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1[1]);
	SavedControl1[1] = SavedControl1[1] | 0x00C00000;
	! Shift in LSC_PROG_CTRL1(0x23) instruction;
	SIR Instruction_Length TDI (LSC_PROG_CTRL1);
	SDR 32 TDI(SavedControl1[1]);
	RUN_TEST IDLE TCK 2 DELAY PWP; 
}
function SVF_ENABLE_CPOL_BIT
{
	! Shift in LSC_PROG_CTRL1(0x23) instruction;
	SIR Instruction_Length TDI (LSC_PROG_CTRL1);
	SDR 32 TDI(0x00C00000);
	RUN_TEST IDLE TCK 2 DELAY PWP; 
}
function ENABLE_MASTER_SPI
{
	datastream FeatureBitsArray[1][32];
	FeatureBitsArray[1] = #00000000000000000001100000100000;
	! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    SDR 32 TDI(FeatureBitsArray[1]);
    RUN_TEST IDLE TCK 2 DELAY PWP;	  
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR_VERIFY 32   TDI(#0^32)
    				TDO(FeatureBitsArray[1]);
}
function PROGRAM_MANUFACTURING_REGISTER
{
	IF (Config_Register_TDI.row = 1)
	{
		print (0,Config_Register_TDI);
		! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
	    SDR 128 TDI(Config_Register_TDI[1]);
	    RUN_TEST IDLE TCK 2 DELAY PWP;
	}
}
function READ_TRIM_REGISTER
{
	datastream TrimArray[1][256];
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000034D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_PES(0x11) instruction;
    SIR Instruction_Length	TDI (LSC_READ_PES);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR 256 TDI(#0^256)
    	    TDO(TrimArray[1]);
   	print (0,TrimArray);
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000);     
}
function READ_PES_FUSES
{
	datastream SavedPESFuse[1][32];
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000004D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_PES(0x11) instruction;
    SIR Instruction_Length	TDI (LSC_READ_PES);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR	 32	TDI(#0^32)
			TDO(SavedPESFuse[1]);
	
	print (0,SavedPESFuse);
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000); 
	 	
}
function READ_MES_REGISTER
{
	datastream MESArray[1][64];
	datastream tmpMESArray[1][128];
	file	NewFile = "FILE_SAVE";
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000000000000000000000014D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_PES(0x11) instruction;
    SIR Instruction_Length	TDI (LSC_READ_PES);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR 128 TDI(0x00000000000000000000000000000000)
    	   TDO(tmpMESArray[1]);
   	MESArray[1] = tmpMESArray[1];
    print (0,MESArray);
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000); 
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, MESArray);
	fclose 	NewFile;
}
function READ_DTR_REGISTER
{
	datastream DTRArray[1][8];
	file	NewFile = "FILE_SAVE"; 
	//82:82	mfgbit_dtr_en	Digital Temp Readout Enable Bit via Mnfg Mode
	! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x0000000000800000000000000000004D);
    RUN_TEST IDLE TCK 2 DELAY 200;
	! Shift in LSC_READ_TEMP(0xE8) instruction;
    SIR Instruction_Length	TDI (LSC_READ_TEMP);
    RUN_TEST IDLE TCK 2 DELAY 200;
    SDR 8 TDI(0x00)
    	   TDO(DTRArray[1]);  
    print (0,DTRArray);
    ! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
	SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    SDR 128 TDI(0x00000000000000000000000000000000);  
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, DTRArray);
	fclose 	NewFile;
}
function CHECK_AUTHTICATE
{
	datastream SavedControl0[1][32];
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00000300)
						MASK(0x00000300);
		@SRAM_ENABLE();		
		! Shift in LSC_READ_CTRL0(0x20) instruction;
		SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR  32 TDI(0x00000000)
				TDO(SavedControl0[1]);

		SavedControl0[1] = SavedControl0[1] | 0x00400000;
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL0);
		SDR 32 TDI(SavedControl0[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		@DISABLE();
	}
}
function SPICHECK_AUTHTICATE
{
	datastream SavedControl0[1][32];
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00C00000)
						MASK(0x00C00000);
		setpin ISPEN HIGH;			  		  		    
		@SPISRAM_ENABLE();		
		! Shift in LSC_READ_CTRL0(0x20) instruction;
		setpin ISPEN LOW;
		SDR 32 TDI (0x00000004);
		SDR  32 TDI(0x00000000)
				TDO(SavedControl0[1]);
		setpin ISPEN HIGH;
		SavedControl0[1] = SavedControl0[1] | 0x00000200;
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
		setpin ISPEN LOW;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(SavedControl0[1]);
		setpin ISPEN HIGH;
		@SPIDISABLE();	
	}
	ELSE
	{
		setpin ISPEN HIGH;	
	}
}
function I2CCHECK_AUTHTICATE
{	
	datastream SavedControl0[1][32];
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00C00000)
						MASK(0x00C00000);
		I2C_STOP;	
		@I2CSRAM_ENABLE();
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC READ CONTROL_0(0x20) instruction;
		SDR 32 TDI (0x00000004);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR	32	TDI(#0^32)
				TDO(SavedControl0[1]);
		I2C_STOP;			
		SavedControl0[1] = SavedControl0[1] | 0x00000200;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(SavedControl0[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 		
		@I2CDISABLE();
	}
	ELSE
	{
		I2C_STOP;
	}
}
function JTAGI2CCHECK_AUTHTICATE
{	
	datastream SavedControl0[1][32];
	TRY 1 
	{
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_TRY_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_TRY_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_TRY_VERIFY	8	TDI  (0x00)
							TDO  (0x03)
							MASK (0x03);
		RUN_TEST IDLE TCK 1000 ;
		SDR_TRY_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		@JTAGI2CSRAM_ENABLE();
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
		SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
		
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		RUN_TEST IDLE TCK 1000 ;
		SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
		
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
		
		SDR	8	TDI  (0x00)
				TDO  (DataByte[1]);	
		RUN_TEST IDLE TCK 1000 ;				
		SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;									
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 

		SavedControl0[1] = SavedControl0[1] | 0x00400000;

		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
		SDR	16	TDI (0x1022);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    DataByte[1] = SavedControl0[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
		@JTAGI2CDISABLE();
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 
	}
}
function CHECK_AUTHTICATE_ENABLE
{
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00000000)
						MASK(0x00000300);
	}
	ELSE
	{
		print (1,"The Authentication Feature is set. Cannot support in this operation.");
	}
}
function SPICHECK_AUTHTICATE_ENABLE
{
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
						TDO(0x00000000)
						MASK(0x00C00000);
		setpin ISPEN HIGH;			  		
	}
	ELSE
	{
		print (1,"The Authentication Feature is set. Cannot support in this operation.");
	}
}
function I2CCHECK_AUTHTICATE_ENABLE
{
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000000)
						MASK(0x00C00000);
		I2C_STOP;	
	}
	ELSE
	{
		print (1,"The Authentication Feature is set. Cannot support in this operation.");
	}
}
function JTAGI2CCHECK_AUTHTICATE_ENABLE
{	
	TRY 1 {
		// check bit AUTH_EN2 AUTH_EN1 of the Status Register1
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);			
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR	16	TDI (0x103D);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x03);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		print (1,"The Authentication Feature is set. Cannot support in this operation.");
	}
}
function SVF_CHECK_AUTHTICATE
{
	@SRAM_ENABLE();		
	! Shift in LSC_PROG_CTRL0(0x22) instruction;
	SIR Instruction_Length TDI (LSC_PROG_CTRL0);
	SDR 32 TDI(0x00400000);
	RUN_TEST IDLE TCK 2 DELAY PWP;
	@DISABLE();
}
function SVF_SPICHECK_AUTHTICATE
{			  		  		    
	@SPISRAM_ENABLE();		
	! Shift in LSC_PROG_CTRL0(0x22) instruction;
	setpin ISPEN LOW;
	SDR 32 TDI (0x00000044);
	SDR 32 TDI(0x00000200);
	setpin ISPEN HIGH;
	@SPIDISABLE();	
}
function SVF_I2CCHECK_AUTHTICATE
{
	@I2CSRAM_ENABLE();
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_PROG_CTRL0(0x22) instruction;
	SDR 32 TDI (0x00000044);
	SDR 32 TDI(0x00000200);
	I2C_STOP;		
	@I2CDISABLE();
	
}
function SVF_JTAGI2CCHECK_AUTHTICATE
{
	@JTAGI2CSRAM_ENABLE();
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_PROG_CTRL0(0x22) instruction;
	SDR	16	TDI (0x1022);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x1000); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x1040); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x1000); 
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI ((0x1000); 
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1; 
	@JTAGI2CDISABLE();
}

function FLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@CFG0_DRYRUN();		
	}
}
function SPIFLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@SPICFG0_DRYRUN();		
	}
}
function I2CFLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@I2CCFG0_DRYRUN();		
	}
}
function JTAGI2CFLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@JTAGI2CCFG0_DRYRUN();		
	}
}
function FLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@CFG1_DRYRUN();		
	}
}
function SPIFLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@SPICFG1_DRYRUN();		
	}
}
function I2CFLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@I2CCFG1_DRYRUN();		
	}
}
function JTAGI2CFLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@JTAGI2CCFG1_DRYRUN();		
	}
}
function SVF_FLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@SVF_CFG0_DRYRUN();		
	}
}
function SVF_SPIFLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@SVF_SPICFG0_DRYRUN();		
	}
}
function SVF_I2CFLASHA_DRYRUN
{
	IF (ISFLASHA == 1)
	{
		! Dry Run the FlashA CFG;
		! Dry Run the CFG0;
		@SVF_I2CCFG0_DRYRUN();		
	}
}
function SVF_FLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@SVF_CFG1_DRYRUN();		
	}
}
function SVF_SPIFLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@SVF_SPICFG1_DRYRUN();		
	}
}
function SVF_I2CFLASHB_DRYRUN
{
	IF (ISFLASHB == 1)
	{
		! Dry Run the FlashB CFG;
		! Dry Run the CFG1;
		@SVF_I2CCFG1_DRYRUN();		
	}
}
function CFG0_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00010000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop 5000 {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	print (0,"CFG0 Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_CFG0_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00010000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 DELAY 5000;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	RUN_TEST IDLE  TCK 2 DELAY PWP;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY	Usercode_Length	TDI(#0^Usercode_Length)
								TDO(#0^Usercode_Length)
								MASK(#0^Usercode_Length);	
}
function SPICFG0_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000008BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
	loop 5000 {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	setpin ISPEN HIGH;
	
	SavedUsercode[1] = $SavedUsercode[1];	
	print (0,"CFG0 Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_SPICFG0_DRYRUN
{
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000008BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 5000;	
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
	setpin ISPEN LOW;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	setpin ISPEN HIGH;								
}
function I2CCFG0_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000008BE);
	RUN_TEST DELAY 2 ;
	loop 5000 {
		I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];						
	print (0,"CFG0 Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_I2CCFG0_DRYRUN
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000008BE);
	I2C_STOP;
	RUN_TEST DELAY 5000;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_STOP;
	RUN_TEST DELAY PWP;
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	I2C_STOP;							 
}
function JTAGI2CCFG0_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream DataByte[1][8];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR	16	TDI (0x107D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1010);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop 1000 {
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
    SDR	16	TDI (0x10C1);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	print (0,"CFG0 Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function PRIMARY_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00100000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop 1000 {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	print (0,"Primary Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_PRIMARY_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00100000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	RUN_TEST IDLE  TCK 2 DELAY 1000;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY	Usercode_Length	TDI(#0^Usercode_Length)
								TDO(#0^Usercode_Length)
								MASK(#0^Usercode_Length);	
}
function SPIPRIMARY_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000004BE);
	setpin ISPEN HIGH;
	loop 1000 {
		RUN_TEST DELAY 2;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	setpin ISPEN HIGH;
							
	print (0,"Primary Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_SPIPRIMARY_DRYRUN
{
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000004BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 2;	
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 1000;
	setpin ISPEN LOW;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	setpin ISPEN HIGH;								
}
function I2CPRIMARY_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000004BE);
	loop 1000 {
		I2C_STOP;	
		RUN_TEST DELAY 2;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];						
	print (0,"Primary Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_I2CPRIMARY_DRYRUN
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000004BE);
	I2C_STOP;
	RUN_TEST DELAY 2;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_STOP;
	RUN_TEST DELAY 1000;
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	I2C_STOP;							 
}
function JTAGI2CPRIMARY_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream DataByte[1][8];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR	16	TDI (0x107D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1020);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop 1000 {
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
    SDR	16	TDI (0x10C1);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	print (0,"Primary Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function GOLDEN_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00101000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop 5000 {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	print (0,"Golden Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_GOLDEN_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00101000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	RUN_TEST IDLE  TCK 2 DELAY 1000;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY	Usercode_Length	TDI(#0^Usercode_Length)
								TDO(#0^Usercode_Length)
								MASK(#0^Usercode_Length);	
}
function SPIGOLDEN_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000014BE);
	setpin ISPEN HIGH;
	loop 1000 {
		RUN_TEST DELAY 2;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	setpin ISPEN HIGH;
							
	print (0,"Golden Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_SPIGOLDEN_DRYRUN
{
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000014BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 2;	
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 1000;
	setpin ISPEN LOW;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	setpin ISPEN HIGH;								
}
function I2CGOLDEN_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000014BE);
	loop 1000 {
		I2C_STOP;	
		RUN_TEST DELAY 2;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];							
	print (0,"Golden Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function SVF_I2CGOLDEN_DRYRUN
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000014BE);
	I2C_STOP;
	RUN_TEST DELAY 2;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_STOP;
	RUN_TEST DELAY 1000;
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	I2C_STOP;							 
}
function JTAGI2CGOLDEN_DRYRUN
{
	datastream SavedUsercode[1][Usercode_Length];
	datastream DataByte[1][8];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR	16	TDI (0x107D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1028);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop 1000 {
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
    SDR	16	TDI (0x10C1);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	print (0,"Golden Usercode Dry Run:");						
	print (0,SavedUsercode); 
}
function CFG1_DRYRUN
{
	datastream SavedUsercode1[1][Usercode_Length];
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00011000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop 5000 {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode1[1]);
	print (0,"CFG1 Usercode Dry Run:");						
	print (0,SavedUsercode1); 
}
function SVF_CFG1_DRYRUN
{
	datastream CtrlReg[1][8];
	CtrlReg[1] = #00011000;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SIR Instruction_Length	TDI (LSC_DEVICE_CTRL);
	SDR 8 TDI(CtrlReg[1]);
	RUN_TEST IDLE TCK 2 DELAY 5000 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	RUN_TEST IDLE  TCK 2 DELAY PWP;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SIR Instruction_Length	TDI (USERCODE_DRYRUN);
	RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY	Usercode_Length	TDI(#0^Usercode_Length)
								TDO(#0^Usercode_Length)
								MASK(#0^Usercode_Length);	
}
function SPICFG1_DRYRUN
{
	datastream SavedUsercode1[1][Usercode_Length];
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000018BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;	
	loop 5000 {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode1);
	setpin ISPEN HIGH;	
	SavedUsercode1[1] = $SavedUsercode1[1];	
	print (0,"CFG1 Usercode Dry Run:");						
	print (0,SavedUsercode1); 
}
function SVF_SPICFG1_DRYRUN
{
	setpin ISPEN LOW;
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000018BE);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 5000;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
	setpin ISPEN LOW;
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	setpin ISPEN LOW;
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	setpin ISPEN HIGH;								
}
function I2CCFG1_DRYRUN
{
	datastream SavedUsercode1[1][Usercode_Length];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000018BE);
	RUN_TEST DELAY 2;
	loop 5000 {
		I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}
	I2C_STOP;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode1);
	I2C_STOP;	
	SavedUsercode1[1] = $SavedUsercode1[1];	
	print (0,"CFG1 Usercode Dry Run:");						
	print (0,SavedUsercode1); 
}
function SVF_I2CCFG1_DRYRUN
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR 32	TDI (0x000018BE);
	I2C_STOP;
	RUN_TEST DELAY 5000;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_STOP;
	RUN_TEST DELAY PWP;	
	I2C_START;
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
	I2C_STOP;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
	SDR 32	TDI(0x00000083);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY	32	TDI(#0^32)
					TDO(#0^32)
					MASK(#0^32);
	I2C_STOP;								
}
function JTAGI2CCFG1_DRYRUN
{
	datastream SavedUsercode1[1][Usercode_Length];
	datastream DataByte[1][8];
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_DEVICE_CTRL(0x7D) instruction;
	SDR	16	TDI (0x107D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1018);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	loop 1000 {
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR	16	TDI (0x10F0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x80);
	}	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in USERCODE_DRYRUN(0xC1) instruction;
    SDR	16	TDI (0x10C1);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode1[1] = ((SavedUsercode1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode1[1] = ((SavedUsercode1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode1[1] = ((SavedUsercode1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode1[1] = ((SavedUsercode1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	print (0,"CFG1 Usercode Dry Run:");						
	print (0,SavedUsercode1); 
}
function READ_MANUFACTURING_REGISTER
{
	datastream Manufacturing[1][128];
	file	NewFile = "FILE_SAVE"; 
			    
	//! Shift in LSC_MANUFACTURE_SHIFT(0x90) instruction;
    //SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    //RUN_TEST IDLE TCK 2 DELAY PWV;
    //SDR 128 TDI(0x00000000000000000000000000000000)
    //	    TDO(Manufacturing[1]);	     
   	//print (0,Manufacturing);
    //SIR Instruction_Length	TDI (LSC_MANUFACTURE_SHIFT);
    //RUN_TEST IDLE TCK 2 DELAY PWV;
    //SDR 128 TDI(0x00000000000000000000000000000000);
    
    Manufacturing[1] = 0x0000000000000000000000000000004D;
    fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT, Manufacturing);
	fclose 	NewFile;
}
function SVF_SAVE_USERCODE 
{
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
								TDO	(#1^Usercode_Length)
								MASK(#0^Usercode_Length);
}
function SPI_SVF_SAVE_USERCODE 
{
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR_VERIFY	32	TDI(#0^Usercode_Length)
			TDO(#1^Usercode_Length)
			MASK(#0^Usercode_Length);
	setpin ISPEN HIGH;
}
function I2C_SVF_SAVE_USERCODE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR_VERIFY	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(#1^Usercode_Length)
						MASK(#0^Usercode_Length);
	I2C_STOP;
}
function SVF_CFG0_ERASE 
{	
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0001);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPICFG0_ERASE 
{	
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00800070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CCFG0_ERASE 
{	
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00800070);
    I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SDR 32 TDI (0x0000000F);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_CFG1_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0002);
	RUN_TEST 	TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPICFG1_ERASE 
{	
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00400070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CCFG1_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00400070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_UFM0_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0004);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIUFM0_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00200070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CUFM0_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00200070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_UFM1_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0008);
	RUN_TEST  TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIUFM1_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00100070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CUFM1_ERASE 
{			
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00100070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_UFM2_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0010);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIUFM2_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00080070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CUFM2_ERASE 
{			
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00080070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_UFM3_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0020);
	RUN_TEST TCK Erase_pulse ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIUFM3_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00040070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CUFM3_ERASE 
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00040070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_CSEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0040);
	RUN_TEST TCK 2 DELAY PWV;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPICSEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00020070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CCSEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00020070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_USEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0080);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIUSEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00010070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CUSEC_ERASE
{		
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00010070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	I2C_STOP;
}
function SVF_CFG0_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0001);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			RUN_TEST IDLE DELAY PWP;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0);  
			RowCount = RowCount +1;		
		} 	
	}
}
function SVF_SPICFG0_PROGRAM {
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		setpin ISPEN HIGH;	
		repeat Temp_Row_Count
		{
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;  
			RowCount = RowCount +1;		
		} 	
		setpin ISPEN HIGH;
	}
}
function SVF_I2CCFG0_PROGRAM{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00800062);
		I2C_STOP;
		repeat Temp_Row_Count
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);	
			I2C_STOP;
			RowCount = RowCount +1;			
		} 	
		I2C_STOP;
	}
}
function SVF_CFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 16 TDI(0x0002);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			RUN_TEST TCK 2 DELAY PWP;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0); 
			RowCount = RowCount +1;		
		} 	
	}
}
function SVF_SPICFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		setpin ISPEN HIGH;		
		repeat Temp_Row_Count
		{
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;   
			RowCount = RowCount +1;		
		} 
		setpin ISPEN HIGH;
	}	
}
function SVF_I2CCFG1_PROGRAM
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG1.row = 1){
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00400062);
		I2C_STOP;
		repeat Temp_Row_Count
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000000E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);	
			I2C_STOP;
			RowCount = RowCount +1;			
		} 	
		I2C_STOP;		
	}
}
function SVF_UFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0004);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			RUN_TEST DELAY PWP;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0);	
			RowCount = RowCount +1;
		} 			   
	}
}
function SVF_SPIUFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x002000E2);
	    setpin ISPEN HIGH;			
		repeat Temp_UFM_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		} 
		setpin ISPEN HIGH;	   
	}
}
function SVF_I2CUFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x002000E2);
		I2C_STOP;		
	    repeat Temp_UFM_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			I2C_STOP;	
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function SVF_UFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0008);
		RUN_TEST	IDLE TCK 2 DELAY 	1;		
		repeat Temp_UFM_Count{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			RUN_TEST DELAY PWP;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			RowCount = RowCount +1;
		} 			   
	}
}
function SVF_SPIUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x001000E2);
	    setpin ISPEN HIGH;			
		repeat Temp_UFM_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		   
		setpin ISPEN HIGH;
	}
}
function SVF_I2CUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x001000E2);
		I2C_STOP;		
	    repeat Temp_UFM_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			I2C_STOP;	
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function SVF_UFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0010);
		RUN_TEST	IDLE TCK 2 DELAY 	1;		
		repeat Temp_UFM2_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			RUN_TEST DELAY PWP;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			RowCount = RowCount +1;
		} 			   
	}
}
function SVF_SPIUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000800E2);
	    setpin ISPEN HIGH;			
		repeat Temp_UFM2_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		} 
		setpin ISPEN HIGH;		   
	}
}
function SVF_I2CUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000800E2);
		I2C_STOP;		
	    repeat Temp_UFM2_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			I2C_STOP;	
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function SVF_UFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 16 TDI (0x0020);
		RUN_TEST	IDLE TCK 2 DELAY 	1;		
		repeat Temp_UFM3_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			RUN_TEST DELAY PWP;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			RowCount = RowCount +1;
		} 			   
	}
}
function SVF_SPIUFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000400E2);
	    setpin ISPEN HIGH;			
		repeat Temp_UFM3_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			setpin ISPEN HIGH;	
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 
		setpin ISPEN HIGH;	   
	}
}
function SVF_I2CUFM3_PROGRAM {
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000400E2);
		I2C_STOP;		
	    repeat Temp_UFM3_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000000E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			I2C_STOP;	
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SDR 32 TDI (0x0000000F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}	
function SVF_FEATURE_ERASE 
{
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0400);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIFEATURE_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;
}
function SVF_I2CFEATURE_ERASE{
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
    I2C_STOP;   
}
function SVF_AESKEY_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0200);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIAESKEY_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;		
}
function SVF_I2CAESKEY_ERASE{
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
    I2C_STOP;    
}
function SVF_PUBKEY_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 16 TDI(0x0100);
	RUN_TEST TCK 2 DELAY Erase_pulse;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
}
function SVF_SPIPUBKEY_ERASE {
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY Erase_pulse;
	setpin ISPEN LOW;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	setpin ISPEN HIGH;		
}
function SVF_I2CPUBKEY_ERASE{
	int32	Erase_pulse = 0;
	Erase_pulse = (PWE * 10);
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
	I2C_STOP;
	RUN_TEST DELAY Erase_pulse;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SDR 32 TDI (0x0000000F);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY 1 TDI(#0) TDO(#0);	
    I2C_STOP;   
}
function SVF_FEATURE_PROGRAM {
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 32;
		//print (0,FeatureArray);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 96 TDI(FeatureArray[1]);
		RUN_TEST DELAY PWP;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureArray[1]);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 32 TDI(FeatureBitsArray[1]);
		RUN_TEST DELAY PWP;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);
	    
	}
}
function SVF_SPIFEATURE_PROGRAM{
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 32;
		//print (0,FeatureArray);
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 96 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		setpin ISPEN LOW; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureArray[1]);
	    setpin ISPEN HIGH;	
	    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    setpin ISPEN LOW; 
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 32 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFFFFFF);
	    setpin ISPEN HIGH;			
	}
}	
function SVF_PROGRAM_PASSWORD
{
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		
		print (0,"Programming the Password Key...");
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
		! Shift in Data; 
		SDR 128 TDI(ProtectKey[1]);
		RUN_TEST TCK 2 DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		
		print (0,"Verify the Password Key...");
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (ProtectKey[1]);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Password Key.");
		}				
		IF (PWD_EN == 1)
		{
			//Bit[2] of OPRAND1 = PWD_EN
			print (0, "Programming the Password Key Enable...");
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    		! Shift in Data; 
			SDR 32 TDI(0x00000004);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Password Key Enable...");
			TRY 1 {
				// check bit PWD_EN (16) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010000);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Password Key Enable.");
			}
		}
		IF (PWD_UFM == 1)
		{
			//Bit[1] of OPRAND1 = PWD_UFM
			print (0, "Programming the Password UFM...");
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    		! Shift in Data; 
			SDR 32 TDI(0x00000002);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Password UFM...");
			TRY 1 {
				// check bit PWD_UFM (17) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00020000)
						  		MASK(0x00020000);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Password UFM.");
			}
		}
		IF (PWD_ALL == 1)
		{
			//Bit[3] of OPRAND1 = PWD_ALL
			print (0, "Programming the Password All...");
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    		! Shift in Data; 
			SDR 32 TDI(0x00000008);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Password All...");
			TRY 1 {
				// check bit PWD_ALL (15) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x00008000);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Password All.");
			}
		}			
	}	
}
function SVF_SPIPROGRAM_PASSWORD
{
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to program the Password Key.");
		}						  		  						
		IF (PWD_EN == 1)
		{
			//Bit[2] of OPRAND1 = PWD_EN
			print (0, "Programming the Password Key Enable...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SDR 32	TDI (0x0000001F);
    		! Shift in Data; 
			SDR 32 TDI(0x20000000);
			setpin ISPEN HIGH;
			RUN_TEST	DELAY PWP;
			print (0,"Verify the Password Key Enable...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit PWD_EN (16) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x00008000);
				setpin ISPEN HIGH;						  						  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;		
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
		    	setpin ISPEN HIGH;
				print (1,"Failed to Program the Password Key Enable.");
			}
		}
		IF (PWD_UFM == 1)
		{
			//Bit[1] of OPRAND1 = PWD_UFM
			print (0, "Programming the Password UFM...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SDR 32	TDI (0x0000001F);
    		! Shift in Data; 
			SDR 32 TDI(0x40000000);
			setpin ISPEN HIGH;
			RUN_TEST	DELAY PWP;
			print (0,"Verify the Password UFM...");
			TRY 1 {
				// check bit PWD_UFM (17) of the status register0
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00004000)
						  		MASK(0x00004000);
				setpin ISPEN HIGH;						  						  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;		
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
		    	setpin ISPEN HIGH;
				print (1,"Failed to Program the Password UFM.");
			}
		}
		IF (PWD_ALL == 1)
		{
			//Bit[3] of OPRAND1 = PWD_ALL
			print (0, "Programming the Password All...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    		SDR 32	TDI (0x0000001F);
			SDR 32 TDI(0x10000000);
			setpin ISPEN HIGH;
			RUN_TEST	DELAY PWP;
			print (0,"Verify the Password All...");
			TRY 1 {
				// check bit PWD_ALL (15) of the status register0
				setpin ISPEN LOW;
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010000);	
				setpin ISPEN HIGH;						  					  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;		
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
		    	SDR	32 	TDI (0x00000064);
		    	setpin ISPEN HIGH;
				print (1,"Failed to Program the Password All.");
			}
		}		
	}
}	
function SVF_PROGRAM_AESKEY
{
	datastream tmpSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");
		tmpSecurityKey[1] = SecurityKey[1] << 128;
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CIPHER_KEY0);
		! Shift in Data; 
		SDR 128 TDI(tmpSecurityKey[1]);
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		tmpSecurityKey[1] = SecurityKey[1];
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CIPHER_KEY1);
		! Shift in Data; 
		SDR 128 TDI(tmpSecurityKey[1]);
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			tmpSecurityKey[1] = SecurityKey[1] << 128;
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (tmpSecurityKey[1]);
								
			tmpSecurityKey[1] = SecurityKey[1];
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (tmpSecurityKey[1]);								
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x01);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				// check bit Dec Only (bit0) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SIR Instruction_Length TDI (LSC_READ_AES_FEA);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x01)
						  		MASK(0x01);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x02);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SIR Instruction_Length TDI (LSC_READ_AES_FEA);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x02)
						  		MASK(0x02);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x04);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SIR Instruction_Length TDI (LSC_READ_AES_FEA);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x04)
						  		MASK(0x04);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function SVF_SPIPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");			
		SaveSecurityKey[1] = SecurityKey[1] << 128;
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;	
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SDR 32	TDI (0x000000BF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			SaveSecurityKey[1] = SecurityKey[1] << 128;
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			setpin ISPEN LOW;
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SDR 32 TDI (0x0000002F);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			setpin ISPEN HIGH;
			SaveSecurityKey[1] = SecurityKey[1];
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			setpin ISPEN LOW;
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SDR 32 TDI (0x0000007F);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			setpin ISPEN HIGH;								
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000809F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit Dec Only (Bit0) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x80)
						  		MASK(0x80);	
				setpin ISPEN HIGH;						  					  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000409F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x40)
						  		MASK(0x40);		
				setpin ISPEN HIGH;		  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000209F);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x20)
						  		MASK(0x20);
				setpin ISPEN HIGH;						  						  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function SVF_I2CPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][128];
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");			
		SaveSecurityKey[1] = SecurityKey[1] << 128;
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CIPHER_KEY0(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		I2C_STOP;		
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CIPHER_KEY1(0xFD) instruction;
		SDR 32	TDI (0x000000BF);
		! Shift in Data; 
		SDR 128 TDI(SaveSecurityKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	 
		I2C_STOP;
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			SaveSecurityKey[1] = SecurityKey[1] << 128;
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_CIPHER_KEY0(0xF4) instruction;
			SDR 32 TDI (0x0000002F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			I2C_STOP;				
			SaveSecurityKey[1] = SecurityKey[1];
			SaveSecurityKey[1] = $SaveSecurityKey[1];
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_CIPHER_KEY1(0xFE) instruction;
			SDR 32 TDI (0x0000007F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);			
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (SaveSecurityKey[1]);
			I2C_STOP;							
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000809F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit Dec Only (bit0) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x80)
						  		MASK(0x80);	
				I2C_STOP;						  					  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000409F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_AES (bit1) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x40)
						  		MASK(0x40);		
				I2C_STOP;		  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF9) instruction;
			SDR 32	TDI (0x0000209F);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_NOISE (bit2) of the AES Register
				! Shift in LSC_READ_AES_FEA(0xFA) instruction;
				SDR 32 TDI (0x0000005F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  8 	TDI(#0^8)
						  		TDO(0x20)
						  		MASK(0x20);
				I2C_STOP;						  						  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}
}	
function SVF_PROGRAM_PUBKEY
{
	datastream TmpPublicKey[1][128];
	IF (PublicKey.row = 1)
	{		
		print (0,"Programming the Public Keys...");	
		TmpPublicKey[1] = PublicKey[1] << 384;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY0);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		TmpPublicKey[1] = PublicKey[1] << 256;
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY1);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		TmpPublicKey[1] = PublicKey[1] << 128;
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY2);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1]);
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		TmpPublicKey[1] = PublicKey[1];
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x63) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY3);
		! Shift in Data; 
		SDR 128 TDI(TmpPublicKey[1])
		RUN_TEST IDLE DELAY PWP;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		
		print (0,"Verify the Public Keys...");
		TRY 1 {
			TmpPublicKey[1] = PublicKey[1] << 384;
			! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);
			
			TmpPublicKey[1] = PublicKey[1] << 256;
			! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);
			
			TmpPublicKey[1] = PublicKey[1] << 128;
			! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY2);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);	
								
			TmpPublicKey[1] = PublicKey[1];
			! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY3);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (TmpPublicKey[1]);																									
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Public Keys.");
		}
		
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN2 AUTH_EN1 for ECDSA by default
		//Bit[1] of OPRAND1 = AUTH_EN2
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
		! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_AUTH_MODE);
		! Shift in Data; 
		SDR 8 TDI(0x03);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN2(9) and AUTH_EN1 (8) of the status register1
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00000300)
							MASK(0x00000300);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}
function SVF_SPIPROGRAM_PUBKEY{
	datastream SavePublicKey[1][128];
	IF (PublicKey.row = 1)
	{
		print (0,"Programming the Public Keys...");		
		SavePublicKey[1]= PublicKey[1] << 384;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1] << 256;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SDR 32	TDI (0x000000DA);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1] << 128;
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SDR 32	TDI (0x00000086);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		SavePublicKey[1]= PublicKey[1];
		SavePublicKey[1]= $SavePublicKey[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY3(0x63) instruction;
		SDR 32	TDI (0x000000C6);
		SDR 128 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		print (0,"Verify the Public Keys...");
		TRY 1 {
			SavePublicKey[1]= PublicKey[1] << 384;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
			SDR 32	TDI (0x0000005A);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;
			SavePublicKey[1]= PublicKey[1] << 256;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
			SDR 32	TDI (0x0000003A);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;	
			SavePublicKey[1]= PublicKey[1] << 128;
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
			SDR 32	TDI (0x00000046);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;		
			SavePublicKey[1]= PublicKey[1];
			SavePublicKey[1]= $SavePublicKey[1];
			setpin ISPEN LOW;
		    ! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
			SDR 32	TDI (0x00000026);
			SDR_VERIFY 128  TDI(#0^128)
							TDO(SavePublicKey[1]);
			setpin ISPEN HIGH;					
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN2 and AUTH_EN1 for ECDSA by default
		//Bit[1] of OPRAND1 = AUTH_EN2
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
		SDR 32	TDI (0x0000C023);
		setpin ISPEN HIGH;	
		print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN2 (9) and AUTH_EN1 (8) of the status register1
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00C00000)
							MASK(0x00C00000);
			setpin ISPEN HIGH;			  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}
function SVF_I2CPROGRAM_PUBKEY{
	datastream SavePublicKey[1][128];
	IF (PublicKey.row = 1)
	{
		print (0,"Programming the Public Keys...");		
		SavePublicKey[1]= PublicKey[1] << 384;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY0(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 128 TDI(SavePublicKey[1]);	
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
		I2C_STOP;		
		SavePublicKey[1]= PublicKey[1] << 256;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY1(0x5B) instruction;
		SDR 32	TDI (0x000000DA);
		SDR 128 TDI(SavePublicKey[1]);	
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
		I2C_STOP;
		SavePublicKey[1]= PublicKey[1] << 128;
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY2(0x61) instruction;
		SDR 32	TDI (0x00000086);
		SDR 128 TDI(SavePublicKey[1]);	
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
		I2C_STOP;
		SavePublicKey[1]= PublicKey[1];
		SavePublicKey[1]= $SavePublicKey[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY3(0x63) instruction;
		SDR 32	TDI (0x000000C6);
		SDR 128 TDI(SavePublicKey[1]);	
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);		
		I2C_STOP;
		print (0,"Verify the Public Keys...");
		TRY 1 {
				SavePublicKey[1]= PublicKey[1] << 384;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY0(0x5A) instruction;
				SDR 32	TDI (0x0000005A);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;				
				SavePublicKey[1]= PublicKey[1] << 256;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY1(0x5C) instruction;
				SDR 32	TDI (0x0000003A);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
				SavePublicKey[1]= PublicKey[1] << 128;
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY2(0x62) instruction;
				SDR 32	TDI (0x00000046);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
				SavePublicKey[1]= PublicKey[1];
				SavePublicKey[1]= $SavePublicKey[1];
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY3(0x64) instruction;
				SDR 32	TDI (0x00000026);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 128  TDI(#0^128)
								TDO(SavePublicKey[1]);
				I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN2 and AUTH_EN1 for ECDSA by default
		//Bit[1] of OPRAND1 = AUTH_EN2
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN2 and AUTH_EN1 Fuses...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_AUTH_MODE(0xC4) instruction;
		SDR 32	TDI (0x0000C023);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		print (0,"Verify the AUTH_EN2 and AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN2 (9) and AUTH_EN1 (8) of the status register1
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00C00000)
							MASK(0x00C00000);
			I2C_STOP;			  		  		    
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to Program the AUTH_EN2 and AUTH_EN1 Fuses.");
		}
	}	
}	
function SVF_PROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 96 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK PWP ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		TRY 1{
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SIR Instruction_Length	TDI (LSC_READ_FEATURE);
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000000000FF00000000);
		}
		ELSE{
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program TraceID.");
		}
	} 	
}
function SVF_SPIPROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1]	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 96 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		TRY 1 {
			setpin ISPEN LOW;
			setpin ISPEN LOW; 
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000FF00000000000000);					  						  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed to Program TraceID.");
		}
	    setpin ISPEN HIGH;	
	}
}
function SVF_I2CPROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1]	
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 96 TDI(FeatureArray[1]);
	    I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		I2C_STOP;	
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000FF00000000000000);
			I2C_STOP;							
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"Failed to Program TraceID.");
		}
	}
}
function SVF_PROGRAM_FEABITS {
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 32 TDI(FeatureBitsArray[1]);
	    RUN_TEST TCK 2 DELAY PWP ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);   
	}
}

function SVF_SPIPROGRAM_FEABITS {
	datastream FeatureBitsArray[1][32];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureBitsArray[1] = ArchArray_TDI[1];
		FeatureBitsArray[1] = $FeatureBitsArray[1];
	    //print (0,FeatureBitsArray);
		setpin ISPEN Low;
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);
	    SDR 32 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_READ_FEABITS (0xFB) instruction;
		SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 32   TDI(#0^32)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFFFFFF);   
	    setpin ISPEN HIGH;
	}
}	
function SVF_FLASHA_PROGRAM_DONE_BIT 
{
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST TCK 2 DELAY PWP;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	TRY 1 {
		// check bit Flash CFG0_DONE bit(12) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00001000)
						MASK(0x00001000);
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Done bit.");
	}
}
function SVF_FLASHB_PROGRAM_DONE_BIT 
{
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST TCK 2 DELAY PWP;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	SDR_VERIFY 1 TDI(#0) TDO(#0);
	TRY 1 {
		// check bit Flash CFG1_DONE bit(13) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00002000)
						MASK(0x00002000);
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Done bit.");
	}
}
function SVF_FLASHA_ERASE 
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@SELECT_CFG0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG0;
		@SVF_CFG0_ERASE();
		! Select UFM0 Sector;
		@SELECT_UFM0();	
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM0;	
		@SVF_UFM0_ERASE();
	}
}
function SVF_SPIFLASHA_ERASE 
{														
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@SPISELECT_CFG0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the CFG0;
		@SVF_SPICFG0_ERASE();
		! Select UFM0 Sector;	
		@SPISELECT_UFM0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SVF_SPIUFM0_ERASE();	
	}
}
function SVF_I2CFLASHA_ERASE 
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA;
		! Select CFG0 Sector;
		@I2CSELECT_CFG0();
		! Check Lock information;	
		@I2CCHECK_ERASE_LOCK();	
		! Erase the CFG0;
		@SVF_I2CCFG0_ERASE();	
		! Select UFM0 Sector;
		@I2CSELECT_UFM0();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SVF_I2CUFM0_ERASE();	
	}
}
function SVF_FLASHB_ERASE 
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@SELECT_CFG1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG1;
		@SVF_CFG1_ERASE();
		! Select UFM1 Sector;
		@SELECT_UFM1();	
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM1;	
		@SVF_UFM1_ERASE();
	}
}
function SVF_SPIFLASHB_ERASE 
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@SPISELECT_CFG1();
		! Check Lock information;	
		@SPICHECK_ERASE_LOCK();	
		! Erase the CFG1;
		@SVF_SPICFG1_ERASE();	
		! Select UFM1 Sector;
		@SPISELECT_UFM1();	
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SVF_SPIUFM1_ERASE();	
	}							
}
function SVF_I2CFLASHB_ERASE 
{																								
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB;
		! Select CFG1 Sector;
		@I2CSELECT_CFG1();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the CFG1;
		@SVF_I2CCFG1_ERASE();	
		! Select UFM1 Sector;
		@I2CSELECT_UFM1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SVF_I2CUFM1_ERASE();	
	}
}
function SVF_FLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@SELECT_UFM2();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM2;
		@SVF_UFM2_ERASE();
		! Select UFM3 Sector;
		@SELECT_UFM3();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM3;
		@SVF_UFM3_ERASE();
	}
}
function SVF_SPIFLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@SPISELECT_UFM2();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM2;
		@SVF_SPIUFM2_ERASE();	
		! Select UFM3 Sector;
		@SPISELECT_UFM3();	
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM3;
		@SVF_SPIUFM3_ERASE();	
	}
}
function SVF_I2CFLASHC_ERASE 
{
	IF (ISFLASHC == 1)
	{
		! Erase the FlashC;
		! Select UFM2 Sector;
		@I2CSELECT_UFM2();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM2;
		@SVF_I2CUFM2_ERASE();	
		! Select UFM3 Sector;
		@I2CSELECT_UFM3();	
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM3;
		@SVF_I2CUFM3_ERASE();	
	}
}
function SVF_FLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@SELECT_CFG0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG0;
		@SVF_CFG0_ERASE();		
	}
}
function SVF_SPIFLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@SPISELECT_CFG0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the CFG0;
		@SVF_SPICFG0_ERASE();		
	}
}
function SVF_I2CFLASHACFG_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA CFG;
		! Select CFG0 Sector;
		@I2CSELECT_CFG0();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the CFG0;
		@SVF_I2CCFG0_ERASE();		
	}
}
function SVF_FLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@SELECT_CFG1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the CFG1;
		@SVF_CFG1_ERASE();		
	}
}
function SVF_SPIFLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@SPISELECT_CFG1();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the CFG1;
		@SVF_SPICFG1_ERASE();		
	}
}
function SVF_I2CFLASHBCFG_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB CFG;
		! Select CFG1 Sector;
		@I2CSELECT_CFG1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the CFG1;
		@SVF_I2CCFG1_ERASE();		
	}
}
function SVF_FLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@SELECT_UFM0();
		! Check Lock information;
		@CHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SVF_UFM0_ERASE();	
	}
}
function SVF_SPIFLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@SPISELECT_UFM0();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SVF_SPIUFM0_ERASE();	
	}
}
function SVF_I2CFLASHAUFM_ERASE
{
	IF (ISFLASHA == 1)
	{
		! Erase the FlashA UFM;
		! Select UFM0 Sector;	
		@I2CSELECT_UFM0();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM0;
		@SVF_I2CUFM0_ERASE();	
	}
}
function SVF_FLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@SELECT_UFM1();
		! Check Lock information;
		@CHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SVF_UFM1_ERASE();	
	}
}
function SVF_SPIFLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@SPISELECT_UFM1();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SVF_SPIUFM1_ERASE();	
	}
}
function SVF_I2CFLASHBUFM_ERASE
{
	IF (ISFLASHB == 1)
	{
		! Erase the FlashB UFM;
		! Select UFM1 Sector;	
		@I2CSELECT_UFM1();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();	
		! Erase the UFM1;
		@SVF_I2CUFM1_ERASE();	
	}
}
function SVF_FLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@SELECT_UFM2();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM2;
		@SVF_UFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@SELECT_UFM3();
		! Check Lock information;
		@CHECK_ERASE_LOCK();
		! Erase the UFM3;
		@SVF_UFM3_ERASE();
	}
}
function SVF_SPIFLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@SPISELECT_UFM2();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the UFM2;
		@SVF_SPIUFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@SPISELECT_UFM3();
		! Check Lock information;
		@SPICHECK_ERASE_LOCK();
		! Erase the UFM3;
		@SVF_SPIUFM3_ERASE();
	}
}
function SVF_I2CFLASHCUFM_ERASE
{
	IF (ISFLASHC_UFM2 == 1)
	{
		! Erase the FlashC UFM2;
		! Select UFM2 Sector;
		@I2CSELECT_UFM2();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the UFM2;
		@SVF_I2CUFM2_ERASE();		
	}
	IF (ISFLASHC_UFM3 == 1)
	{
		! Erase the FlashC UFM3;
		! Select UFM3 Sector;
		@I2CSELECT_UFM3();
		! Check Lock information;
		@I2CCHECK_ERASE_LOCK();
		! Erase the UFM3;
		@SVF_I2CUFM3_ERASE();
	}
}
function SVF_FLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SVF_CFG0_ERASE();
		! Program CFG0;
		@SVF_CFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@SVF_UFM0_ERASE(); 
		! Program the UFM0;
		@SVF_UFM0_PROGRAM();  
		! Verify the UFM0;													
		@UFM0_VERIFY();     
		! Select CFG0;     
		@SELECT_CFG0();	
		! Program DONE bit;
		@SVF_FLASHA_PROGRAM_DONE_BIT();			
	}
}
function SVF_SPIFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG0;
		@SVF_SPICFG0_ERASE();
		! Program CFG0;
		@SVF_SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@SPISELECT_UFM0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SVF_SPIUFM0_ERASE(); 
		! Program the UFM0;
		@SVF_SPIUFM0_PROGRAM();  
		! Verify the UFM0;													
		@SPIUFM0_VERIFY();     
		! Select CFG0;     
		@SPISELECT_CFG0();	
		! Program DONE bit;
		@SPIFLASH_PROGRAM_DONE_BIT();			
	}
}
function SVF_I2CFLASHA_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SVF_I2CCFG0_ERASE();
		! Program CFG0;
		@SVF_I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Select UFM0;													
		@I2CSELECT_UFM0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@SVF_I2CUFM0_ERASE(); 
		! Program the UFM0;
		@SVF_I2CUFM0_PROGRAM();  
		! Verify the UFM0;													
		@I2CUFM0_VERIFY();     
		! Select CFG0;     
		@I2CSELECT_CFG0();	
		! Program DONE bit;
		@I2CFLASH_PROGRAM_DONE_BIT();			
	}
}
function SVF_FLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@SVF_CFG1_ERASE();	
		! Program CFG1;
		@SVF_CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM1;												
		@SVF_UFM1_ERASE(); 		
		! Program the UFM1;										
		@SVF_UFM1_PROGRAM();  
		! Verify the UFM1;
		@UFM1_VERIFY();       
		! Select CFG1;   	
		@SELECT_CFG1();	
		! Program DONE bit;
		@SVF_FLASHB_PROGRAM_DONE_BIT();	
	}
}
function SVF_SPIFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SVF_SPICFG1_ERASE();	
		! Program CFG1;
		@SVF_SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;												
		@SVF_SPIUFM1_ERASE(); 		
		! Program the UFM1;										
		@SVF_SPIUFM1_PROGRAM();  
		! Verify the UFM1;
		@SPIUFM1_VERIFY();       
		! Select CFG1;   	
		@SPISELECT_CFG1();	
		! Program DONE bit;
		@SPIFLASH_PROGRAM_DONE_BIT();	
	}
}
function SVF_I2CFLASHB_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@SVF_I2CCFG1_ERASE();	
		! Program CFG1;
		@SVF_I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Select UFM1;		
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;												
		@SVF_I2CUFM1_ERASE(); 		
		! Program the UFM1;										
		@SVF_I2CUFM1_PROGRAM();  
		! Verify the UFM1;
		@I2CUFM1_VERIFY();       
		! Select CFG1;   	
		@I2CSELECT_CFG1();	
		! Program DONE bit;
		@I2CFLASH_PROGRAM_DONE_BIT();	
	}
}
function SVF_FLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SELECT_CFG0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SVF_CFG0_ERASE();
		! Program CFG0;
		@SVF_CFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@CFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@CFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@CFG0_VERIFY_USERCODE();		
		! Program DONE bit;
		@SVF_FLASHA_PROGRAM_DONE_BIT();			
	}
}
function SVF_SPIFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@SPISELECT_CFG0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG0;
		@SVF_SPICFG0_ERASE();
		! Program CFG0;
		@SVF_SPICFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@SPICFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@SPICFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@SPICFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASH_PROGRAM_DONE_BIT();			
	}
}
function SVF_I2CFLASHA_CFG_PROGRAM
{
	IF (ISFLASHA == 1)
	{
		! Select CFG0;
		@I2CSELECT_CFG0();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG0;
		@SVF_I2CCFG0_ERASE();
		! Program CFG0;
		@SVF_I2CCFG0_PROGRAM();	 
		! Program CFG0 USERCODE;
		@I2CCFG0_PROGRAM_USERCODE();
		! Verify CFG0;	
		@I2CCFG0_VERIFY();	
		! Verify CFG0 USERCODE;	
		@I2CCFG0_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASH_PROGRAM_DONE_BIT();			
	}
}
function SVF_FLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@SELECT_CFG1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@SVF_CFG1_ERASE();	
		! Program CFG1;
		@SVF_CFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@CFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@CFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@CFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@SVF_FLASHB_PROGRAM_DONE_BIT();	
	}
}
function SVF_SPIFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@SPISELECT_CFG1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase the CFG1; 
		@SVF_SPICFG1_ERASE();	
		! Program CFG1;
		@SVF_SPICFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@SPICFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@SPICFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@SPICFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@SPIFLASH_PROGRAM_DONE_BIT();	
	}
}
function SVF_I2CFLASHB_CFG_PROGRAM
{
	IF (ISFLASHB == 1)
	{
		! Select CFG1;				
		@I2CSELECT_CFG1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase the CFG1; 
		@SVF_I2CCFG1_ERASE();	
		! Program CFG1;
		@SVF_I2CCFG1_PROGRAM();
		! Program CFG1 USERCODE;	 
		@I2CCFG1_PROGRAM_USERCODE();
		! Verify CFG1;	
		@I2CCFG1_VERIFY();	
		! Verify CFG1 USERCODE;
		@I2CCFG1_VERIFY_USERCODE();
		! Program DONE bit;
		@I2CFLASH_PROGRAM_DONE_BIT();	
	}
}

function SVF_UFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SELECT_UFM0();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM0;
		@SVF_UFM0_ERASE(); 
		! Program the UFM0;
		@SVF_UFM0_PROGRAM();  
		! Verify the UFM0;													
		@UFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SELECT_UFM1();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM1;
		@SVF_UFM1_ERASE(); 
		! Program the UFM1;
		@SVF_UFM1_PROGRAM();  
		! Verify the UFM1;													
		@UFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SELECT_UFM2();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM2;
		@SVF_UFM2_ERASE(); 
		! Program the UFM2;
		@SVF_UFM2_PROGRAM();  
		! Verify the UFM2;													
		@UFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SELECT_UFM3();	
		! Check Erase LOCK information;
		@CHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@CHECK_PROG_LOCK(); 
		! Erase UFM3;
		@SVF_UFM3_ERASE(); 
		! Program the UFM3;
		@SVF_UFM3_PROGRAM();  
		! Verify the UFM3;													
		@UFM3_VERIFY(); 
	}
}
function SVF_SPIUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@SPISELECT_UFM0();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM0;
		@SVF_SPIUFM0_ERASE(); 
		! Program the UFM0;
		@SVF_SPIUFM0_PROGRAM();  
		! Verify the UFM0;													
		@SPIUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@SPISELECT_UFM1();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM1;
		@SVF_SPIUFM1_ERASE(); 
		! Program the UFM1;
		@SVF_SPIUFM1_PROGRAM();  
		! Verify the UFM1;													
		@SPIUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@SPISELECT_UFM2();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM2;
		@SVF_SPIUFM2_ERASE(); 
		! Program the UFM2;
		@SVF_SPIUFM2_PROGRAM();  
		! Verify the UFM2;													
		@SPIUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@SPISELECT_UFM3();		
		! Check Erase LOCK information;
		@SPICHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@SPICHECK_PROG_LOCK();
		! Erase UFM3;
		@SVF_SPIUFM3_ERASE(); 
		! Program the UFM3;
		@SVF_SPIUFM3_PROGRAM();  
		! Verify the UFM3;													
		@SPIUFM3_VERIFY(); 
	}
}
function SVF_I2CUFM_PROGRAM_VERIFY
{
	IF (EFuseArray_TDI_UFM0.row = 1)
	{
		! Select UFM0;													
		@I2CSELECT_UFM0();
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM0;
		@SVF_I2CUFM0_ERASE(); 
		! Program the UFM0;
		@SVF_I2CUFM0_PROGRAM();  
		! Verify the UFM0;													
		@I2CUFM0_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM1.row = 1)
	{
		! Select UFM1;													
		@I2CSELECT_UFM1();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM1;
		@SVF_I2CUFM1_ERASE(); 
		! Program the UFM1;
		@SVF_I2CUFM1_PROGRAM();  
		! Verify the UFM1;													
		@I2CUFM1_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM2.row = 1)
	{
		! Select UFM2;													
		@I2CSELECT_UFM2();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM2;
		@SVF_I2CUFM2_ERASE(); 
		! Program the UFM2;
		@SVF_I2CUFM2_PROGRAM();  
		! Verify the UFM2;													
		@I2CUFM2_VERIFY(); 
	}
	IF (EFuseArray_TDI_UFM3.row = 1)
	{
		! Select UFM3;													
		@I2CSELECT_UFM3();	
		! Check Erase LOCK information;
		@I2CCHECK_ERASE_LOCK(); 
		! Check Program LOCK information;
		@I2CCHECK_PROG_LOCK(); 
		! Erase UFM3;
		@SVF_I2CUFM3_ERASE(); 
		! Program the UFM3;
		@SVF_I2CUFM3_PROGRAM();  
		! Verify the UFM3;													
		@I2CUFM3_VERIFY(); 
	}
}
function JTAGI2CFLASHA_VERIFY_DONE_BIT 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);			
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x10)
					MASK (0x10);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;   	      	
}
function JTAGI2CFLASHB_VERIFY_DONE_BIT 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);			
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x20)
					MASK (0x20);
	RUN_TEST IDLE TCK 1000 ;
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x00)
					MASK (0x00);	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;   	      	
}			
function JTAGI2CSAVE_TRACEID	
{
	set_return_code (-1);
	print (1,"Operation is not supported. Cannot continue.");
}	
]]>
</Script>
</SVF_Plus>
