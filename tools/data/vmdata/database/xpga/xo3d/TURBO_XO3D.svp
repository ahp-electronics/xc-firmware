<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE		SVF_Plus	SYSTEM	"SVF_Plus.dtd" >

<SVF_Plus version="1.0">
<Header>
	<Device name="DEVICE_NAME"/>
</Header>
<Setup> <!-- use default Header, Trailer and Frequency value -->
	<Interface protocol="JTAG_1149.1"/>
</Setup>
<Parameter>
	<!-- Length fields are in number if bits -->
	<Instruction_Length value="INSTRUCTION_REGISTER_LENGTH"/> 
	<Row_Width			value="DEVICE_ROW_WIDTH"/> 
	<Address_Length		value="ADDRESS_REGISTER_LENGTH"/> 
	<Address length="ADDRESS_LENGTH">
		INI_ADDRESS			
	</Address>
	<ID_Length 			value="DEVICE_ID_LENGTH"/>
	<Usercode_Length 	value="DEVICE_USERCODE_LENGTH"/>
	<BSCAN_Length value="BSCAN_REGISTER_LENGTH"/> 
	<Bscan length="BSCAN_LENGTH">
		BSCAN_DATA
	</Bscan>
	<BscanMask length="BSCAN_LENGTH">
		BSCAN_MASK
	</BscanMask>
	<TotalFuse value="TOTAL_FUSE_MAP"/>
	<PWP	value="PROGRAMING_PULSE_WIDTH"/>
	<PWV	value="VERIFY_PULSE_WIDTH"/>
	<PWE	value="ERASE_PULSE_WIDTH"/>
	<MDRDelay value="MDR_DELAY"/>
	<Instruction>
		EXTEST	 			= 0x15;
		EXTEST_PULSE        = 0x2D;
		EXTEST_TRAIN        = 0x2E;
		INTEST              = 0x2C;
		CLAMP               = 0x78;
		HIGHZ               = 0x18;
		LSC_PRELOAD         = 0x1C;             
		LSC_SAMPLE          = 0x1C;									
		BYPASS              = 0xFF;
		IDCODE_PUB          = 0xE0;
		LSC_UIDCODE_PUB     = 0x19;
		USERCODE            = 0xC0;
		LSC_READ_TEMP       = 0xE8;
		LSC_DEVICE_CTRL     = 0x7D;
		LSC_READ_STATUS0    = 0x3C;
		LSC_READ_STATUS1    = 0x3D;
		LSC_CHECK_BUSY      = 0xF0;
		LSC_REFRESH         = 0x79;
		LSC_I2CI_CRBR_WT    = 0x9C;
		LSC_I2CI_TXDR_WT    = 0x9D;
		LSC_I2CI_RXDR_RD    = 0x9E;
		LSC_I2CI_SR_RD      = 0x9F;
		LSC_IP_A            = 0x32;
		LSC_IP_B            = 0x38;
		LSC_IPTEST_A        = 0x33;
		LSC_IPTEST_B        = 0x39;
		LSC_PROG_SPI        = 0x3A;
		LSC_PROG_SPI1       = 0x3E;
		LSC_IDCODE_PRV      = 0x16;
		LSC_READ_PES        = 0x11;
		LSC_MANUFACTURE_SHIFT = 0x90;
		ISC_ENABLE          = 0xC6;
		LSC_ENABLE_X        = 0x74;
		ISC_DISABLE         = 0x26;
		ISC_PROGRAM         = 0x67;
		ISC_NOOP            = 0x30;
		ISC_PROGRAM_USERCODE = 0xC2;
		ISC_READ            = 0x80;
		ISC_ERASE           = 0x0E;
		ISC_DISCHARGE       = 0x14;
		ISC_PROGRAM_DONE    = 0x5E;
		ISC_ERASE_DONE      = 0x24;
		ISC_PROGRAM_SECURITY = 0xCE;
		LSC_PROGRAM_SECPLUS = 0xCF;
		ISC_DATA_SHIFT      = 0x05;
		ISC_ADDRESS_SHIFT   = 0x42;
		LSC_INIT_ADDRESS    = 0x46;
		LSC_WRITE_ADDRESS   = 0xB4;
		LSC_PROG_INCR       = 0x82;
		LSC_PROG_INCR_ENC   = 0xB6;
		LSC_PROG_INCR_CMP   = 0xB8;
		LSC_PROG_INCR_CNE   = 0xBA;
		LSC_READ_INCR       = 0x6A;
		LSC_PROG_CTRL0      = 0x22;
		LSC_READ_CTRL0      = 0x20;
		LSC_RESET_CRC       = 0x3B;
		LSC_READ_CRC        = 0x60;
		LSC_PROG_SED_CRC    = 0xA2;
		LSC_READ_SED_CRC    = 0xA4;
		LSC_SHIFT_PASSWORD  = 0xBC;
		LSC_PROG_PASSWORD   = 0xF1;
		LSC_READ_PASSWORD   = 0xF2;
		LSC_PROG_CIPHER_KEY = 0xF3;
		LSC_READ_CIPHER_KEY = 0xF4;
		LSC_PROG_FEATURE    = 0xE4;          
		LSC_READ_FEATURE    = 0xE7;      
		LSC_PROG_FEABITS    = 0xF8;
		LSC_READ_FEABITS    = 0xFB;
		LSC_WRITE_COMP_DIC  = 0x02;
		LSC_WRITE_BUS_ADDR  = 0xF6;
		LSC_PCS_WRITE       = 0x72;
		LSC_PCS_READ        = 0xF7;
		LSC_EBR_WRITE       = 0xB2;
		LSC_EBR_READ        = 0xB0;
		LSC_PROG_INCR_NV    = 0x70;
		LSC_READ_INCR_NV    = 0x73;
		LSC_INIT_ADDR_UFM   = 0x47;
		LSC_READ_TAG        = 0xCA;
		LSC_ERASE_UFM       = 0xCB;
		LSC_PROG_UFM        = 0xC9;
		LSC_READ_UFM        = 0xCA;
		LSC_STORE           = 0xD0;
		LSC_BITSTREAM_BURST = 0x7A;
		LSC_PROG_PES        = 0xD0;
		LSC_PROG_MES        = 0xD1;
		LSC_PROG_MAIN_RED   = 0xD3;
		LSC_PROG_MAIN_RCR   = 0xD4;
		LSC_PROG_MAIN_RMR   = 0xD5;
		LSC_PROG_NV_RED     = 0xD6;
		LSC_PROG_NV_RMR     = 0xD7;
		LSC_READ_MES        = 0xD8; 
		LSC_READ_TRIM       = 0xD1;
		LSC_READ_MAIN_RED   = 0xDA;
		LSC_READ_MAIN_RCR   = 0xDC;
		LSC_READ_MAIN_RMR   = 0xDC;
		LSC_READ_NV_RED     = 0xDD;
		LSC_READ_NV_RMR     = 0xDE;
		LSC_MFG_MTEST       = 0x96;
		LSC_MFG_MTRIM       = 0x69;
		LSC_MFG_MDATA       = 0x8F;
		LSC_ISCAN           = 0xDF;	
		LSC_PROG_CTRL1      = 0x23;
		LSC_READ_CTRL1		= 0x21;
		LSC_AUTH_CTRL		= 0x58;
		LSC_PROG_ECDSA_PUBKEY =0x59;
		LSC_READ_ECDSA_PUBKEY =0x5A;
		LSC_PROGR_USEC		= 0x57;
		LSC_PROG_AES_FEA    = 0xF5;
		LSC_PROG_CSEC       = 0x54;
		LSC_READ_CSEC       = 0X55;
		LSC_PROG_USEC       = 0x56;
		LSC_READ_USEC       = 0x57;
	</Instruction>
</Parameter>
<Data>
	<DataField	name="IDTDI">
		<FieldBlock	row_width="DEVICE_ID_LENGTH">
			ID_DATA
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAM">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			0x00000000000000000200000000000000000000000000000800000000000
			  000000000000000000000000000000000000000000000000000000000000000000
		</FieldBlock>
	</DataField>
	<DataField	name="BSCANPROGRAMMASK">
		<FieldBlock	row_width="BSCAN_REGISTER_LENGTH">
			0x00000000000000000200000000000000000000000000000800000000000
			  000000000000000000000000000000000000000000000000000000000000000000
		</FieldBlock>
	</DataField>
</Data>
<Operation_List  label="TurboOperation0">		
	"SRAM Fast Configuration" = "	INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password, 
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM [SEQUENTIAL]	! Program Fuse Map,
										VERIFY_USERCODE		! Verify USERCODE,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION, 
										SYNCFUNCTION, 
										SYNCFUNCTION,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password,   
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL] ! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	[SEQUENTIAL]! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM lock,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM Lock,
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK[SEQUENTIAL] ! Check the SRAM Lock,
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"INIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							SYNCFUNCTION, 
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							CHECK_PASSWORD ! Check the Password,  
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"INIT 	! Initialize";	
																																						  							  							  
</Operation_List>
<Operation_List label="TurboOperation1">	
	"SRAM Fast Configuration" = "	INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password, 
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM [SEQUENTIAL]	! Program Fuse Map,
										VERIFY_USERCODE		! Verify USERCODE,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION, 
										SYNCFUNCTION, 
										SYNCFUNCTION,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password,   
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL] ! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	[SEQUENTIAL]! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM lock,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM Lock,
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK[SEQUENTIAL] ! Check the SRAM Lock,
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"INIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							SYNCFUNCTION, 
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							CHECK_PASSWORD ! Check the Password,  
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"INIT 	! Initialize";	
</Operation_List>
<Operation_List label="TurboOperation2">
	"SRAM Fast Configuration" = "	INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password, 
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM [SEQUENTIAL]	! Program Fuse Map,
										VERIFY_USERCODE		! Verify USERCODE,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION, 
										SYNCFUNCTION, 
										SYNCFUNCTION,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password,   
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL] ! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	[SEQUENTIAL]! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM lock,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM Lock,
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK[SEQUENTIAL] ! Check the SRAM Lock,
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"INIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							SYNCFUNCTION, 
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							CHECK_PASSWORD ! Check the Password,  
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"INIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  														 															 			 							
</Operation_List>
<Operation_List label="TurboOperation3">	
	"SRAM Fast Configuration" = "	INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password, 
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										BURST_PROGRAM [SEQUENTIAL]	! Program Fuse Map,
										VERIFY_USERCODE		! Verify USERCODE,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION,
										SYNCFUNCTION, 
										SYNCFUNCTION, 
										SYNCFUNCTION,
										DISABLE ! Exit the programming mode,
										VERIFY_STATUS ! Verify Status Register"	;																												
					
	"SRAM Erase,Program,Verify" = "INIT 	! Initialize,   
										READ_ID	! Check the IDCODE,
										IO_STATE ! Program Bscan register,
										CHECK_PASSWORD [SEQUENTIAL]! Check the Password,   
										SRAM_ENABLE	! Enable SRAM programming mode, 
										CHECK_SRAM_ERASE_LOCK [SEQUENTIAL] ! Check the SRAM Lock,										
										SRAM_ERASE	! Erase the SRAM, 
										PROGRAM_CONTROL0	! Program Control0 Register,
										PROGRAM_CONTROL1	! Program Control1 Register,
										SRAM_PROGRAM	[SEQUENTIAL]! Program Fuse Map,
										SRAM_PROGRAM_USERCODE	! Program USERCODE,
										SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
										VERIFY_USERCODE		! Verify USERCODE, 
										PROGRAM_DONE_BIT	! Program DONE bit,
										DISABLE ! Exit the programming mode"	;	
										
	"SRAM Verify Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,  
								IO_STATE ! Program Bscan register,
								CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM lock,
								SRAM_ENABLE	! Enable SRAM programming mode, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								VERIFY_CONTROL0 ! Verify Control Register0,
								VERIFY_CONTROL1 ! Verify Control Register1,
								SRAM_VERIFY	[SEQUENTIAL]! Verify Fuse Map, 
								SRAM_VERIFY_USERCODE		! Verify USERCODE, 
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;
							
	"SRAM Erase Only"	=	"INIT 	! Initialize, 
								READ_ID	! Check the IDCODE,
								IO_STATE ! Program Bscan register,
								CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
								SRAM_ENABLE	! Enable SRAM programming mode, 
								CHECK_SRAM_ERASE_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								SRAM_ERASE	! Erase the SRAM, 
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
								SYNCFUNCTION,
			 			 		DISABLE ! Exit the programming mode"	;

	"SRAM Verify ID" = 	"INIT 	! Initialize, 
						 		READ_ID ! Check the IDCODE"; 

	"SRAM Display ID" = "INIT, READ_ID, SAVE_ID";

	"SRAM Program Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL0 ! Program Control Register 0,
								             DISABLE";	

	"SRAM Display Control Register0" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK [SEQUENTIAL]! Check the SRAM Lock,
											 SAVE_CONTROL0 !Read Control Register 0,
								             DISABLE";	

	"SRAM Program Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
								 			 CHECK_PASSWORD [SEQUENTIAL]! Check the Password,  
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_PROG_LOCK [SEQUENTIAL]! Check the SRAM Lock,
								 			 PROGRAM_CONTROL1 ! Program Control Register 1,
								             DISABLE";

	"SRAM Display Control Register1" = "INIT ! Initialize,
											 READ_ID	! Check the IDCODE,
											 SAVE_ID,
											 SRAM_ENABLE	! Enable SRAM programming mode, 
								             CHECK_SRAM_READ_LOCK[SEQUENTIAL] ! Check the SRAM Lock,
											 SAVE_CONTROL1 !Read Control Register 1,
								             DISABLE";	

	"SRAM Verify USERCODE"	=	"INIT 	! Initialize, 
									READ_ID	! Check the IDCODE,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SYNCFUNCTION,
									SRAM_ENABLE,
									SRAM_VERIFY_USERCODE		! Verify USERCODE,
									DISABLE"; 
								
	"SRAM Display USERCODE"	=	"INIT, 
										READ_ID, 
										SAVE_ID,
										SRAM_ENABLE,
										SAVE_USERCODE,
										DISABLE";								
								
	"SRAM Read and Save"	=	"INIT, 
									 READ_ID, 
									 SAVE_ID, 
									 IO_STATE ! Program Bscan register,
									 SRAM_ENABLE, 
									 CHECK_SRAM_READ_LOCK,  
									 SAVE_CONTROL0,
									 SAVE_CONTROL1,
									 SRAM_SAVE_ARRAY, 
									 SAVE_USERCODE, 
									 DISABLE";								
								
	"SRAM Read Status Register" = "INIT ! Initialize,
							 			 READ_ID	! Check the IDCODE,
							 			 SAVE_ID,
							 			 SAVE_STATUS";									
								
	"SRAM Refresh" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							SYNCFUNCTION, 
							REFRESH_FUNCTION ! Refresh";								
	
	"SRAM Secure" = " INIT !Initialize,
							READ_ID !Check the IDCODE,
							CHECK_PASSWORD ! Check the Password,  
							SRAM_ENABLE	! Enable SRAM programming mode, 								             
							CHECK_SRAM_PROG_LOCK ! Check the SRAM Lock,
							SRAM_SECURE ! Secure the SRAM,
							DISABLE";
														
	"SRAM Bypass"	=	"INIT 	! Initialize";																				 			 									 			 													 			 															  				 			 										  																 			 		
</Operation_List>
<Script>
<![CDATA[
int32   Temp_Row_Count = 0;
int32   Temp_UFM_Count = 0;
int32   Temp_UFM2_Count = 0;
int32	Temp_UFM3_Count = 0;
int32   MutexOn = 0;

function NOT_SUPPORTED
{
	print (1,"Operation is not supported. Cannot continue.");	
}
function INIT 
{
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR HDR_LENGTH TDI(HDR_PATTERN);
	HIR HIR_LENGTH TDI(HIR_PATTERN);
	TDR TDR_LENGTH TDI(TDR_PATTERN);
	TIR TIR_LENGTH TDI(TIR_PATTERN);
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12541;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1150;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SVFINIT 
{
	! Row_Width	  : DEVICE_ROW_WIDTH; 
	! Address_Length : ADDRESS_REGISTER_LENGTH; 
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	ENDIR IRPAUSE;
	FREQUENCY 1E6 HZ;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12541;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1150;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function SPIINIT 
{
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	ENDDR DRPAUSE;
	FREQUENCY 1E6 HZ;
	setpin ISPEN HIGH;
	setpin ISPEN LOW;
	setpin ISPEN HIGH;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12541;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1150;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}										
function I2CINIT 
{
	HDR 0;
	HIR 0;
	TDR 0;
	TIR 0;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12541;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1150;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
}
function JTAGI2CINIT 
{
	HDR 1 TDI(#0);
	HIR 8 TDI(#11111111);
	TDR 0;
	TIR 0;
	ENDDR IDLE;
	ENDIR IDLE;
	STATE IDLE;
	IF (Address_Length == 888)
    {
    	Temp_Row_Count = 12541;
    	Temp_UFM_Count = 3582;
		Temp_UFM2_Count = 1150;
		Temp_UFM3_Count = 191;
    }
    ELSEIF (Address_Length == 623)
    {
    	Temp_Row_Count = 5759;
    	Temp_UFM_Count = 767;
    }
    ELSE
    {
    	Temp_Row_Count = 0;
    }
    ! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 10;
	! I2C LSC_I2CI_CRBR_WT to set XO2 SCL frequency; 
	SIR 8 TDI (0x9C);
	! I2C Prescale Control Register Setting;
	SDR 16 TDI(0x0000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;
	SDR 16 TDI(0x8000);                  
	RUN_TEST	IDLE TCK 2 DELAY 1;	
}
function PRELOAD {
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
}

function INI_PRELOAD {				
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length);
}
function SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}

function INI_SAMPLE {				
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   STATE DRPAUSE;
   STATE IDLE;
}
function CAPTURE {	
	datastream SavedBScanTDO[1][BSCAN_Length];	
	file NewFile = "FILE_SAVE";		
   ! Shift in Sample(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(#1^BSCAN_Length)
   					TDO(SavedBScanTDO[1]);
   Bscan[1] = SavedBScanTDO[1];	
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1]);
   // Write To file 
   fopen NewFile att "w"
					 format "SVF_Plus";	
   fwrite NewFile (BSCAN_TDO, Bscan);
   fclose 	NewFile;
   
}
function DYNAMIC {	
   ENDDR DRPAUSE;
   ! Shift in Preload(0x1C) instruction;
   SIR Instruction_Length TDI(LSC_PRELOAD);
   SDR BSCAN_Length TDI(Bscan[1])
   					DMASK(BscanMask[1]);
   STATE IDLE;
}
function READ_ID 
{
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length 	TDI (IDCODE_PUB);
	SDR_VERIFY	ID_Length	TDI (#0^ID_Length)
					        TDO	(IDTDI[1])
					        MASK (DEVICE_ID_MASK);
}
function SPIREAD_ID 
{
	IDTDI[1] = $IDTDI[1];
	setpin ISPEN LOW;
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	32	TDI (0x00000007);
	SDR_VERIFY	32	TDI (0x00000000)
					TDO	(IDTDI[1])
					MASK (0xFFFFFFFF);
					
	setpin ISPEN HIGH;				        
}
function I2CREAD_ID 
{
	IDTDI[1] = $IDTDI[1];
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	32	TDI (0x00000007);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY	32	TDI (0x00000000)
						TDO	(IDTDI[1])
						MASK (0xFFFFFFF0);						
		I2C_STOP;
	}	
	ELSE
	{	
		I2C_STOP;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function JTAGI2CREAD_ID 
{
	datastream DataByte[1][8];
	datastream MaskByte[1][8];
	datastream DataIDMask[1][32];
	DataIDMask[1] = DEVICE_ID_MASK;
	TRY 1{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in IDCODE_PUB(0xE0) opcode;
		SDR	16	TDI (0x10E0);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (IDTDI[1]);
		MaskByte[1] = (DataIDMask[1]);
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 8);
		MaskByte[1] = (DataIDMask[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 16);
		MaskByte[1] = (DataIDMask[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);
		DataByte[1] = (IDTDI[1] << 24);
		MaskByte[1] = (DataIDMask[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (MaskByte[1]);								
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}	
	ELSE
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100;		
		print (1,"Failed to read the Device's IDCODE. Please check the I2C Slave Address.");
	}			        
}
function SAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE"; 
	! Shift in IDCODE_PUB(0xE0) instruction;
    SIR Instruction_Length	TDI	(IDCODE_PUB);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function SPISAVE_ID	{
	datastream SavedID[1][32];
	file	NewFile = "FILE_SAVE";
	setpin ISPEN LOW; 
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
	SDR	32	TDI (#0^ID_Length)
				    TDO	(SavedID);
	setpin ISPEN HIGH;
	SavedID[1] = $SavedID[1];					
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function I2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	file	NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in IDCODE_PUB(0xE0) opcode;
    SDR 32 	TDI (0x00000007);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	ID_Length	TDI (#0^ID_Length)
					TDO	(SavedID);
	I2C_STOP;				
	SavedID[1] = $SavedID[1];	
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}
function JTAGI2CSAVE_ID	{
	datastream SavedID[1][ID_Length];
	datastream DataByte[1][8];
	file	NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in IDCODE_PUB(0xE0) opcode;
	SDR	16	TDI (0x10E0);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedID[1] = ((SavedID[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5800);
	RUN_TEST IDLE TCK 1000 ;			
	// Write To File 
	fopen	NewFile att "w" format "SVF_Plus";
	fwrite	NewFile (ID, SavedID);
	fclose 	NewFile;
}									
function SRAM_ENABLE {
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SPISRAM_ENABLE {
	setpin ISPEN LOW;
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 32 TDI (0x0000009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 1000;
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}										
function I2CSRAM_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 32 TDI (0x0000009E);
    I2C_STOP;
    RUN_TEST DELAY 1000;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 32 TDI (0x00000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ENABLE(0xC6) instruction;
	SDR	16	TDI (0x10C6);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function SRAM_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1000;
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY Instruction_Length TDI (BYPASS)
    					   		  TDO (0x00)
    					   		  MASK(0xC4);
}
function SPISRAM_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWE;
}
function I2CSRAM_ERASE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
}
function JTAGI2CSRAM_ERASE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC ERASE(0x0E) instruction;
	SDR	16	TDI (0x100E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1001);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY PWE;
}
function CFG0_ERASE 
{	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x04);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPICFG0_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CCFG0_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function CFG1_ERASE 
{	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x24);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPICFG1_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002470);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CCFG1_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function UFM0_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x08);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM0_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001070);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM0_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001070);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function UFM1_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x28);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM1_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001470);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM1_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001470);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function UFM2_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x44);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM2_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002270);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM2_ERASE {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00002270);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}
function UFM3_ERASE 
{
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x48);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWV;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIUFM3_ERASE 
{
    setpin ISPEN LOW;		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001270);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWV;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;
	}
	setpin ISPEN HIGH;
}
function I2CUFM3_ERASE 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);		
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00001270);
    loop PWE {
    	I2C_STOP;
		RUN_TEST DELAY PWV;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
	I2C_STOP;
}									
function CHECK_SRAM_ERASE_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000010);
	}
	ELSE
	{		
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;		  
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_ERASE_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Write Lock is set. Cannot continue.");
	}		
}										
function I2CCHECK_SRAM_ERASE_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_ERASE_LOCK{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x10);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Erase Lock is set. Cannot continue.");
	}
}
function CHECK_SRAM_PROG_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_PROG_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"The SRAM Write Lock is set. Cannot continue.");
	}		
}
function I2CCHECK_SRAM_PROG_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_PROG_LOCK
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x20);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;							  				  	
	}
	ELSE{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 			
		print (1,"The SRAM Program Lock is set. Cannot continue.");
	}
}
function CHECK_SRAM_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function SPICHECK_SRAM_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function I2CCHECK_SRAM_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function JTAGI2CCHECK_SRAM_READ_LOCK
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1{
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x40);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	16	TDI (0x1026);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 200; 
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY 1000;     
		     
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 100; 	 				  
		print (1,"The SRAM Read Lock is set. Cannot continue.");
	}
}
function CHECK_PASSWORD 
{	
	IF (ProtectKey.row = 1)
	{			  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SIR Instruction_Length TDI (LSC_SHIFT_PASSWORD);
		SDR  128  TDI(ProtectKey[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00010000)
					  		MASK(0x00010200);										  
		}
		ELSE
		{				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_TRY_VERIFY  32 	TDI(#0^32)
							  	TDO(0x00000000)
							  	MASK(0x00030000);			  			  
		}
		ELSE
		{
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function SPICHECK_PASSWORD
{	
	datastream SaveProtectKey[1][64];
	IF (ProtectKey.row = 1)
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			setpin ISPEN HIGH;											  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			set_return_code (-93);				  
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x0000C000);
			setpin ISPEN HIGH;					  				  			  
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}	
function I2CCHECK_PASSWORD
{	
	datastream SaveProtectKey[1][64];
	IF (ProtectKey.row = 1)
	{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);		  
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR 32 TDI (0x0000003D);
		SaveProtectKey[1] = ProtectKey[1];
		SaveProtectKey[1] = $SaveProtectKey[1];
		SDR  128  TDI(SaveProtectKey[1]);
		I2C_STOP;
		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO(0x00008000)
					  		MASK(0x04008000);
			I2C_STOP;											  
		}
		ELSE
		{
			I2C_STOP;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_TRY_VERIFY  32 	TDI(#0^32)
					  			TDO(0x00000000)
					  			MASK(0x0000C000);
			I2C_STOP;					  				  			  
		}
		ELSE
		{	
			I2C_STOP;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}		
}
function JTAGI2CCHECK_PASSWORD{	
	datastream SaveProtectKey[1][64];
	datastream DataByte[1][8];
	IF (ProtectKey.row = 1)
	{	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_SHIFT_PASSWORD(0xBC) instruction;
		SDR	16	TDI (0x10BC);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Password Key; 	
    	DataByte[1] = ProtectKey[1];
    	SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;		
		DataByte[1] = (ProtectKey[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 32);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 40);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 48);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (ProtectKey[1] << 56);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 2 DELAY 1;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ;
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		TRY 1 {
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x01);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x02);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;				
					  														  
		}
		ELSE
		{
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			print (0,"The Password Key does not match the Password Key in the device.");
			print (1,"Please re-enter the Password Key.");
		}
	}
	ELSE
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);				
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR	16	TDI (0x103C);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ;
		TRY 1 {
			! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
			SIR	8	TDI  (0x9E);
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x03);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			RUN_TEST IDLE TCK 1000 ;
			SDR_VERIFY	8	TDI  (0x00)
							TDO  (0x00)
							MASK (0x00);
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;	 				  			  
		}
		ELSE
		{	
			! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
			SIR	8	TDI  (0x9D);
			SDR	16	TDI  (0x5800);
			RUN_TEST IDLE TCK 1000 ;
			print (1,"A Password Key is required. Please provide the Password Key.");
		}
	}
}						
function BURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SIR Instruction_Length	TDI (LSC_BITSTREAM_BURST);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
	RUN_TEST	IDLE TCK 100 DELAY PWP;
}
function SPIBURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWP;
}	
function I2CBURST_PROGRAM 
{
	FuseArray_TDI.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    I2C_STOP;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
    SDR 32	TDI (0x0000005E);
	! Shift in TOTAL_FUSE_MAP bits;
    SDR	TotalFuse		TDI	(FuseArray_TDI);
    I2C_STOP;
	RUN_TEST DELAY PWP;
}
function JTAGI2CBURST_PROGRAM {
	datastream DataByte[1][8];
	int32	ByteCount = 1;
	int32	i = 0;
	FuseArray_TDI.row = 1;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR	16	TDI (0x1046);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_BITSTREAM_BURST(0x7A) instruction;
	SDR	16	TDI (0x107A);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	ByteCount = TotalFuse/8;
	FuseArray_TDI[1] = $FuseArray_TDI[1];
	repeat ByteCount {
		DataByte[1] = (FuseArray_TDI[1] << i);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;	
		i = i + 8;
	}
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;
}
function PROGRAM_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		SavedControl0[1] = $SavedControl0[1];
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL0);
		SDR 32 TDI(SavedControl0[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
	}
}	
function SPIPROGRAM_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
	    SavedControl0[1] = Control_Register_0_TDI[1];
	    SDR 32 TDI(SavedControl0[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL0 
{
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
	    SDR 32 TDI (0x00000044);
		SDR 32 TDI(Control_Register_0_TDI[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CPROGRAM_CONTROL0 
{
	datastream DataByte[1][8];
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL0(0x22) instruction;
		SDR	16	TDI (0x1022);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl0[1] = Control_Register_0_TDI[1];
	    DataByte[1] = SavedControl0[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl0[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl0[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl0[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function VERIFY_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		SavedControl0[1] = $SavedControl0[1];
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL0);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl0[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIVERIFY_CONTROL0 
{
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl0[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL0 
{
	IF (Control_Register_0_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR 32 TDI (0x00000004);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_0_TDI[1]);
		I2C_STOP;					   
	}
}
function JTAGI2CVERIFY_CONTROL0 {
	datastream DataByte[1][8];
	datastream SavedControl0[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl0[1] = Control_Register_0_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL0(0x20) instruction;
	    SDR	16	TDI (0x1020);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl0[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl0[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl0[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
function SAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0);
				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function SPISAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl0[1]);
	setpin ISPEN HIGH;	  
	SavedControl0[1] = $SavedControl0[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL0 
{
	datastream SavedControl0[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_0(0x20) instruction;
	SDR 32 TDI (0x00000004);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl0);
	I2C_STOP;			
	print (0,SavedControl0);
	SavedControl0[1] = $SavedControl0[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL0 {
	datastream SavedControl0[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL0(0x20) instruction;
    SDR	16	TDI (0x1020);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl0[1] = ((SavedControl0[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 								   
	print (0,SavedControl0);
	SavedControl0[1] = $SavedControl0[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl0);
	fclose 	NewFile;
}
function PROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_CTRL1);
		SDR 32 TDI(SavedControl1[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIPROGRAM_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SavedControl1[1] = Control_Register_1_TDI[1];
	    SDR 32 TDI(SavedControl1[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP; 
		setpin ISPEN LOW;
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;					   
	}
}
function I2CPROGRAM_CONTROL1 
{
	IF (Control_Register_1_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
	    SDR 32 TDI (0x000000C4);
		SDR 32 TDI(Control_Register_1_TDI[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP; 
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_1_TDI[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CPROGRAM_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_PROG_CTRL1(0x23) instruction;
		SDR	16	TDI (0x1023);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SavedControl1[1] = Control_Register_1_TDI[1];
	    DataByte[1] = SavedControl0[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedControl1[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
		
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 				   
	}
}
function VERIFY_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		SavedControl1[1] = $SavedControl1[1];
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SIR Instruction_Length TDI (LSC_READ_CTRL1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(SavedControl1[1])
					   MASK(0xFFFFFFFF);
	}
}
function SPIVERIFY_CONTROL1 
{
	datastream SavedControl1[1][32];
	IF (Control_Register_0_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
	    setpin ISPEN LOW;
		! Shift in LSCC READ CONTROL 0(0x21) instruction;
	    SDR 32 TDI (0x00000084);
		SDR_VERIFY  32 TDI(0x00000000)
				   	   TDO(SavedControl1[1])
				       MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;				       
	}	
}
function I2CVERIFY_CONTROL1 
{
	IF (Control_Register_1_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR 32 TDI (0x00000084);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 TDI(0x00000000)
					   TDO(Control_Register_1_TDI[1])
					   MASK(0xFFFFFFFF);
		I2C_STOP;						   
	}
}
function JTAGI2CVERIFY_CONTROL1 {
	datastream DataByte[1][8];
	datastream SavedControl1[1][32];
	IF (Control_Register_1_TDI.row = 1)
	{
		SavedControl1[1] = Control_Register_1_TDI[1];
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in LSC_READ_CTRL1(0x21) instruction;
	    SDR	16	TDI (0x1021);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedControl1[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedControl1[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedControl1[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 								   
	}
}
function SAVE_CONTROL1
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SIR Instruction_Length TDI (LSC_READ_CTRL1);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1);
				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SPISAVE_CONTROL1 
{
	datastream SavedControl1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	SDR  32 TDI(0x00000000)
			TDO(SavedControl1);
	setpin ISPEN HIGH;	  
	SavedControl1[1] = $SavedControl1[1];
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROL1 
{
	datastream SavedControl1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC READ CONTROL_1(0x21) instruction;
	SDR 32 TDI (0x00000084);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedControl1);
	I2C_STOP;			
	print (0,SavedControl1);
	SavedControl1[1] = $SavedControl1[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_0_TDI, SavedControl1);
	fclose 	NewFile;
}
function JTAGI2CSAVE_CONTROL1 {
	datastream SavedControl1[1][32];
	datastream DataByte[1][8];
	file NewFile = "FILE_SAVE";
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_CTRL1(0x21) instruction;
    SDR	16	TDI (0x1021);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);	
	SavedControl1[1] = ((SavedControl1[1]) @ (DataByte[1])) << 8;									
    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 								   
	print (0,SavedControl1);
	SavedControl0[1] = $SavedControl0[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Control_Register_1_TDI, SavedControl1);
	fclose 	NewFile;
}
function SRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;	
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_PROG_INCR(0x82) instruction;
    SIR Instruction_Length	TDI	(LSC_PROG_INCR);
	repeat Address_Length {
		! Shift Out Data Row = RowCount;
	    SDR	Row_Width	TDI	(FuseArray_TDI);	    
	    RUN_TEST	IDLE TCK 2 DELAY 	PWP;						
		RowCount = RowCount +1;
	}				
}	
function SPISRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    setpin ISPEN HIGH;	
    
    RUN_TEST DELAY 1000;	
    
	repeat Address_Length{
		setpin ISPEN LOW;
		! Shift in LSC_PROG_INCR(0x82) instruction;
    	SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;	
		RowCount = RowCount +1;			
	} 
		
}
function I2CSRAM_PROGRAM 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00000062);
    I2C_STOP;
    
    RUN_TEST DELAY 1000;
    
    repeat Address_Length{
		I2C_START;	
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_INCR(0x82) instruction;
	    SDR 32	TDI (0x00008441); 
		! Shift in Data Row = RowCount; 			
		SDR	Row_Width	TDI	(FuseArray_TDI[RowCount]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;	
		RowCount = RowCount +1;			
	} 		
}
function JTAGI2CSRAM_PROGRAM {
	print (1,"Operation is not supported. Cannot continue.");	
}
function CFG0_PROGRAM 
{
	int32	RowCount = 1;
	IF (FuseArray_TDI_CFG0.row == 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 8 TDI(0x01);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	  
			RowCount = RowCount +1;		
		} 	
	}
}
function SPICFG0_PROGRAM {
	int32	RowCount = 1;
	IF(FuseArray_TDI_CFG0.row == 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00008062);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000840E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			setpin ISPEN HIGH;
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	   
			RowCount = RowCount +1;	
			setpin ISPEN HIGH;		
		} 	
	}
}
function I2CCFG0_PROGRAM{
	int32	RowCount = 1;
	IF(FuseArray_TDI_CFG0.row == 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00008062);
		I2C_STOP;
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000840E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG0[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			}
			I2C_STOP;
			RowCount = RowCount +1;			
		} 	
		I2C_STOP;
	}
}
function CFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF(FuseArray_TDI_CFG1.row == 1)
	{
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
		SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_Row_Count
		{
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);    								
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			RUN_TEST IDLE TCK 2 ;	
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
			SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST IDLE DELAY 1;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	  
			RowCount = RowCount +1;		
		} 	
	}
}
function SPICFG1_PROGRAM 
{
	int32	RowCount = 1;
	IF(FuseArray_TDI_CFG1.row == 1)
	{
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00004062);
		setpin ISPEN HIGH;		
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{
			setpin ISPEN LOW;
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000840E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			setpin ISPEN HIGH;
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	   
			RowCount = RowCount +1;	
			setpin ISPEN HIGH;		
		} 
	}	
}
function I2CCFG1_PROGRAM
{
	int32	RowCount = 1;
	IF(FuseArray_TDI_CFG1.row == 1){
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00004062);
		I2C_STOP;
		RUN_TEST DELAY 1000;
		repeat Temp_Row_Count
		{
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
			SDR 32	TDI (0x0000840E);    
			! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(FuseArray_TDI_CFG1[RowCount]);
			loop PWP {
				I2C_STOP;
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
				SDR 32 TDI (0x0000000F);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);	
			} 	
			I2C_STOP;
			RowCount = RowCount +1;			
		} 	
		I2C_STOP;
	}
}
function UFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row == 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 8 TDI (0x09);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function SPIUFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row == 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000090E2);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;
		repeat Temp_UFM_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 
			   
	}
}
function I2CUFM0_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row == 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000090E2);
		I2C_STOP;
		RUN_TEST DELAY 1000;
	    repeat Temp_UFM_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM0[RowCount]);
			loop PWP {
				I2C_STOP;	
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
		    	I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function UFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row == 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 8 TDI (0x0A);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM_Count{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function SPIUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row == 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000050E2);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;
		repeat Temp_UFM_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		   
	}
}
function I2CUFM1_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row == 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000050E2);
		I2C_STOP;
		RUN_TEST DELAY 1000;
	    repeat Temp_UFM_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM1[RowCount]);
			loop PWP {
				I2C_STOP;	
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
		    	I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function UFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row == 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 8 TDI (0x0B);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM2_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 
			   
	}
}
function SPIUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row == 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x0000D0E2);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;
		repeat Temp_UFM2_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 		   
	}
}
function I2CUFM2_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row == 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x0000D0E2);
		I2C_STOP;
		RUN_TEST DELAY 1000;
	    repeat Temp_UFM2_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM2[RowCount]);
			loop PWP {
				I2C_STOP;	
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
		    	I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function UFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row == 1)
	{		
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
		SDR 8 TDI (0x0C);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		repeat Temp_UFM3_Count
		{	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SIR Instruction_Length	TDI (LSC_PROG_INCR_NV);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			RUN_TEST IDLE TCK 2 ;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
			loop PWP {
				RUN_TEST DELAY PWV;
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}	
			RowCount = RowCount +1;
		} 			   
	}
}
function SPIUFM3_PROGRAM 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row == 1)
	{		
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000030E2);
	    setpin ISPEN HIGH;	
		RUN_TEST DELAY 1000;
		repeat Temp_UFM3_Count
		{
			setpin ISPEN LOW;	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			setpin ISPEN HIGH;	
			loop PWP {
				RUN_TEST DELAY PWV;
				setpin ISPEN LOW;
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
				setpin ISPEN HIGH;
			}	
			setpin ISPEN HIGH; 
			RowCount = RowCount +1;
		} 	   
	}
}
function I2CUFM3_PROGRAM {
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row == 1)
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    SDR 32	TDI (0x000030E2);
		I2C_STOP;
		RUN_TEST DELAY 1000;
	    repeat Temp_UFM3_Count
	    {		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	
			! Shift in LSC_PROG_INCR_NV(0x70) instruction;
	    	SDR 32	TDI (0x0000840E);
	    	! Shift in Data Row = RowCount; 			
			SDR	128	TDI	(EFuseArray_TDI_UFM3[RowCount]);
			loop PWP {
				I2C_STOP;	
				RUN_TEST DELAY PWV;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		    	SDR 32 TDI (0x0000000F);
		    	I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY 1 TDI(#0) TDO(#0);
			}
			I2C_STOP;
			RowCount = RowCount +1;
		} 
		I2C_STOP;	   
	}
}
function SRAM_PROGRAM_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}	
function SPISRAM_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
		setpin ISPEN LOW;
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
		SDR 32	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;
		RUN_TEST IDLE DELAY PWP;
	}
}
function I2CSRAM_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
		I2C_START;	
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
		SDR 32	TDI	(SavedUsercode[1]);
		I2C_STOP;
		RUN_TEST IDLE DELAY PWP;
	}
}
function JTAGI2CPROGRAM_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ;
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
		SDR	16	TDI (0x10C2);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ;
	    SavedUsercode[1] = Usercode_TDI[1];
	    DataByte[1] = SavedUsercode[1];
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 8);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 16);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		DataByte[1] = (SavedUsercode[1] << 24);
		SDR	16	TDI ((0x10) @ (DataByte[1])); 
		RUN_TEST IDLE TCK 1000 ;
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 2 DELAY 1; 	
	}
}
function SRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x00);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_READ_INCR(0x6A) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR);
		repeat Address_Length {
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function SPISRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		setpin ISPEN HIGH; 
		
		RUN_TEST DELAY 1000;
	
    	repeat Address_Length {
    		setpin ISPEN LOW;
			! Shift in LSC_READ_INCR(0x6A) instruction;
			SDR 32	TDI	(0x00008456);	
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			setpin ISPEN HIGH;	
			setpin ISPEN LOW;
			SDR 32 TDI(#0^32);
			setpin ISPEN HIGH;										
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function I2CSRAM_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI.row = 1;
	FuseArray_MASK.row = 1;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
		SDR 32	TDI (0x00000062);
		I2C_STOP;  
		
		RUN_TEST DELAY 1000;
	
    	repeat Address_Length {
    		I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			! Shift in LSC_READ_INCR(0x6A) instruction;
			SDR 32	TDI	(0x00008456);	
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift Out Data Row = RowCount;
		    SDR_VERIFY	Row_Width	TDI	(#0^Row_Width)
									TDO	(FuseArray_TDI)
									MASK(FuseArray_MASK);
			I2C_STOP;	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			SDR 32 TDI(#0^32);
			I2C_STOP;										
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1, "Failed in Function VERIFY /see log file for more details/ ");
	}				
}
function JTAGI2CSRAM_VERIFY {
	print (1,"Operation is not supported. Cannot continue.");	
}
function SRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";

	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR	Row_Width	TDI	(#1^Row_Width);
    ! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
	SDR 8 TDI(0x00);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
	! Shift in LSC_READ_INCR(0x6A) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR);
	repeat Address_Length{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift Out Data Row = RowCount;
		SDR	Row_Width	TDI	(#1^Row_Width)
						TDO	(SavedFuseMap);
		RowCount = RowCount +1;
	}
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function SPISRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	setpin ISPEN HIGH; 
	
	RUN_TEST DELAY 1000;
		  
    repeat Address_Length {
    	setpin ISPEN LOW;
		! Shift in LSC_READ_INCR(0x6A) instruction;
		SDR 32	TDI	(0x00008456);		
		SDR 	Row_Width	TDI	(#0^Row_Width)
						    TDO	(SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function I2CSRAM_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap[Address_Length][Row_Width];
	file NewFile = "FILE_SAVE";
	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00000062);
	I2C_STOP;    
	
	RUN_TEST DELAY 1000;
		
	repeat Address_Length{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_INCR(0x6A) instruction;
		SDR 32	TDI	(0x00008456);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		! Shift out Data Row = RowCount; 			
		SDR	Row_Width	TDI	(#0^Row_Width)
						TDO	(SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;
	}	
	I2C_STOP;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI, SavedFuseMap);
	fclose 	NewFile;
}
function JTAGI2CSRAM_SAVE_ARRAY {
	print (1,"Operation is not supported. Cannot continue.");	
}
function CFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x01);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
		repeat Temp_Row_Count{	
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift out Data Row = RowCount; 
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);	
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function CFG0_VERIFY /see log file for more details/ ");
	}					
}
function SPICFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00008062);
    	setpin ISPEN HIGH;  
		RUN_TEST DELAY 1000;		
    	repeat Temp_Row_Count{	
    		setpin ISPEN LOW;
    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000084CE);	    
	    	! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);
			setpin ISPEN HIGH;	
			setpin ISPEN LOW;
			SDR 32 TDI(#0^32);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG0_VERIFY /see log file for more details/ ");
	}	
}
function I2CCFG0_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG0.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00008062);
	I2C_STOP;   
    RUN_TEST DELAY 1000;
	TRY 1 {		     			
		repeat Temp_Row_Count {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000084CE);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG0[RowCount]);
			I2C_STOP;	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			SDR 32 TDI(#0^32);
			I2C_STOP;										
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG0_VERIFY /see log file for more details/ ");
	}				
}
function CFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    	SDR 8 TDI(0x02);
		RUN_TEST	IDLE TCK 2 DELAY 	1;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
		repeat Temp_Row_Count{	
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			! Shift out Data Row = RowCount; 
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;
		print (1, "Failed in Function CFG1_VERIFY /see log file for more details/ ");
	}					
}
function SPICFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    	SDR 32	TDI (0x00004062);
    	setpin ISPEN HIGH; 
		RUN_TEST DELAY 1000;	   
    	repeat Temp_Row_Count{	
    		setpin ISPEN LOW;
    		! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000084CE);	    
	    	! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			setpin ISPEN HIGH;	
			setpin ISPEN LOW;
			SDR 32 TDI(#0^32);
			setpin ISPEN HIGH;
			RowCount = RowCount +1;
		}
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x000064);
		setpin ISPEN HIGH;
		print (1, "Failed in Function SPICFG1_VERIFY /see log file for more details/ ");
	}	
}
function I2CCFG1_VERIFY 
{
	int32	RowCount = 1;
	FuseArray_TDI_CFG1.row = 1;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00004062);
	I2C_STOP;   
    RUN_TEST DELAY 1000;
	TRY 1 {		     			
		repeat Temp_Row_Count {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
	    	SDR 32	TDI	(0x000084CE);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			! Shift out Data Row = RowCount; 			
			SDR_VERIFY	128	TDI	(#0^128)
							TDO	(FuseArray_TDI_CFG1[RowCount]);
			I2C_STOP;	
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
			SDR 32 TDI(#0^32);
			I2C_STOP;										
			RowCount = RowCount +1;
		}		
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1, "Failed in Function I2CCFG1_VERIFY /see log file for more details/ ");
	}				
}
function UFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 8 TDI(0x09);
	    	RUN_TEST	IDLE  TCK 2 DELAY 1;      	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM_Count
			{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				RowCount = RowCount +1;
			}
			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM0_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SDR 32	TDI (0x000090E2);
	    	setpin ISPEN HIGH;		
			RUN_TEST DELAY 1000;
	    	repeat Temp_UFM_Count
	    	{	
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				SDR 32 TDI(#0^32);
				setpin ISPEN HIGH;
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM0_VERIFY /see log file for more details/ ");
		}
	}
					
}
function I2CUFM0_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM0.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000090E2);
			I2C_STOP;			    				
			RUN_TEST DELAY 1000;
			repeat Temp_UFM_Count
			{	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM0[RowCount]);
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				SDR 32 TDI(#0^32);
				I2C_STOP;										
				RowCount = RowCount +1;		
			}			
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM0_VERIFY /see log file for more details/ ");
		}
	}		
}
function UFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 8 TDI(0x0A);
	    	RUN_TEST	IDLE  TCK 2 DELAY 1;      	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM_Count{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM1_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SDR 32	TDI (0x000050E2);
	    	setpin ISPEN HIGH;		
			RUN_TEST DELAY 1000;
	    	repeat Temp_UFM_Count
	    	{	
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				SDR 32 TDI(#0^32);
				setpin ISPEN HIGH;
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM1_VERIFY /see log file for more details/ ");
		}
	}					
}
function I2CUFM1_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM1.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
			SDR 32	TDI (0x000050E2);
			I2C_STOP;			    				
			RUN_TEST DELAY 1000;
			repeat Temp_UFM_Count
			{	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM1[RowCount]);
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				SDR 32 TDI(#0^32);
				I2C_STOP;										
				RowCount = RowCount +1;		
			}			
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM1_VERIFY /see log file for more details/ ");
		}
	}		
}
function UFM2_VERIFY {
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 8 TDI(0x0B);
	    	RUN_TEST	IDLE  TCK 2 DELAY 1;      	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM2_Count
			{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM2_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM2_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SDR 32	TDI (0x0000D0E2);
	    	setpin ISPEN HIGH;		
			RUN_TEST DELAY 1000;
	    	repeat Temp_UFM2_Count
	    	{	
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				SDR 32 TDI(#0^32);
				setpin ISPEN HIGH;
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM2_VERIFY /see log file for more details/ ");
		}
	}					
}
function I2CUFM2_VERIFY 
{
	int32	RowCount = 1;    	
	IF (EFuseArray_TDI_UFM2.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_EBR(0x47) instruction;
			SDR 32	TDI (0x0000D0E2);
			I2C_STOP;			    	
			RUN_TEST DELAY 1000;
			repeat Temp_UFM2_Count
			{	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM2[RowCount]);
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				SDR 32 TDI(#0^32);
				I2C_STOP;										
				RowCount = RowCount +1;		
			}			
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM2_VERIFY /see log file for more details/ ");
		}
	}		
}
function UFM3_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SIR Instruction_Length	TDI (LSC_INIT_ADDR_UFM);
			SDR 8 TDI(0x0C);
	    	RUN_TEST	IDLE  TCK 2 DELAY 1;      	
			! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
			repeat Temp_UFM3_Count
			{	
				RUN_TEST	IDLE TCK 2 DELAY 	PWV;
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				RowCount = RowCount +1;
			}			
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY 1;
			print (1, "Failed in Function UFM3_VERIFY /see log file for more details/ ");
		}
	}					
}
function SPIUFM3_VERIFY 
{
	int32	RowCount = 1;
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_INIT_ADDR_UFM(0x47) instruction;
	    	SDR 32	TDI (0x000030E2);
	    	setpin ISPEN HIGH;		
			RUN_TEST DELAY 1000;
	    	repeat Temp_UFM3_Count
	    	{	
	    		setpin ISPEN LOW;      	
				! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);		    				
		    	! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				setpin ISPEN HIGH;	
				setpin ISPEN LOW;
				SDR 32 TDI(#0^32);
				setpin ISPEN HIGH;
				RowCount = RowCount +1;		
			}
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW; 
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1, "Failed in Function SPIUFM3_VERIFY /see log file for more details/ ");
		}
	}					
}
function I2CUFM3_VERIFY 
{
	int32	RowCount = 1;   	
	IF (EFuseArray_TDI_UFM3.row = 1)
	{		
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_INIT_ADDR_EBR(0x47) instruction;
			SDR 32	TDI (0x000030E2);
			I2C_STOP;			    				
			RUN_TEST DELAY 1000;
			repeat Temp_UFM3_Count
			{	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		    	! Shift in LSC_READ_INCR_NV(0x73) instruction;
		    	SDR 32	TDI	(0x000084CE);
			    I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);	
				! Shift out Data Row = RowCount; 
				SDR_VERIFY	128	TDI	(#0^128)
								TDO	(EFuseArray_TDI_UFM3[RowCount]);
				I2C_STOP;	
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
				SDR 32 TDI(#0^32);
				I2C_STOP;										
				RowCount = RowCount +1;		
			}			
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
			I2C_STOP;			
			print (1, "Failed in Function I2CUFM3_VERIFY /see log file for more details/ ");
		}
	}		
}
function SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SPISAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function I2CSAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function JTAGI2CSAVE_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in READ USERCODE(0xC0) instruction;
    SDR	16	TDI (0x10C0);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedUsercode[1] = ((SavedUsercode[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI, SavedUsercode);
	fclose 	NewFile;
}
function SAVE_STATUS 
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS0);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
			
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS1);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];
	print (0,SavedSTATUS);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SPISAVE_STATUS	
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
	setpin ISPEN HIGH;			
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	setpin ISPEN HIGH;		
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	print (0,SavedSTATUS);
	SavedSTATUS[1] = $SavedSTATUS[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function I2CSAVE_STATUS	
{
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS0);
	I2C_STOP;	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR 32 TDI (0x000000BC);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	32	TDI(#0^32)
			TDO(SavedSTATUS1);
	I2C_STOP;
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	print (0,SavedSTATUS);
	SavedSTATUS[1] = $SavedSTATUS[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function JTAGI2CSAVE_STATUS	{
	datastream DataByte[1][8];
	datastream SavedSTATUS[1][64];
	datastream SavedSTATUS0[1][32];
	datastream SavedSTATUS1[1][32];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS[1] = ((SavedSTATUS0[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ; 
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_READ_STATUS1(0x3D) instruction;
	SDR	16	TDI (0x103D);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ; 	
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ; 	
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ; 
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);
	SavedSTATUS[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;
	RUN_TEST IDLE TCK 1000 ;
	SDR	8	TDI  (0x00)
			TDO  (DataByte[1]);			
	SavedSTATUS[1] = ((SavedSTATUS1[1]) @ (DataByte[1])) << 8;				
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ; 
	SavedSTATUS[1] = SavedSTATUS0[1] @ SavedSTATUS1[1];	
	print (0,SavedSTATUS);
	SavedSTATUS[1] = $SavedSTATUS[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, SavedSTATUS);
	fclose 	NewFile;
}
function SRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}
}
function SPISRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}

}
function I2CSRAM_SECURE
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function JTAGI2CSRAM_SECURE{
	print (1,"Operation is not supported. Cannot continue.");	
}
function PROGRAM_DONE_BIT 
{
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST	IDLE TCK 2 DELAY PWP;				
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0xC4);
}
function SPISRAMPROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;
	RUN_TEST DELAY 200;
}

function I2CSRAMPROGRAM_DONE_BIT 
{	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR 32 TDI (0x0000007A);
	I2C_STOP
	RUN_TEST DELAY PWP; 										
}
function JTAGI2CSRAMPROGRAM_DONE_BIT 
{	
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
	SDR	16	TDI (0x105E);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 1;										
}	
function DISABLE 
{
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 100 DELAY 100;
}
function SPIDISABLE 
{
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
    setpin ISPEN LOW;
	! Shift in NO-OP(0xFF) instruction;
    SDR	32 	TDI (0xFFFFFFFF);
    setpin ISPEN HIGH;
}
function I2CDISABLE	
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;    	    	
}
function JTAGI2CDISABLE	
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in ISC DISABLE(0x26) instruction;
	SDR	16	TDI (0x1026);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200; 
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;     
	     
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100; 	        	    	
}																	
function REFRESH_FUNCTION 
{
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
    RUN_TEST IDLE TCK 2 DELAY 1000; 

	! Shift in BYPASS(0xFF) instruction;
    SIR Instruction_Length	TDI (BYPASS);
	RUN_TEST IDLE TCK 100 DELAY 5000;
}				
function SPIREFRESH_FUNCTION 
{
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
}
function I2CREFRESH_FUNCTION 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    RUN_TEST DELAY 200;	
}
function JTAGI2CREFRESH_FUNCTION 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 2 DELAY 200;		
}																								
function SRAM_TRANSPARENT_READ_ENABLE 
{
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function SPISRAM_TRANSPARENT_READ_ENABLE 
{
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_ENABLE 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_ENABLE 
{
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function SRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_REFRESH(0x79) instruction;
    SIR Instruction_Length	TDI (LSC_REFRESH);
	RUN_TEST	IDLE	TCK 2 ;

	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY PWP;
}
function SPISRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    setpin ISPEN HIGH;
	RUN_TEST DELAY PWV;
}
function I2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 32 TDI (0x0000002E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function JTAGI2CSRAM_TRANSPARENT_READ_REFRESH_ENABLE {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR	16	TDI (0x1079);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in LSC_ENABLE_X(0x74) instruction;
	SDR	16	TDI (0x1074);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x5000);
	RUN_TEST IDLE TCK 1000 ;
}
function VERIFY_STATUS {
	TRY 1 {
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS0);
	    SDR_VERIFY	32	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00002100);
	}
	ELSE
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x02000000)
						MASK(0x02000000);
			print (1, "The Authentication has failed/see log file for more details/ ");						
		}
		ELSE
		{
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function SPIVERIFY_STATUS {
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		setpin ISPEN HIGH;	
	}
	ELSE
	{
		TRY 1 {
			setpin ISPEN HIGH;
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x00000040)
						MASK(0x00000040);
			setpin ISPEN HIGH;
			print (1, "The Authentication has failed/see log file for more details/ ");						
		}
		ELSE
		{
			setpin ISPEN HIGH;
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function I2CVERIFY_STATUS {
	TRY 1 {
		I2C_START;		
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO (0x00800000)
				  	MASK(0x008C0000);
		I2C_STOP;		
	}
	ELSE
	{
		TRY 1 {
			I2C_STOP;
			I2C_START;		
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
	    	SDR_VERIFY	32	TDI(#0^32)
						TDO (0x00000040)
						MASK(0x00000040);
			I2C_STOP;
			print (1, "The Authentication has failed /see log file for more details/ ");						
		}
		ELSE
		{
			I2C_STOP;
			print (1, "Failed to Verify DONE bit /see log file for more details/ ");
		}
	}	
}
function JTAGI2CVERIFY_STATUS {
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);
	! Shift in Slave Address + WR;
	SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
	RUN_TEST IDLE TCK 1000 ;
	! Check ACK;
	! Shift in LSC_I2C_SR_RD(0x9F) instruction;
	SIR	8	TDI  (0x9F);
	SDR_VERIFY	8	TDI  (0x00)
					TDO  (0x04)
					MASK (0x24);
	! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
	SIR	8	TDI  (0x9D);				
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR	16	TDI (0x103C);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x1000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in Slave Address + RD;
	SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
	RUN_TEST IDLE TCK 1000 ;
	SDR	16	TDI  (0x2000);
	RUN_TEST IDLE TCK 1000 ;
	! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
	SIR	8	TDI  (0x9E);
	TRY 1 {
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x01)
						MASK (0x21);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x00)
						MASK (0x00);	
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5800);
		RUN_TEST IDLE TCK 1000 ;					
	}
	ELSE
	{
		print (1, "Failed to Verify DONE bit /see log file for more details/ ");
	}
}
function FLASH_ENABLE{
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x00);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
	
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x01);
	RUN_TEST 	TCK 2 DELAY 1000;
	
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x00)
									MASK(0xC0);	
									
	! Shift in ISC ENABLE(0xC6) instruction;
    SIR Instruction_Length TDI (ISC_ENABLE);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;

}
function SPIFLASH_ENABLE {
	! SRAM Erase;
	setpin ISPEN LOW;
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    setpin ISPEN HIGH;
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    setpin ISPEN HIGH;
    setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    setpin ISPEN HIGH;
	RUN_TEST IDLE DELAY PWE;
	setpin ISPEN LOW;
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    setpin ISPEN HIGH;	
    RUN_TEST DELAY PWV;
}
function I2CFLASH_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC REFRESH(0x79) instruction;
    SDR 24 TDI (0x00009E);
    I2C_STOP;
    RUN_TEST DELAY 1000;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x000063);
    I2C_STOP;
	RUN_TEST DELAY PWV;
    I2C_START;
    ! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00008070);
    I2C_STOP;
	RUN_TEST DELAY PWE;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ENABLE(0xC6) instruction;
    SDR 24 TDI (0x001063);
    I2C_STOP;	
    RUN_TEST DELAY PWV;
}
function SPIFLASH_TRANSPARENT_ENABLE {
	setpin ISPEN LOW;
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    setpin ISPEN HIGH;
    RUN_TEST DELAY PWV;
}
function FLASH_TRANSPARENT_ENABLE {
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SIR Instruction_Length TDI (LSC_ENABLE_X);
    SDR 8 TDI(0x08);
	RUN_TEST	IDLE	TCK 2 DELAY 1;
}
function I2CFLASH_TRANSPARENT_ENABLE {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_ENABLE_X(0x74) instruction;
    SDR 24 TDI (0x00102E);
    I2C_STOP;
    RUN_TEST DELAY PWV;
}
function SELECT_AESKEY{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x06);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_AESKEY{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00006062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_AESKEY{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00006062);
    I2C_STOP;	
}
function SELECT_FEA{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x04);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_FEA{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00002062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_FEA{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00002062);
    I2C_STOP;	
}
function SELECT_PUBKEY{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x05);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_PUBKEY{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x0000A062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_PUBKEY{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x0000A062);
    I2C_STOP;	
}
function SELECT_CFG0
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x01);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_CFG0
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00008062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_CFG0
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00008062);
    I2C_STOP;	
}
function SELECT_CFG1
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x02);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_CFG1
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00004062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_CFG1
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00004062);
    I2C_STOP;	
}
function SELECT_UFM0
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x09);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_UFM0
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00009062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_UFM0
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00009062);
    I2C_STOP;	
}
function SELECT_UFM1
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x0A);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_UFM1
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00005062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_UFM1
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00005062);
    I2C_STOP;	
}
function SELECT_UFM2{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x0B);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_UFM2{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x0000D062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_UFM2{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x0000D062);
    I2C_STOP;	
}
function SELECT_UFM3{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x0C);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_UFM3{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x00003062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_UFM3{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x00003062);
    I2C_STOP;	
}
function SELECT_CSEC
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x07);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_CSEC
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x0000E062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_CSEC
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x0000E062);
    I2C_STOP;	
}
function SELECT_USEC
{
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SIR Instruction_Length	TDI (LSC_INIT_ADDRESS);
    SDR 8 TDI(0x0D);
	RUN_TEST	IDLE TCK 2 DELAY 	1;
}
function SPISELECT_USEC
{
	setpin ISPEN LOW;
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
	SDR 32	TDI (0x0000B062);
	setpin ISPEN HIGH;  
}
function I2CSELECT_USEC
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_INIT_ADDRESS(0x46) instruction;
    SDR 32	TDI (0x0000B062);
    I2C_STOP;	
}
function FEATURE_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x02);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIFEATURE_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    setpin ISPEN HIGH;
	loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CFEATURE_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004070);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}	
    I2C_STOP;   
}
function AESKEY_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x42);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIAESKEY_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004270);
    setpin ISPEN HIGH;
	loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CAESKEY_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004270);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}	
    I2C_STOP;    
}
function PUBKEY_ERASE {
	! Shift in ISC ERASE(0x0E) instruction;
    SIR Instruction_Length TDI (ISC_ERASE);
    SDR 8 TDI(0x22);
	RUN_TEST 	TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWE {
		RUN_TEST IDLE  TCK 2 DELAY PWP;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}
}
function SPIPUBKEY_ERASE {
	setpin ISPEN LOW;
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004470);
    setpin ISPEN HIGH;
    loop PWE {
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
		SDR_VERIFY 1 TDI(#0) TDO(#0);
		setpin ISPEN HIGH;		
	}
	setpin ISPEN HIGH;
}
function I2CPUBKEY_ERASE{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC ERASE(0x0E) instruction;
    SDR 32 TDI (0x00004470);
    loop PWE {
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SDR 32 TDI (0x0000000F);
    	I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY 1 TDI(#0) TDO(#0);	
	}	
    I2C_STOP;   
}
function FEATURE_PROGRAM {
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 96 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureArray[1]);
	    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFF2);
	    
	}
}
function SPIFEATURE_PROGRAM{
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 96 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureArray[1]);
	    setpin ISPEN HIGH;	
	    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    setpin ISPEN LOW; 
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFF);
	    setpin ISPEN HIGH;			
	}
}
function I2CFEATURE_PROGRAM{
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{	    					
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    FeatureBitsArray[1] = $FeatureBitsArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (0x81);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0x0FFFF);
	    I2C_STOP;
	    FeatureArray[1] = ArchArray_TDI[1] << 16;
		//print (0,FeatureArray);
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (0x01);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    FeatureArray[1] = $FeatureArray[1];
	    SDR 96 TDI(FeatureArray[1]);
	    RUN_TEST DELAY 1000;
		I2C_STOP;	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_WRITE );
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SDR 32	TDI (0x000000E7);
	    I2C_RESTART;
	    ! Shift in Slave Address;
		SDR	8	TDI ( NEW_I2C_ADDR_READ );
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureArray[1]);
	    I2C_STOP;			
	}
}
function CHECK_ERASE_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000010);
	}
	ELSE
	{		
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;		  
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}
function SPICHECK_ERASE_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}		
}	
function I2CCHECK_ERASE_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x08000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"Current Sector Erase Lock is set. Cannot continue.");
	}
}	
function CHECK_PROG_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000020);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"Current Sector Program Lock is set. Cannot continue.");
	}
}
function SPICHECK_PROG_LOCK 
{	
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		setpin ISPEN HIGH;					  				  			  
	}
	ELSE
	{	
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Current Sector Prog Lock is set. Cannot continue.");
	}		
}
function I2CCHECK_PROG_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x04000000);
		I2C_STOP;				  	
	}
	ELSE{	
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;		
		print (1,"Current Sector Program Lock is set. Cannot continue.");
	}
}
function CHECK_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		! Shift in ISC DISABLE(0x26) instruction;
	    SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
	    SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY 1;			  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function SPICHECK_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;				  
		print (1,"Current Sector Lock is set. Cannot continue.");
	}
}
function I2CCHECK_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
		I2C_STOP;				  
		print (1,"Current Sector Read Lock is set. Cannot continue.");
	}
}
function WARNING_READ_LOCK
{
	TRY 1{
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000000)
				  	MASK(0x00000040);
	}
	ELSE
	{	
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 0.");
	}
}
function SPIWARNING_READ_LOCK
{
	TRY 1{
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		setpin ISPEN HIGH;
	}
	ELSE
	{
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 0.");
	}
}
function I2CWARNING_READ_LOCK
{
	TRY 1{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_TRY_VERIFY  32 	TDI(#0^32)
				  			TDO(0x00000000)
				  			MASK(0x02000000);
		I2C_STOP;
	}
	ELSE
	{
		print (0,"Warning: Current Sector Read Lock is set. The readback data will contain all 0.");
	}
}
function PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIPROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}

}
function I2CPROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function CSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPICSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}

}
function I2CCSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CSEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CSEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function USEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIUSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CUSEC_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (USEC_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (USEC_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function CFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPICFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}

}
function I2CCFG0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function CFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPICFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CCFG1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function UFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIUFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CUFM0_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function UFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIUFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CUFM1_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM1_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM1_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function UFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM2_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIUFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM2_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CUFM2_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM2_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM2_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function UFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM3_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SPIUFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM3_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		setpin ISPEN HIGH;
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		setpin ISPEN HIGH;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	setpin ISPEN HIGH;
    	RUN_TEST DELAY PWP;
    	setpin ISPEN LOW;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		setpin ISPEN HIGH;
	}
}
function I2CUFM3_PROGRAM_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (UFM3_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x02000000)
				  	MASK(0x02000000);
		I2C_STOP;	    
    }
    // Lock SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x04000000)
				  	MASK(0x04000000);
		I2C_STOP;
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (UFM3_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SDR 32	TDI (0x00000073);
    	SDR 8 TDI(LockBitsArray[1]);
    	I2C_STOP;
    	RUN_TEST DELAY PWP;
    	I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x06000000)
				  	MASK(0x06000000);
		I2C_STOP;
	}
}
function CFG0_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][8];
	// 0 RSVD RSVD RSVD SEC_HLOCK_L SEC_READ_L SEC_PROG_L SEC_ERASE_L
	// Lock SEC_READ_L
	IF (CFG0_ISSECURED == 1)
	{
		LockBitsArray[1] = #00000100;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000040)
				  	MASK(0x00000040);
	    
    }
    // Lock SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 2)
	{
		LockBitsArray[1] = #00000010;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000020)
				  	MASK(0x00000020);
	}
	// Lock SEC_READ_L SEC_PROG_L
	ELSEIF (CFG0_ISSECURED == 3)
	{
		LockBitsArray[1] = #00000110;
		! Shift in ISC_PROGRAM_SECURITY(0xCE) instruction;
    	SIR Instruction_Length	TDI (ISC_PROGRAM_SECURITY);
    	SDR 8 TDI(LockBitsArray[1]);
    	RUN_TEST IDLE TCK 2 DELAY PWP;
    	! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00000060)
				  	MASK(0x00000060);
	}	
}
function SAVE_CONTROLNV1{
	datastream SavedFeatureRowArray[1][96];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length TDI (LSC_READ_FEATURE);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR  96 TDI(#0^96)
			TDO(SavedFeatureRowArray[1]);
	SavedControlNV1[1] = SavedFeatureRowArray[1] >> 64;			  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function SPISAVE_CONTROLNV1{
	datastream SavedFeatureRowArray[1][96];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x0000007E);
	SDR  96 TDI(#0^96)
			TDO(SavedFeatureRowArray[1]);
	setpin ISPEN HIGH;		
	
	SavedControlNV1[1] = SavedFeatureRowArray[1] >> 64;				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function I2CSAVE_CONTROLNV1{
	datastream SavedFeatureRowArray[1][96];
	datastream SavedControlNV1[1][32];
	file	NewFile = "FILE_SAVE"; 
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x0000007E);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR  96 TDI(#0^96)
			TDO(SavedFeatureRowArray[1]);
	I2C_STOP;
	SavedControlNV1[1] = SavedFeatureRowArray[1] >> 64;				  
	// Write To File 
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (Control_Register_1_TDI, SavedControlNV1);
	fclose 	NewFile;
}
function PROGRAM_CONTROL_NV1{
	datastream FeatureRowArray[1][96];
	datastream FeatureRowArrayMask[1][96];
	IF (Control_Register_1_TDI.row = 1)
	{
		FeatureRowArray[1] = (Control_Register_1_TDI[1] @ (#0^64));
		FeatureRowArrayMask[1] = ((#1^32) @ (#0^64));
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length TDI (LSC_PROG_FEATURE);
		SDR 96 TDI(FeatureRowArray[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 96   TDI(#0^96)
	    				TDO(FeatureRowArray[1])
						MASK(FeatureRowArrayMask[1]);					
	}
}
function SPIPROGRAM_CONTROL_NV1{
	datastream FeatureRowArray[1][96];
	datastream FeatureRowArrayMask[1][96];
	IF (Control_Register_1_TDI.row = 1)
	{
		Control_Register_1_TDI[1] = $Control_Register_1_TDI[1];
		FeatureRowArray[1] = ((#0^64) @ Control_Register_1_TDI[1]);
		FeatureRowArrayMask[1] = ((#0^64) @ (#1^32) );
		setpin ISPEN LOW;
		! Shift in  LSC_PROG_FEATURE( 0xE4) instruction;
		SDR 32	TDI (0x00000027);
		SDR 96 TDI(FeatureRowArray[1]);		
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;	
		setpin ISPEN LOW; 
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
		SDR 32	TDI (0x0000007E);
		SDR_VERIFY 96   TDI(#0^96)
						TDO(FeatureRowArray[1])
						MASK(FeatureRowArrayMask[1]);
		setpin ISPEN HIGH;								
	}
}
function I2CPROGRAM_CONTROL_NV1{
	datastream FeatureRowArray[1][96];
	datastream FeatureRowArrayMask[1][96];
	IF (Control_Register_1_TDI.row = 1)
	{
		Control_Register_1_TDI[1] = $Control_Register_1_TDI[1];
		FeatureRowArray[1] = ((#0^64) @ Control_Register_1_TDI[1]);
		FeatureRowArrayMask[1] = ((#0^64) @ (#1^32) );
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
		SDR 32	TDI (0x00000027);
		SDR 96 TDI(FeatureRowArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;			
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_FEATURE (0xE7) instruction;
		SDR 32	TDI (0x0000007E);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  96 	TDI(#0^96)
						TDO (FeatureRowArray[1])
						MASK(FeatureRowArrayMask[1]);	
		I2C_STOP;								
	}
}
function PROGRAM_PASSWORD{
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		
		print (0,"Programming the Password Key...");
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_PASSWORD);
		! Shift in Data; 
		SDR 128 TDI(ProtectKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
		
		print (0,"Verify the Password Key...");
		TRY 1 {
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SIR Instruction_Length TDI (LSC_READ_PASSWORD);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  128 	TDI(#0^128)
								TDO (ProtectKey[1]);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Password Key.");
		}
		
		print (0, "Programming the Password Key Enable...");
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
    	! Shift in Data; 
		SDR 16 TDI(0x000C);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE  TCK 2 DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS0);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00010000)
					  	MASK(0x00013000);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Password Key Enable.");
		}		
	}	
}
function SPIPROGRAM_PASSWORD{
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00000000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}	
		
		print (0,"Programming the Password Key...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];
    	! Shift in Data; 
		SDR 128 TDI(SaveProtectKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			setpin ISPEN LOW; 
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(SaveProtectKey[1]);
			setpin ISPEN HIGH;						  	   					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to program the Password Key.");
		}						  		  		
		print (0, "Programming the Password Key Enable...");
		setpin ISPEN LOW; 
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0x3000);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO (0x00008000)
					  	MASK(0x000C8000);
			setpin ISPEN HIGH;					  					  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;		
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
	    	print (1,"Failed to program the Password Key Enable.");
		}
		
	}
}
function I2CPROGRAM_PASSWORD{
	datastream SaveProtectKey[1][128];
	IF (ProtectKey.row = 1)
	{
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  	TDO(0x00000000)
					  	MASK(0x000C8000);
			I2C_STOP;						  		  		    
		}
		ELSE {	
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	  
			print (1,"The Password Key already programmed. Please Erase the Feature Row first.");
		}
		print (0,"Programming the Password Key...");
		SaveProtectKey[1] = ProtectKey[1];
    	SaveProtectKey[1] = $SaveProtectKey[1];	
	    I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_PASSWORD(0xF1) instruction;
    	SDR 32	TDI (0x0000008F);
    	! Shift in Data; 
		SDR 128 TDI(ProtectKey[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key...");
		// Verify the Password Key;
		TRY 1 {
			I2C_START;
	    	! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_PASSWORD(0xF2) instruction;
			SDR 32 TDI (0x0000004F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  128 TDI(#0^128)
					  	   TDO(ProtectKey[1]);	
			I2C_STOP;					  	   				  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to program the Password Key.");
		}
		print (0, "Programming the Password Key Enable...");
		I2C_START;
	    ! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEABITS(0xF8) instruction;
    	SDR 32	TDI (0x0000001F);
    	! Shift in Data; 
		SDR 16 TDI(0x3000);
		I2C_STOP;
		RUN_TEST DELAY PWP;	
		print (0,"Verify the Password Key Enable...");
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS0(0x3C) instruction;
			SDR 32 TDI (0x0000003C);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
					  		TDO (0x00008000)
					  		MASK(0x000C8000);	
					  							  			
			I2C_STOP;					  					  		  		    
		}
		ELSE {		  
			I2C_STOP;		
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	24 	TDI (0x000064);
		    I2C_STOP;
		    RUN_TEST DELAY 200;	 
			print (1,"Failed to program the Password Key Enable and Keylock.");
		}
			
	}
}
function PROGRAM_AESKEY
{
	IF (SecurityKey.row = 1)
	{
		print (0,"Programming the Encryption Keys...");	
		! Shift in LSC_PROG_CIPHER_KEY(0xF3) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CIPHER_KEY);
		! Shift in Data; 
		SDR 256 TDI(SecurityKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			! Shift in LSC_READ_CIPHER_KEY(0xF4) instruction;
			SIR Instruction_Length TDI (LSC_READ_CIPHER_KEY);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  256 	TDI(#0^256)
								TDO (SecurityKey[1]);
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x01);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				// check bit Dec Only (15) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS0);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00008000)
						  		MASK(0x00008000);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x02);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				// check bit RAND_AES (10) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00000400)
						  		MASK(0x00000400);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SIR Instruction_Length	TDI (LSC_PROG_AES_FEA);
			! Shift in Data; 
			SDR 8 TDI(0x04);
			RUN_TEST	IDLE TCK 2 DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				// check bit RAND_NOISE (11) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SIR Instruction_Length TDI (LSC_READ_STATUS1);
				RUN_TEST IDLE TCK 2 DELAY PWV; 
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00000800)
						  		MASK(0x00000800);				  		  		    
			}
			ELSE {		  
				! Shift in ISC DISABLE(0x26) instruction;
			    SIR	Instruction_Length 	TDI (ISC_DISABLE);
				RUN_TEST	IDLE  TCK 2 DELAY PWP;         
				! Shift in BYPASS(0xFF) instruction;
			    SIR	Instruction_Length 	TDI (BYPASS);
				RUN_TEST	IDLE  TCK 2 DELAY PWV;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function SPIPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][256];
	IF (SecurityKey.row = 1)
	{
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		print (0,"Programming the Encryption Keys...");	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CIPHER_KEY(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 256 TDI(SaveSecurityKey[1]);
		setpin ISPEN HIGH;
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			setpin ISPEN LOW;
			! Shift in LSC_READ_CIPHER_KEY(0xF4) instruction;
			SDR 32 TDI (0x0000002F);			
			SDR_VERIFY  256 	TDI(#0^256)
								TDO (SaveSecurityKey[1]);
			setpin ISPEN HIGH;								
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000080AF);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit Dec Only (15) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010000);	
				setpin ISPEN HIGH;						  					  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000040AF);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_AES (10) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00400000)
						  		MASK(0x00400000);		
				setpin ISPEN HIGH;		  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			setpin ISPEN LOW;
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000020AF);
			setpin ISPEN HIGH;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				setpin ISPEN LOW;
				// check bit RAND_NOISE (11) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00200000)
						  		MASK(0x00200000);
				setpin ISPEN HIGH;						  						  		  		    
			}
			ELSE {		  
				setpin ISPEN HIGH;
				setpin ISPEN LOW;	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    setpin ISPEN HIGH;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}	
}
function I2CPROGRAM_AESKEY{
	datastream SaveSecurityKey[1][256];
	IF (SecurityKey.row = 1)
	{
		SaveSecurityKey[1] = SecurityKey[1];
		SaveSecurityKey[1] = $SaveSecurityKey[1];
		print (0,"Programming the Encryption Keys...");	
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CIPHER_KEY(0xF3) instruction;
		SDR 32	TDI (0x000000CF);
		! Shift in Data; 
		SDR 256 TDI(SaveSecurityKey[1]);
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;
		
		print (0,"Verify the Encryption Keys...");
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_CIPHER_KEY(0xF4) instruction;
			SDR 32 TDI (0x0000002F);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);			
			SDR_VERIFY  256 	TDI(#0^256)
								TDO (SaveSecurityKey[1]);
			I2C_STOP;								
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Encryption Keys.");
		}
		IF (DEC_ONLY == 1)
		{
			//Bit[0] of OPRAND1 = DEC_ONLY
			print (0,"Programming the Encrypted Bitstream Only Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000080AF);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Encrypted Bitstream Only fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit Dec Only (15) of the status register0
				! Shift in LSC_READ_STATUS0(0x3C) instruction;
				SDR 32 TDI (0x0000003C);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00010000)
						  		MASK(0x00010000);	
				I2C_STOP;						  					  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Encrypted Bitstream Only Fuses.");
			}
		}
		IF (RAND_AES == 1)
		{
			//Bit[1] of OPRAND1 = RAND_AES
			print (0,"Programming the Random AES Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000040AF);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random AES fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_AES (10) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00400000)
						  		MASK(0x00400000);		
				I2C_STOP;		  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random AES Fuses.");
			}
		}
		IF (RAND_NOISE == 1)
		{
			//Bit[2] of OPRAND1 = RAND_NOISE
			print (0,"Programming the Random Noise Fuses...");
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_PROG_AES_FEA(0xF5) instruction;
			SDR 32	TDI (0x000020AF);
			I2C_STOP;
			RUN_TEST DELAY PWP;
			print (0,"Verify the Random Noise fuses...");
			TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				// check bit RAND_NOISE (11) of the status register1
				! Shift in LSC_READ_STATUS1(0x3D) instruction;
				SDR 32 TDI (0x000000BC);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);
				SDR_VERIFY  32 	TDI(#0^32)
						  		TDO(0x00200000)
						  		MASK(0x00200000);
				I2C_STOP;						  						  		  		    
			}
			ELSE {		  
				I2C_STOP;
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
				! Shift in ISC DISABLE(0x26) instruction;
			    SDR	32 	TDI (0x00000064);
			    I2C_STOP;
				print (1,"Failed to Program the Random Noise Fuses.");
			}
		}
	}
}
function PROGRAM_PUBKEY
{
	IF (PublicKey.row = 1)
	{
		print (0,"Programming the Public Keys...");	
		! Shift in LSC_PROG_ECDSA_PUBKEY(0x59) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_ECDSA_PUBKEY);
		! Shift in Data; 
		SDR 512 TDI(PublicKey[1]);
		RUN_TEST	IDLE TCK 2 ;
		! Shift in LSC_CHECK_BUSY(0xF0) instruction;
		SIR Instruction_Length	TDI ( LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY PWV;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}
		print (0,"Verify the Public Keys...");
		TRY 1 {
			! Shift in LSC_READ_ECDSA_PUBKEY(0x5A) instruction;
			SIR Instruction_Length TDI (LSC_READ_ECDSA_PUBKEY);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  512 	TDI(#0^512)
								TDO (PublicKey[1])
		}
		ELSE
		{
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN1 for ECDSA by default
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN1 Fuses...");
		! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_AUTH_MODE);
		! Shift in Data; 
		SDR 8 TDI(0x01);
		RUN_TEST	IDLE TCK 2 DELAY PWP;
		print (0,"Verify the AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN1 (8) of the status register1
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SIR Instruction_Length TDI (LSC_READ_STATUS1);
			RUN_TEST IDLE TCK 2 DELAY PWV; 
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00000100)
							MASK(0x00000100);				  		  		    
		}
		ELSE {		  
			! Shift in ISC DISABLE(0x26) instruction;
		    SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
		    SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program the AUTH_EN1 Fuses.");
		}
	}	
}
function SPIPROGRAM_PUBKEY{
	datastream SavePublicKey[1][512]
	IF (PublicKey.row = 1)
	{
		SavePublicKey[1]=PublicKey[1];
		SavePublicKey[1]=$SavePublicKey[1];
		print (0,"Programming the Public Keys...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_ECDSA_PUBKEY(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 512 TDI(SavePublicKey[1]);	
		setpin ISPEN HIGH;		
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}
		setpin ISPEN HIGH;
		print (0,"Verify the Public Keys...");
		TRY 1 {
				setpin ISPEN LOW;
			    ! Shift in LSC_READ_ECDSA_PUBKEY(0x5A) instruction;
				SDR 32	TDI (0x0000005A);
				SDR_VERIFY 512  TDI(#0^512)
								TDO(SavePublicKey[1]);
				setpin ISPEN HIGH;								
		}
		ELSE
		{
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN1 for ECDSA by default
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN1 Fuses...");
		setpin ISPEN LOW;
		! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
		SDR 32	TDI (0x000080B3);
		setpin ISPEN HIGH;	
		print (0,"Verify the AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN1 (8) of the status register1
			setpin ISPEN LOW;
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00800000)
							MASK(0x00800000);
			setpin ISPEN HIGH;			  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    setpin ISPEN HIGH;
			print (1,"Failed to Program the AUTH_EN1 Fuses.");
		}
	}	
}
function I2CPROGRAM_PUBKEY{
	datastream SavePublicKey[1][512]
	IF (PublicKey.row = 1)
	{
		SavePublicKey[1]=PublicKey[1];
		SavePublicKey[1]=$SavePublicKey[1];
		print (0,"Programming the Public Keys...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_ECDSA_PUBKEY(0x59) instruction;
		SDR 32	TDI (0x0000009A);
		SDR 512 TDI(SavePublicKey[1]);	
		loop PWP {
			I2C_STOP;
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
	    	I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);			
		}	 
		I2C_STOP;

		print (0,"Verify the Public Keys...");
		TRY 1 {
				I2C_START;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_WRITE);
				! Shift in LSC_READ_ECDSA_PUBKEY(0x5A) instruction;
				SDR 32	TDI (0x0000005A);
				I2C_RESTART;
				! Shift in Slave Address;
				SDR	8	TDI (SLAVE_ADDRESS_READ);		
				SDR_VERIFY 512  TDI(#0^512)
								TDO(SavePublicKey[1]);
				I2C_STOP;
		}
		ELSE
		{
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to program the Public Keys.");
		}
		// HMAC Authentication will not supported for Sentry
		// Always program the AUTH_EN1 for ECDSA by default
		//Bit[0] of OPRAND1 = AUTH_EN1
		print (0,"Programming the AUTH_EN1 Fuses...");
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
		SDR 32	TDI (0x000080B3);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		print (0,"Verify the AUTH_EN1 fuses...");
		TRY 1 {
			// check bit AUTH_EN1 (8) of the status register1
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_STATUS1(0x3D) instruction;
			SDR 32 TDI (0x000000BC);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY  32 	TDI(#0^32)
							TDO(0x00800000)
							MASK(0x00800000);
			I2C_STOP;			  		  		    
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
		    SDR	32 	TDI (0x00000064);
		    I2C_STOP;
			print (1,"Failed to Program the AUTH_EN1 Fuses.");
		}
	}	
}
function PROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEATURE);
	    SDR 96 TDI(FeatureArray[1]);
	    RUN_TEST IDLE TCK PWP ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	
		TRY 1{
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SIR Instruction_Length	TDI (LSC_READ_FEATURE);
			RUN_TEST	IDLE TCK 2 DELAY 	PWV;
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000000000FF00000000);
		}
		ELSE{
			! Shift in ISC DISABLE(0x26) instruction;
			SIR	Instruction_Length 	TDI (ISC_DISABLE);
			RUN_TEST	IDLE  TCK 2 DELAY PWP;         
			! Shift in BYPASS(0xFF) instruction;
			SIR	Instruction_Length 	TDI (BYPASS);
			RUN_TEST	IDLE  TCK 2 DELAY PWV;
			print (1,"Failed to Program TraceID.");
		}
	} 	
}
function SPIPROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1]	
		setpin ISPEN LOW;
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 96 TDI(FeatureArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;	
		TRY 1 {
			setpin ISPEN LOW;
			setpin ISPEN LOW; 
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000FF00000000000000);					  						  		  		    
		}
		ELSE {		  
			setpin ISPEN HIGH;
			setpin ISPEN LOW;	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			setpin ISPEN HIGH;
			print (1,"Failed to Program TraceID.");
		}
	    setpin ISPEN HIGH;	
	}
}
function I2CPROGRAM_TRACEID{
	datastream FeatureArray[1][96];
	IF (UID.row = 1)
	{
		FeatureArray[1] = (#0^56) @ UID[1] @ (#0^32);
		FeatureArray[1]	= $FeatureArray[1]	
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_FEATURE( 0xE4) instruction;
	    SDR 32	TDI (0x00000027);
	    SDR 96 TDI(FeatureArray[1]);
	    I2C_STOP;
		loop PWP {
			RUN_TEST DELAY PWV;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
		    I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			I2C_STOP;
		}	 	
		TRY 1 {
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);
			! Shift in LSC_READ_FEATURE (0xE7) instruction;
			SDR 32	TDI (0x000000E7);
			I2C_RESTART;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_READ);
			SDR_VERIFY 96   TDI(#0^96)
							TDO(FeatureArray[1])
							MASK(0x00000000FF00000000000000);
			I2C_STOP;							
		}
		ELSE {		  
			I2C_STOP;
			I2C_START;
			! Shift in Slave Address;
			SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
			! Shift in ISC DISABLE(0x26) instruction;
			SDR	32 	TDI (0x00000064);
			I2C_STOP;
			print (1,"Failed to Program TraceID.");
		}
	}
}
function PROGRAM_FEABITS {
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{    		
	    FeatureBitsArray[1] = ArchArray_TDI[1];
	    //print (0,FeatureBitsArray);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SIR Instruction_Length	TDI (LSC_PROG_FEABITS);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    RUN_TEST IDLE TCK 2 ;
	    ! Shift in LSC_CHECK_BUSY(0xF0) instruction;
    	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
		loop PWP {
			RUN_TEST IDLE DELAY 1;
			SDR_VERIFY 1 TDI(#0) TDO(#0);
		}	  
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
	    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFF);   
	}
}

function SPIPROGRAM_FEABITS {
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureBitsArray[1] = ArchArray_TDI[1];
		FeatureBitsArray[1] = $FeatureBitsArray[1];
	    //print (0,FeatureBitsArray);
		setpin ISPEN Low;
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);
	    SDR 16 TDI(FeatureBitsArray[1]);
	    setpin ISPEN HIGH;	
		loop PWP {
			RUN_TEST DELAY PWV;
			setpin ISPEN LOW;
			! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	    	SDR 32 TDI (0x0000000F);
			SDR_VERIFY 1 TDI(#0) TDO(#0);
			setpin ISPEN HIGH;
		}	 
		setpin ISPEN HIGH;
		setpin ISPEN LOW;
		! Shift in LSC_READ_FEABITS (0xFB) instruction;
		SDR 32	TDI (0x000000DF);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFF);   
	    setpin ISPEN HIGH;
	}
}

function I2CPROGRAM_FEABITS{
	datastream FeatureBitsArray[1][16];
	IF (ArchArray_TDI.row = 1)
	{
		FeatureBitsArray[1] = ArchArray_TDI[1];
		FeatureBitsArray[1] = $FeatureBitsArray[1];
	    I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	    ! Shift in in LSC_PROG_FEABITS(0xF8) instruction;
	    SDR 32	TDI (0x0000001F);	    
	    SDR 16 TDI(FeatureBitsArray[1]);
	    I2C_STOP;	
	    RUN_TEST DELAY 1000;
		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in in LSC_READ_FEABITS(0xFB) instruction;
	    SDR 32	TDI (0x000000DF);
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 16   TDI(#0^16)
	    				TDO(FeatureBitsArray[1])
	    				MASK(0xFFFF);
	    I2C_STOP;		
	}
}
function PROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN1 for ECDSA by default
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN1 Fuses...");
	! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
	SIR Instruction_Length	TDI (LSC_PROG_AUTH_MODE);
	! Shift in Data; 
	SDR 8 TDI(0x01);
	RUN_TEST	IDLE TCK 2 DELAY PWP;
	print (0,"Verify the AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN1 (8) of the status register1
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SIR Instruction_Length TDI (LSC_READ_STATUS1);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00000100)
						MASK(0x00000100);				  		  		    
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}

function SPIPROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN1 for ECDSA by default
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN1 Fuses...");
	setpin ISPEN LOW;
	! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
	SDR 32	TDI (0x000080B3);
	setpin ISPEN HIGH;	
	print (0,"Verify the AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN1 (8) of the status register1
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00800000)
						MASK(0x00800000);
		setpin ISPEN HIGH;			  		  		    
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	32 	TDI (0x00000064);
		setpin ISPEN HIGH;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}

function I2CPROGRAM_AUTHENTICATION
{
	// HMAC Authentication will not supported for Sentry
	// Always program the AUTH_EN1 for ECDSA by default
	//Bit[0] of OPRAND1 = AUTH_EN1
	print (0,"Programming the AUTH_EN1 Fuses...");
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_PROG_AUTH_MODE(0xCD) instruction;
	SDR 32	TDI (0x000080B3);
	I2C_STOP;
	RUN_TEST DELAY PWP;
	print (0,"Verify the AUTH_EN1 fuses...");
	TRY 1 {
		// check bit AUTH_EN1 (8) of the status register1
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS1(0x3D) instruction;
		SDR 32 TDI (0x000000BC);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
						TDO(0x00800000)
						MASK(0x00800000);
		I2C_STOP;			  		  		    
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
		SDR	32 	TDI (0x00000064);
		I2C_STOP;
		print (1,"Failed to Program the AUTH_EN1 Fuses.");
	}
}
function FEATURE_ROW_READ{
	datastream FeatureRow[1][112];
	datastream FeatureArray[1][96];
	datastream FeatureBitsArray[1][16];
	file	NewFile = "FILE_SAVE"; 	
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEATURE);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 96  TDI(#0^96)
    		TDO(FeatureArray[1]);   	
   	
	! Shift in in LSC_READ_FEABITS(0xFB) instruction;
    SIR Instruction_Length	TDI (LSC_READ_FEABITS);
    RUN_TEST	IDLE TCK 2 DELAY 	PWV;
    SDR 16  TDI(#0^16)
    		TDO(FeatureBitsArray[1]);  
    FeatureRow[1] = (FeatureArray[1] @ FeatureBitsArray[1]);
	//print (0,FeatureRow);
	
	fopen	NewFile att "wa" format "SVF_Plus";
	fwrite	NewFile (STATUS_BIT,FeatureRow);
	fclose 	NewFile;
}

function SPIFEATURE_ROW_READ
{
	datastream SaveFeatureArray[1][96];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][112];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	SDR	96	TDI (#0^96)
			TDO	(SaveFeatureArray[1]);
	setpin ISPEN HIGH;
	SaveFeatureArray[1] = $SaveFeatureArray[1];
	setpin ISPEN LOW;
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	SDR	16	TDI (#0^16)
			TDO	(SaveFeatureBitsArray[1]);
	setpin ISPEN HIGH;
    SaveFeatureBitsArray[1] = $SaveFeatureBitsArray[1];
    FeatureSavedFuseMap[1] = (SaveFeatureArray[1] @ SaveFeatureBitsArray[1]); 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureSavedFuseMap);
	fclose 	NewFile;   	
}

function I2CFEATURE_ROW_READ{
	datastream SaveFeatureArray[1][96];
	datastream SaveFeatureBitsArray[1][16];
	datastream FeatureSavedFuseMap[1][112];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEATURE (0xE7) instruction;
	SDR 32	TDI (0x000000E7);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	96	TDI (#0^96)
			TDO	(SaveFeatureArray[1]);
	I2C_STOP;
	SaveFeatureArray[1] = $SaveFeatureArray[1];
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_FEABITS (0xFB) instruction;
	SDR 32	TDI (0x000000DF);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR	16	TDI (#0^16)
			TDO	(SaveFeatureBitsArray[1]);
	I2C_STOP;
    SaveFeatureBitsArray[1] = $SaveFeatureBitsArray[1];
    FeatureSavedFuseMap[1] = (SaveFeatureArray[1] @ SaveFeatureBitsArray[1]); 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (STATUS_BIT, FeatureSavedFuseMap);
	fclose 	NewFile;   	
}
function CFG0_PROGRAM_USERCODE
{
	IF (Usercode_TDI_CFG0.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI_CFG0[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function SPICFG0_PROGRAM_USERCODE
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}
function I2CCFG0_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function CFG1_PROGRAM_USERCODE 
{
	IF (Usercode_TDI_CFG1.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI_CFG1[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}
function SPICFG1_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}
function I2CCFG1_PROGRAM_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG1.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function PROGRAM_USERCODE {
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
		SDR Usercode_Length	TDI	(Usercode_TDI[1]);
		! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SIR Instruction_Length	TDI (ISC_PROGRAM_USERCODE);
		RUN_TEST	TCK 2   DELAY 	PWP;
	}
}

function SPIPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW;
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		setpin ISPEN HIGH;	
		RUN_TEST DELAY PWP;
	}
}

function I2CPROGRAM_USERCODE {
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	 	! Shift in ISC PROGRAM USERCODE(0xC2) instruction;
	    SDR 32	TDI (0x00000043);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR Usercode_Length	TDI	(SavedUsercode[1]);
		I2C_STOP;	
		RUN_TEST DELAY PWP;
	}
}
function CFG0_VERIFY_USERCODE 
{
	IF (Usercode_TDI_CFG0.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI_CFG0)
									MASK(0xFFFFFFFF);
	}
}
function SPICFG0_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG0.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CCFG0_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG0.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG0[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function CFG1_VERIFY_USERCODE 
{
	IF (Usercode_TDI_CFG1.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI_CFG1)
									MASK(0xFFFFFFFF);
	}
}
function SPICFG1_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG1.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CCFG1_VERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI_CFG1.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI_CFG1[1];
	    SavedUsercode[1] = $SavedUsercode[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function SRAM_VERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		Usercode_TDI[1] = $Usercode_TDI[1];
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI[1])
									MASK(0xFFFFFFFF);
	}
}
function VERIFY_USERCODE 
{
	IF (Usercode_TDI.row = 1)
	{
		! Shift in READ USERCODE(0xC0) instruction;
	    SIR Instruction_Length TDI (USERCODE);
	    RUN_TEST	TCK 2  DELAY 	PWV;
		SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(Usercode_TDI)
									MASK(0xFFFFFFFF);
	}
}
function SPIVERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		setpin ISPEN LOW; 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI[1];
	    SDR_VERIFY 	32 	TDI (#0^Usercode_Length)
					   	TDO	(SavedUsercode[1])
						MASK(0xFFFFFFFF);
		setpin ISPEN HIGH;									
	}
}	
function I2CVERIFY_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR 32 TDI (0x00000003);
	    SavedUsercode[1] = Usercode_TDI[1];
	    I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
	    SDR_VERIFY 	Usercode_Length TDI (#0^Usercode_Length)
									TDO	(SavedUsercode[1])
									MASK(0xFFFFFFFF);
		I2C_STOP;									
	}
}
function JTAGI2CVERIFY_USERCODE {
	datastream DataByte[1][8];
	datastream SavedUsercode[1][Usercode_Length];
	IF (Usercode_TDI.row = 1)
	{
		SavedUsercode[1] = Usercode_TDI[1];
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in Slave Address + WR;
		SDR	16	TDI ((0x90) @ ($SLAVE_ADDRESS_WRITE));
		RUN_TEST IDLE TCK 1000 ; 
		! Check ACK;
		! Shift in LSC_I2C_SR_RD(0x9F) instruction;
		SIR	8	TDI  (0x9F);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (0x04)
						MASK (0x24);
		! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		! Shift in READ USERCODE(0xC0) instruction;
	    SDR	16	TDI (0x10C0);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x1000);
		RUN_TEST IDLE TCK 1000 ; 
		! Shift in Slave Address + RD;
		SDR	16	TDI  ((0x90) @ ($SLAVE_ADDRESS_READ));
		RUN_TEST IDLE TCK 1000 ; 
		SDR	16	TDI  (0x2000);
		RUN_TEST IDLE TCK 1000 ; 
		DataByte[1] = SavedUsercode[1];
		! Shift in LSC_I2C_RXDR_RD(0x9E) instruction;
		SIR	8	TDI  (0x9E);
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 8);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);	
		DataByte[1] = (SavedUsercode[1] << 16);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);
		DataByte[1] = (SavedUsercode[1] << 24);
		RUN_TEST IDLE TCK 1000 ;
		SDR_VERIFY	8	TDI  (0x00)
						TDO  (DataByte[1])
						MASK (0xFF);										
	    ! Shift in LSC_I2C_TXDR_WT(0x9D) instruction;
		SIR	8	TDI  (0x9D);
		SDR	16	TDI  (0x5000);
		RUN_TEST IDLE TCK 1000 ; 									
	}
}
function VERIFY_SRAM_DONE_BIT {
	RUN_TEST	IDLE  TCK 100 DELAY 5000;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI (LSC_READ_STATUS0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000100)
			  		MASK(0x00002100);

}

function SPIVERIFY_SRAM_DONE_BIT {
	RUN_TEST DELAY 5000;
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000100)
			  		MASK(0x00002100);	
	setpin ISPEN HIGH;	
}

function I2CVERIFY_SRAM_DONE_BIT {
	RUN_TEST DELAY 5000;
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);	
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000100)
			  		MASK(0x00002100);		
	I2C_STOP;	
}
function DISABLE_REFRESH {	
	! Shift in ISC DISABLE(0x26) instruction;
    SIR	Instruction_Length 	TDI (ISC_DISABLE);
	RUN_TEST	IDLE  TCK 2 DELAY 1000;   
	
	! Shift in BYPASS(0xFF) instruction;
    SIR	Instruction_Length 	TDI (BYPASS);
	RUN_TEST	IDLE  TCK 2 DELAY 100;
}

function SPIDISABLE_REFRESH {
	setpin ISPEN LOW;
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    setpin ISPEN HIGH;
    RUN_TEST DELAY 200;
    setpin ISPEN LOW;
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    setpin ISPEN HIGH;
}

function I2CDISABLE_REFRESH {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC DISABLE(0x26) instruction;
    SDR	32 	TDI (0x00000064);
    I2C_STOP;
    RUN_TEST DELAY 200;
    I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_REFRESH(0x79) instruction;
    SDR 32	TDI (0x0000009E);
    I2C_STOP;
}
function FLASH_PROGRAM_DONE_BIT 
{
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SIR	Instruction_Length 	TDI (ISC_PROGRAM_DONE);
	RUN_TEST	IDLE TCK 2 ;
	! Shift in LSC_CHECK_BUSY(0xF0) instruction;
	SIR Instruction_Length TDI (LSC_CHECK_BUSY);
	loop PWP {
		RUN_TEST IDLE DELAY 1;
		SDR_VERIFY 1 TDI(#0) TDO(#0);
	}		
	TRY 1 {
		! Shift in BYPASS(0xFF) instruction;
    	SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
										TDO(0x04)
										MASK(0xC4);
	}
	ELSE {		  
		! Shift in ISC DISABLE(0x26) instruction;
		SIR	Instruction_Length 	TDI (ISC_DISABLE);
		RUN_TEST	IDLE  TCK 2 DELAY PWP;         
		! Shift in BYPASS(0xFF) instruction;
		SIR	Instruction_Length 	TDI (BYPASS);
		RUN_TEST	IDLE  TCK 2 DELAY PWV;
		print (1,"Failed to Program the Done bit.");
	}
}
function SPIFLASH_PROGRAM_DONE_BIT 
{
	setpin ISPEN LOW;
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	setpin ISPEN HIGH;	
	RUN_TEST DELAY PWP;		
	TRY 1 {
		setpin ISPEN LOW;
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x008C0000);
		setpin ISPEN HIGH;
	}
	ELSE {		  
		setpin ISPEN HIGH;
		setpin ISPEN LOW;	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    setpin ISPEN HIGH;
		print (1,"Failed to Program the DONE bit.");
	}
}

function I2CFLASH_PROGRAM_DONE_BIT 
{
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in ISC PROGRAM DONE(0x5E) instruction;
    SDR	32 	TDI (0x0000007A);
	I2C_STOP;	
	RUN_TEST DELAY PWP;
	TRY 1 {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_STATUS0(0x3C) instruction;
		SDR 32 TDI (0x0000003C);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  	TDO(0x00800000)
				  	MASK(0x008C0000);
		I2C_STOP;
	}
	ELSE {		  
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);	  
		! Shift in ISC DISABLE(0x26) instruction;
	    SDR	32 	TDI (0x00000064);
	    I2C_STOP;
		print (1,"Failed to Program the DONE bit.");
	}
}
function VERIFY_DONE_BIT {	
	RUN_TEST	IDLE  TCK 100 DELAY 5000;
	! Shift in BYPASS(0xFF) instruction;
    SIR_VERIFY	Instruction_Length 	TDI (BYPASS)
									TDO(0x04)
									MASK(0x84);	   	      	
}

function SPIVERIFY_DONE_BIT {	
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	setpin ISPEN HIGH;  	      	
}

function I2CVERIFY_DONE_BIT {	
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO (0x00800000)
			  	MASK(0x008C0000);
	I2C_STOP;  	      	
}
function CHECK_STATUS {
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SIR Instruction_Length TDI(LSC_READ_STATUS0);
	RUN_TEST IDLE TCK 2 DELAY PWV; 
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x00003000);
}

function SPICHECK_STATUS {
	setpin ISPEN LOW;
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	SDR_VERIFY  32 	TDI(#0^32)
			  		TDO(0x00000000)
			  		MASK(0x000C0000);
	setpin ISPEN HIGH;
}

function I2CCHECK_STATUS {
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE);
	! Shift in LSC_READ_STATUS0(0x3C) instruction;
	SDR 32 TDI (0x0000003C);
	I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
	SDR_VERIFY  32 	TDI(#0^32)
			  	TDO(0x00000000)
			  	MASK(0x000C0000);
	I2C_STOP;
}
function CFG0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap0[RowCount]);	
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function SPICFG0_SAVE_ARRAY 
{
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
    {	
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap0[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;
		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function I2CCFG0_SAVE_ARRAY 
{
	datastream SavedFuseMap0[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count{
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap0[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;
	}
	I2C_STOP;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG0, SavedFuseMap0);
	fclose 	NewFile;
}
function CFG1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_Row_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap1[RowCount]);	
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap0);
	fclose 	NewFile;
}
function SPICFG1_SAVE_ARRAY 
{
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
    {	
		setpin ISPEN LOW;
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI(#0^128)
				TDO	(SavedFuseMap1[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;
	}
	setpin ISPEN HIGH;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap0);
	fclose 	NewFile;
}
function I2CCFG1_SAVE_ARRAY 
{
	datastream SavedFuseMap1[Temp_Row_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_Row_Count
    {
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(SavedFuseMap1[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;
	}
	I2C_STOP;		
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (FuseArray_TDI_CFG1, SavedFuseMap0);
	fclose 	NewFile;
}
function UFM0_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM0_SAVE_ARRAY 
{
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM0_SAVE_ARRAY {
	datastream UFM0SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM0SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM0, UFM0SavedFuseMap);
	fclose 	NewFile;			
}
function UFM1_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM1_SAVE_ARRAY 
{
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM1_SAVE_ARRAY {
	datastream UFM1SavedFuseMap[Temp_UFM_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM1SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM1, UFM1SavedFuseMap);
	fclose 	NewFile;			
}
function UFM2_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM2_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM2_SAVE_ARRAY 
{
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM2_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM2_SAVE_ARRAY {
	datastream UFM2SavedFuseMap[Temp_UFM2_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM2_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM2SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM2, UFM2SavedFuseMap);
	fclose 	NewFile;			
}
function UFM3_SAVE_ARRAY 
{
	int32	RowCount = 1;
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	! Shift in LSC_READ_INCR_NV(0x73) instruction;
    SIR Instruction_Length	TDI	(LSC_READ_INCR_NV);
	repeat Temp_UFM3_Count
	{	
		RUN_TEST	IDLE TCK 2 DELAY 	PWV;
		! Shift out Data Row = RowCount; 
		SDR	128	TDI	(#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		RowCount = RowCount +1;
	}	
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function SPIUFM3_SAVE_ARRAY 
{
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM3_Count
	{	
		setpin ISPEN LOW;      	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);
		SDR 128 TDI (#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		setpin ISPEN HIGH;	
		setpin ISPEN LOW;
		SDR 32 TDI(#0^32);
		setpin ISPEN HIGH;	
		RowCount = RowCount +1;			
	}			
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function I2CUFM3_SAVE_ARRAY 
{
	datastream UFM3SavedFuseMap[Temp_UFM3_Count][128];
	file NewFile = "FILE_SAVE";
	repeat Temp_UFM3_Count
	{		
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);       	
		! Shift in LSC_READ_INCR_NV(0x73) instruction;
		SDR 32	TDI	(0x000084CE);	
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);	
		! Shift out Data Row = RowCount; 			
		SDR	128	TDI	(#0^128)
				TDO	(UFM3SavedFuseMap[RowCount]);
		I2C_STOP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		SDR 32	TDI	(#0^32);						
		I2C_STOP;						
		RowCount = RowCount +1;		
	}
	I2C_STOP;
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (EFuseArray_TDI_UFM3, UFM3SavedFuseMap);
	fclose 	NewFile;			
}
function CFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function SPICFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function I2CCFG0_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG0, SavedUsercode);
	fclose 	NewFile;
}
function CFG1_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	! Shift in READ USERCODE(0xC0) instruction;
    SIR Instruction_Length	TDI (USERCODE);
    RUN_TEST	TCK 2 DELAY 	PWV;
	SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, SavedUsercode);
	fclose 	NewFile;
}
function SPICFG1_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	setpin ISPEN LOW;
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    SDR	32	TDI(#0^Usercode_Length)
			TDO(SavedUsercode);
	setpin ISPEN HIGH;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, SavedUsercode);
	fclose 	NewFile;
}
function I2CCFG1_SAVE_USERCODE 
{
	datastream SavedUsercode[1][Usercode_Length];
	file NewFile = "FILE_SAVE";
	I2C_START;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_WRITE); 
	! Shift in READ USERCODE(0xC0) instruction;
    SDR 32	TDI (0x00000003);
    I2C_RESTART;
	! Shift in Slave Address;
	SDR	8	TDI (SLAVE_ADDRESS_READ);
    SDR	Usercode_Length	TDI(#0^Usercode_Length)
						TDO(SavedUsercode);
	I2C_STOP;
	SavedUsercode[1] = $SavedUsercode[1];
	// Write To file 
	fopen NewFile att "wa"
					 format "SVF_Plus";	
	fwrite NewFile (Usercode_TDI_CFG1, SavedUsercode);
	fclose 	NewFile;
}
function CSEC_PROGRAM_CENTRAL_LOCK
{
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SIR Instruction_Length	TDI (LSC_PROG_CSEC);
		SDR 32 TDI(CSEC_Array_TDI[1]);
		RUN_TEST IDLE TCK 2 DELAY PWP;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SIR Instruction_Length TDI (LSC_READ_CSEC);
		RUN_TEST IDLE TCK 2 DELAY PWV; 
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(CSEC_Array_TDI[1])
				  		MASK(CSEC_Array_TDI[1]);
	}
}
function SPICSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		setpin ISPEN LOW;
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		setpin ISPEN HIGH;
		RUN_TEST DELAY PWP;
		setpin ISPEN LOW;
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		setpin ISPEN HIGH;
	}
}
function I2CCSEC_PROGRAM_CENTRAL_LOCK
{
	datastream LockBitsArray[1][32];
	IF (CSEC_Array_TDI.row = 1)
	{
		// Bit0 SEC_ERASE_C_CFG0
		// Bit1 SEC_READ_C_CFG0
		// Bit2 SEC_HLOCK_C_CFG0
		// Bit3 SEC_ERASE_C_CFG1
		// Bit4 SEC_READ_C_CFG1
		// Bit5 SEC_HLOCK_C_CFG1
		// Bit6 SEC_ERASE_C_FEA
		// Bit7 SEC_READ_C_FEA
		// Bit8 SEC_HLOCK_C_FEA
		// Bit9 SEC_ERASE_C_PUBKEY
		// Bit10 SEC_READ_C_PUBKEY
		// Bit11 SEC_HLOCK_C_PUBKEY
		// Bit12 SEC_ERASE_C_AESKEY
		// Bit13 SEC_READ_C_AESKEY
		// Bit14 SEC_HLOCK_C_AESKEY
		LockBitsArray[1] = CSEC_Array_TDI[1];
		LockBitsArray[1] = $LockBitsArray[1];
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_PROG_CSEC(0x54) instruction;
		SDR 32	TDI (0x0000002A);
		SDR 32 TDI(LockBitsArray[1]);
		I2C_STOP;
		RUN_TEST DELAY PWP;
		I2C_START;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_WRITE);
		! Shift in LSC_READ_CSEC(0x55) instruction;
		SDR 32 TDI (0x000000AA);
		I2C_RESTART;
		! Shift in Slave Address;
		SDR	8	TDI (SLAVE_ADDRESS_READ);
		SDR_VERIFY  32 	TDI(#0^32)
				  		TDO(LockBitsArray[1])
				  		MASK(LockBitsArray[1]);
		I2C_STOP;
	}
}
]]>
</Script>
</SVF_Plus>